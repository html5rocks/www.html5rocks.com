{% extends "tutorial.html" %}

{% block head %}
<style>
  figure img { border: 1px solid #ccc; }
  .red { color:#ff0000; }
  .green { color:#00ff00;}
  #simple-pointer-lock { text-align:center; margin-left: auto; margin-right: auto; width: 10em; }
</style>
{% endblock %}

{% block browsersupport %}
<span class="browser opera supported"><span class="browser_name">Opera</span><span class="support">unsupported</span></span>
<span class="browser ie"><span class="browser_name">Internet Explorer</span><span class="support">supported</span></span>
<span class="browser safari supported"><span class="browser_name">Safari</span><span class="support">supported</span></span>
<span class="browser ff supported"><span class="browser_name">Firefox</span><span class="support">supported</span></span>
<span class="browser chrome supported"><span class="browser_name">Chrome</span><span class="support">supported</span></span>
{% endblock %}

{% block html5badge %}
<img src="/static/images/identity/html5-badge-h-graphics.png" width="133" height="64" alt="This article is powered by HTML5 Graphics, 3D &amp; Effects" title="This article is powered by HTML5 Graphics, 3D &amp; Effects" />
{% endblock %}

{% block iscompatible %}
{% endblock %}


{% block content %}

<h2 id="toc-introduction">Introduction</h2>

<p>
The Pointer Lock API helps properly implement first-person shooter controls in a browser game. Without relative mouse movement the player's cursor could, for example, hit the right edge of the screen and any further movements to the right would be discounted - the view would not continue to pan right, and the player would not be able to pursue the bad guys and strafe them with his machine gun. The player is going to get fragged and become frustrated. With pointer lock this suboptimal behaviour can't happen. </p>

<p>The <a href="https://developer.mozilla.org/en-US/docs/API/Pointer_Lock_API">Pointer Lock API</a> allows your application to do the following:
<ul>
	<li>Get access to raw mouse data including relative mouse movements</li>
	<li>Route all mouse events to a specific element</li>
</ul>
<p>
As a side effect of enabling pointer lock, the mouse cursor is hidden allowing you to choose to draw an application-specific pointer if you desire, or leave the mouse pointer hidden so that the user can move the frame with the mouse. Relative mouse movement is the mouse pointer position's delta from the previous frame regardless of absolute position.  For example, if the the mouse pointer moved from (640, 480) to (520, 490) the relative movement was (-120, 10). See below for an interactive example showing raw mouse position deltas.
</p>


<p>This tutorial covers two topics: the nuts and bolts of activating and processing pointer lock events, and implementing the first-person shooter control scheme. That's right, when you're finished reading this article you will know how to use pointer lock and implement Quake-style controls for your very own browser game!
</p>

<h2 id="toc-topic">Pointer Lock Mechanics</h2>

<h3 id="toc-topic-subtopic">Feature Detection</h3>

<p>To determine if the user's browser supports pointer lock you need to check for <code>pointerLockElement</code> or a vendor-prefixed version in the document object. In code:</p>

<pre class="prettyprint">
	var havePointerLock = 'pointerLockElement' in document    ||
			      'mozPointerLockElement' in document ||
			      'webkitPointerLockElement' in document;
</pre>

<p>Currently pointer lock is only available in Firefox and Chrome. Opera and IE do not yet support it.</p>

<!--
<div id="have-pointer-lock-result">Does my browser support pointer lock? <p class="red">No</p></div>
<script>
var havePointerLock = 'pointerLockElement' in document;
console.log(havePointerLock);
havePointerLock = havePointerLock || 'mozPointerLockElement' in document;
console.log(havePointerLock);
havePointerLock = havePointerLock || 'webkitPointerLockElement' in document;
console.log(havePointerLock);
if (havePointerLock) {
	document.getElementById('have-pointer-lock-result').innerHTML = 'Does my browser support pointer lock? <p class="green">Yes</p>';
} else {
	document.getElementById('have-pointer-lock-result').innerHTML = 'Does my browser support pointer lock? <p class="red">No</p>';
}
</script>
-->

<h3 id="toc-topic-subtopic">Activating</h3>

<p>Activating pointer lock is a two step process. First your application requests pointer lock be enabled for a specific element, and immediately after the user gives permission, a <code>pointerlockchange</code> event fires. The user can cancel pointer lock at any time by pressing the escape key. Your application can also progrmamatically exit pointer lock. When pointer lock is cancelled a <code>pointerlockchange</code> event fires.
</p>

<pre class="prettyprint">
	element.requestPointerLock = element.requestPointerLock ||
				     element.mozRequestPointerLock ||
				     element.webkitRequestPointerLock;
	// Ask the browser to lock the pointer
	element.requestPointerLock();

	// Ask the browser to release the pointer
	document.exitPointerLock = document.exitPointerLock ||
				   document.mozExitPointerLock ||
				   document.webkitExitPointerLock;
	document.exitPointerLock();
</pre>

<p>The above code is all it takes. When the browser locks the pointer a bubble will popup letting the user know that your application has locked the pointer and instructing them that they can cancel it by pressing the 'Esc' key.
</p>

<img src="static/popup.png" />

<h3 id="toc-topic-subtopic">Event Handling</h3>

<p>There are two events that your application must add listeners for. The first is <code>pointerlockchange</code>, which fires whenever a change in pointer lock state occurs. The second is <code>mousemove</code> which fires whenever the mouse has moved.</p>

<pre class="prettyprint">
// Hook pointer lock state change events
document.addEventListener('pointerlockchange', changeCallback, false);
document.addEventListener('mozpointerlockchange', changeCallback, false);
document.addEventListener('webkitpointerlockchange', changeCallback, false);

// Hook mouse move events
document.addEventListener("mousemove", this.moveCallback, false);
</pre>

<p class="notice">NOTE: Because of vendor-prefixing, you will have to listen for <code>pointerlockchange</code>, <code>mozpointerlockchange</code>, and <code>webkitpointerlockchange</code>events to be cross-browser compatible.</p>

<p>Inside your <code>pointerlockchange</code> callback you must check if the pointer has just been locked or unlocked. Determining if pointer lock was enabled is simple: check if document.pointerLockElement is equal to the element that pointer lock was requested for. If it is, your application successfully locked the pointer and if it is not, the pointer was unlocked by the user or your own code.</p>

<pre class="prettyprint">
if (document.pointerLockElement === requestedElement ||
	document.mozPointerLockElement === requestedElement ||
	document.webkitPointerLockElement === requestedElement) {
	// Pointer was just locked
	// Enable the mousemove listener
	document.addEventListener("mousemove", this.moveCallback, false);
} else {
	// Pointer was just unlocked
	// Disable the mousemove listener
	document.removeEventListener("mousemove", this.moveCallback, false);
	this.unlockHook(this.element);
}
</pre>

<p>
 When pointer lock is enabled <code>clientX</code>, <code>clientY</code>, <code>screenX</code>, and <code>screenY</code> remain constant. <code>movementX</code> and <code>movementY</code> are updated with the number of pixels the pointer would have moved since the last event was delivered. In pseudo-code:</p>

<pre class="prettyprint">
event.movementX = currentCursorPositionX - previousCursorPositionX;
event.movementY = currentCursorPositionY - previousCursorPositionY;
</pre>

<p>Inside the <code>mousemove</code> callback relative mouse motion data can be extracted from the event's <code>movementX</code> and <code>movementY</code> fields.</p>
<pre class="prettyprint">
function moveCallback(e) {
	var movementX = e.movementX       ||
			e.mozMovementX    ||
			e.webkitMovementX ||
			0,
	movementY = e.movementY 	  ||
			e.mozMovementY    ||
			e.webkitMovementY ||
			0;
}
</pre>

<p class="notice">NOTE: The movement fields also have vendor-prefixes</p>

<h3 id="toc-topic-subtopic">Interactive Example</h3>
<p>Interactive example time. When you click on the 'Click me!' box, your pointer will be locked and the relative mouse movements will be displayed. The raw data is displayed with no extra processing. You should be able to see that the origin is in the upper left hand of the screen with positive movements going to the right and down.</p>
<div id="simple-pointer-lock">
	<p class="notice">Click me!</p>
</div>

<h3 id="toc-topic-subtopic">Catching errors</h3>
<p>If an error is raised by either entering or exiting pointer lock the <code>pointerlockerror</code> event fires. There is no data attached to this event.</p>

<pre class="prettyprint">
document.addEventListener('pointerlockerror', errorCallback, false);
document.addEventListener('mozpointerlockerror', errorCallback, false);
document.addEventListener('webkitpointerlockerror', errorCallback, false);
</pre>

<h3 id="toc-topic-subtopic">Full-screen Required?</h3>

<p>Originally pointer lock was tied to the FullScreen API. Meaning that an element must be in fullscreen mode before it can have the pointer locked to it. That is no longer true and pointer lock can be used for any element in your application full-screen or not.</p>

<h2 id="toc-topic">First-Person Shooter Controls Example</h2>

<p>Now that we have pointer lock enabled and receiving events, it's time for a practical example. Have you ever wanted to know how the controls in Quake work? Strap in because I'm about to explain them with code!</p>

<p>First-person shooter controls are built around four core mechanics:</p>

<ul>
  <li>Moving forward and backward along the current look vector</li>
  <li>Moving left and right along the current strafe vector</li>
  <li>Rotating the view yaw (left and right)</li>
  <li>Rotating the view pitch (up and down)</li>
</ul>

<p>A game implementing this control scheme needs only three pieces of data: camera position, camera look vector, and a constant up vector. The up vector is always (0, 1, 0). All four of the above mechanics just manipulate the camera position and camera look vector in different ways.</p>

<h3 id="toc-topic-subtopic">Movement</h3>

<p>First on deck is movement. In the demo below movement is mapped to the standard W, A, S, and D keys. The W and S keys drive the camera forward and backward. While the A and D keys drive the camera to the left and right. Moving the camera forward and backward is simple:</p>

<pre class="prettyprint">
// Forward direction
var forwardDirection = vec3.create(cameraLookVector);
// Speed
var forwardSpeed = dt * cameraSpeed;
// Forward or backward depending on keys held
var forwardScale = 0.0;
forwardScale += keyState.W ? 1.0 : 0.0;
forwardScale -= keyState.S ? 1.0 : 0.0;
// Scale movement
vec3.scale(forwardDirection, forwardScale * forwardSpeed);
// Add scaled movement to camera position
vec3.add(cameraPosition, forwardDirection);
</pre>

<p>Strafing left and right requires a strafe direction. The strafe direction can be computed using the cross product:</p>

<pre class="prettyprint">
// Strafe direction
var strafeDirection = vec3.create();
vec3.cross(cameraLookVector, cameraUpVector, strafeDirection);
</pre>

<p>Once you have the strafe direction, implementing strafe movement is the same as moving forward or backward.</p>

<p>Below is a demo that only has movement implemented. We will build to a completely working demo by the end.</p>

<canvas id="webGLFrontBufferMovement" style="margin-left: auto; margin-right: auto; display:block; padding-left: 0; padding-right: 0;"></canvas>

<p>Next up is rotating the view.</p>

<h3 id="toc-topic-subtopic">Yaw</h3>
<p>Yaw or the horizontal rotation of the camera view is just a rotation around the constant up vector. Below is general code for rotating the camera look vector around an arbitrary axis. It works by constructing a <a href="http://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation">quaternion</a> representing the rotation of <code>deltaAngle</code> radians around <code>axis</code> and then uses the quaternion to rotate the camera look vector:</p>

<pre class="prettyprint">
// Extract camera look vector
var frontDirection = vec3.create();
vec3.subtract(this.lookAtPoint, this.eyePoint, frontDirection);
vec3.normalize(frontDirection);
var q = quat4.create();
// Construct quaternion 
quat4.fromAngleAxis(deltaAngle, axis, q);
// Rotate camera look vector
quat4.multiplyVec3(q, frontDirection);
// Update camera look vector
this.lookAtPoint = vec3.create(this.eyePoint);
vec3.add(this.lookAtPoint, frontDirection);
</pre>

<p>The demo below only has yaw working.</p>

<canvas id="webGLFrontBufferYaw" style="margin-left: auto; margin-right: auto; display:block; padding-left: 0; padding-right: 0;"></canvas>

<h3 id="toc-topic-subtopic">Pitch</h3>
<p>Implementing pitch or the vertical rotation of the camera view is similar but instead of a rotation around the up vector you apply a rotation around the strafe vector. The first step is to compute the strafe vector and then rotate the camera look vector around that axis.</p>

<p>The demo below only has pitch working.</p>

<canvas id="webGLFrontBufferPitch" style="margin-left: auto; margin-right: auto; display:block; padding-left: 0; padding-right: 0;"></canvas>

<h3 id="toc-topic-subtopic">Putting it all together</h3>
<p>Below is a fully working interactive example that combines pointer lock and first-person shooter controls. Click on the element to active the control.</p>

<canvas id="webGLFrontBuffer" style="margin-left: auto; margin-right: auto; display:block; padding-left: 0; padding-right: 0;"></canvas>

<h2 id="toc-topic-subtopic">Summary</h2>
<p>The Pointer Lock API allows you to take control of the mouse cursor. If you're making web games your players will love it when they stop getting fragged because they excitedly moved mouse out of the window and your game stopped getting mouse updates. Usage is simple:</p>

<ul>
	<li>Add <code>pointerlockchange</code> event listener to track the state of pointer lock</li>
	<li>Request pointer lock for a specific element</li>
	<li>Add <code>mousemove</code> event listener to get updates</li>
</ul>

<h2 id="toc-references">External Demos</h2>
<ul>
  <li><a href="http://media.tojicode.com/q3bsp/">Quake 3 Map Viewer</a></li>
  <li><a href="http://www.youtube.com/watch?v=onD-avVQXFk">Video demonstration</a></li>
</ul>

<h2 id="toc-references">References</h2>
<ul>
  <li><a href="https://developer.mozilla.org/en/API/Mouse_Lock_API">Mozilla Developer Network API documentation</a></li>
</ul>

<script>

/* 
 * glMatrix.js - High performance matrix and vector operations for WebGL
 * version 0.9.6
 */
 
/*
 * Copyright (c) 2011 Brandon Jones
 *
 * This software is provided 'as-is', without any express or implied
 * warranty. In no event will the authors be held liable for any damages
 * arising from the use of this software.
 *
 * Permission is granted to anyone to use this software for any purpose,
 * including commercial applications, and to alter it and redistribute it
 * freely, subject to the following restrictions:
 *
 *    1. The origin of this software must not be misrepresented; you must not
 *    claim that you wrote the original software. If you use this software
 *    in a product, an acknowledgment in the product documentation would be
 *    appreciated but is not required.
 *
 *    2. Altered source versions must be plainly marked as such, and must not
 *    be misrepresented as being the original software.
 *
 *    3. This notice may not be removed or altered from any source
 *    distribution.
 */

// Fallback for systems that don't support WebGL
if(typeof Float32Array != 'undefined') {
	glMatrixArrayType = Float32Array;
} else if(typeof WebGLFloatArray != 'undefined') {
	glMatrixArrayType = WebGLFloatArray; // This is officially deprecated and should dissapear in future revisions.
} else {
	glMatrixArrayType = Array;
}

/*
 * vec3 - 3 Dimensional Vector
 */
var vec3 = {};

/*
 * vec3.create
 * Creates a new instance of a vec3 using the default array type
 * Any javascript array containing at least 3 numeric elements can serve as a vec3
 *
 * Params:
 * vec - Optional, vec3 containing values to initialize with
 *
 * Returns:
 * New vec3
 */
vec3.create = function(vec) {
	var dest = new glMatrixArrayType(3);
	
	if(vec) {
		dest[0] = vec[0];
		dest[1] = vec[1];
		dest[2] = vec[2];
	}
	
	return dest;
};

/*
 * vec3.set
 * Copies the values of one vec3 to another
 *
 * Params:
 * vec - vec3 containing values to copy
 * dest - vec3 receiving copied values
 *
 * Returns:
 * dest
 */
vec3.set = function(vec, dest) {
	dest[0] = vec[0];
	dest[1] = vec[1];
	dest[2] = vec[2];
	
	return dest;
};

/*
 * vec3.add
 * Performs a vector addition
 *
 * Params:
 * vec - vec3, first operand
 * vec2 - vec3, second operand
 * dest - Optional, vec3 receiving operation result. If not specified result is written to vec
 *
 * Returns:
 * dest if specified, vec otherwise
 */
vec3.add = function(vec, vec2, dest) {
	if(!dest || vec == dest) {
		vec[0] += vec2[0];
		vec[1] += vec2[1];
		vec[2] += vec2[2];
		return vec;
	}
	
	dest[0] = vec[0] + vec2[0];
	dest[1] = vec[1] + vec2[1];
	dest[2] = vec[2] + vec2[2];
	return dest;
};

/*
 * vec3.subtract
 * Performs a vector subtraction
 *
 * Params:
 * vec - vec3, first operand
 * vec2 - vec3, second operand
 * dest - Optional, vec3 receiving operation result. If not specified result is written to vec
 *
 * Returns:
 * dest if specified, vec otherwise
 */
vec3.subtract = function(vec, vec2, dest) {
	if(!dest || vec == dest) {
		vec[0] -= vec2[0];
		vec[1] -= vec2[1];
		vec[2] -= vec2[2];
		return vec;
	}
	
	dest[0] = vec[0] - vec2[0];
	dest[1] = vec[1] - vec2[1];
	dest[2] = vec[2] - vec2[2];
	return dest;
};

/*
 * vec3.negate
 * Negates the components of a vec3
 *
 * Params:
 * vec - vec3 to negate
 * dest - Optional, vec3 receiving operation result. If not specified result is written to vec
 *
 * Returns:
 * dest if specified, vec otherwise
 */
vec3.negate = function(vec, dest) {
	if(!dest) { dest = vec; }
	
	dest[0] = -vec[0];
	dest[1] = -vec[1];
	dest[2] = -vec[2];
	return dest;
};

/*
 * vec3.scale
 * Multiplies the components of a vec3 by a scalar value
 *
 * Params:
 * vec - vec3 to scale
 * val - Numeric value to scale by
 * dest - Optional, vec3 receiving operation result. If not specified result is written to vec
 *
 * Returns:
 * dest if specified, vec otherwise
 */
vec3.scale = function(vec, val, dest) {
	if(!dest || vec == dest) {
		vec[0] *= val;
		vec[1] *= val;
		vec[2] *= val;
		return vec;
	}
	
	dest[0] = vec[0]*val;
	dest[1] = vec[1]*val;
	dest[2] = vec[2]*val;
	return dest;
};

/*
 * vec3.normalize
 * Generates a unit vector of the same direction as the provided vec3
 * If vector length is 0, returns [0, 0, 0]
 *
 * Params:
 * vec - vec3 to normalize
 * dest - Optional, vec3 receiving operation result. If not specified result is written to vec
 *
 * Returns:
 * dest if specified, vec otherwise
 */
vec3.normalize = function(vec, dest) {
	if(!dest) { dest = vec; }
	
	var x = vec[0], y = vec[1], z = vec[2];
	var len = Math.sqrt(x*x + y*y + z*z);
	
	if (!len) {
		dest[0] = 0;
		dest[1] = 0;
		dest[2] = 0;
		return dest;
	} else if (len == 1) {
		dest[0] = x;
		dest[1] = y;
		dest[2] = z;
		return dest;
	}
	
	len = 1 / len;
	dest[0] = x*len;
	dest[1] = y*len;
	dest[2] = z*len;
	return dest;
};

/*
 * vec3.cross
 * Generates the cross product of two vec3s
 *
 * Params:
 * vec - vec3, first operand
 * vec2 - vec3, second operand
 * dest - Optional, vec3 receiving operation result. If not specified result is written to vec
 *
 * Returns:
 * dest if specified, vec otherwise
 */
vec3.cross = function(vec, vec2, dest){
	if(!dest) { dest = vec; }
	
	var x = vec[0], y = vec[1], z = vec[2];
	var x2 = vec2[0], y2 = vec2[1], z2 = vec2[2];
	
	dest[0] = y*z2 - z*y2;
	dest[1] = z*x2 - x*z2;
	dest[2] = x*y2 - y*x2;
	return dest;
};

/*
 * vec3.length
 * Caclulates the length of a vec3
 *
 * Params:
 * vec - vec3 to calculate length of
 *
 * Returns:
 * Length of vec
 */
vec3.length = function(vec){
	var x = vec[0], y = vec[1], z = vec[2];
	return Math.sqrt(x*x + y*y + z*z);
};

/*
 * vec3.dot
 * Caclulates the dot product of two vec3s
 *
 * Params:
 * vec - vec3, first operand
 * vec2 - vec3, second operand
 *
 * Returns:
 * Dot product of vec and vec2
 */
vec3.dot = function(vec, vec2){
	return vec[0]*vec2[0] + vec[1]*vec2[1] + vec[2]*vec2[2];
};

/*
 * vec3.direction
 * Generates a unit vector pointing from one vector to another
 *
 * Params:
 * vec - origin vec3
 * vec2 - vec3 to point to
 * dest - Optional, vec3 receiving operation result. If not specified result is written to vec
 *
 * Returns:
 * dest if specified, vec otherwise
 */
vec3.direction = function(vec, vec2, dest) {
	if(!dest) { dest = vec; }
	
	var x = vec[0] - vec2[0];
	var y = vec[1] - vec2[1];
	var z = vec[2] - vec2[2];
	
	var len = Math.sqrt(x*x + y*y + z*z);
	if (!len) { 
		dest[0] = 0; 
		dest[1] = 0; 
		dest[2] = 0;
		return dest; 
	}
	
	len = 1 / len;
	dest[0] = x * len; 
	dest[1] = y * len; 
	dest[2] = z * len;
	return dest; 
};

/*
 * vec3.lerp
 * Performs a linear interpolation between two vec3
 *
 * Params:
 * vec - vec3, first vector
 * vec2 - vec3, second vector
 * lerp - interpolation amount between the two inputs
 * dest - Optional, vec3 receiving operation result. If not specified result is written to vec
 *
 * Returns:
 * dest if specified, vec otherwise
 */
vec3.lerp = function(vec, vec2, lerp, dest){
    if(!dest) { dest = vec; }
    
    dest[0] = vec[0] + lerp * (vec2[0] - vec[0]);
    dest[1] = vec[1] + lerp * (vec2[1] - vec[1]);
    dest[2] = vec[2] + lerp * (vec2[2] - vec[2]);
    
    return dest;
}

/*
 * vec3.str
 * Returns a string representation of a vector
 *
 * Params:
 * vec - vec3 to represent as a string
 *
 * Returns:
 * string representation of vec
 */
vec3.str = function(vec) {
	return '[' + vec[0] + ', ' + vec[1] + ', ' + vec[2] + ']'; 
};

/*
 * mat3 - 3x3 Matrix
 */
var mat3 = {};

/*
 * mat3.create
 * Creates a new instance of a mat3 using the default array type
 * Any javascript array containing at least 9 numeric elements can serve as a mat3
 *
 * Params:
 * mat - Optional, mat3 containing values to initialize with
 *
 * Returns:
 * New mat3
 */
mat3.create = function(mat) {
	var dest = new glMatrixArrayType(9);
	
	if(mat) {
		dest[0] = mat[0];
		dest[1] = mat[1];
		dest[2] = mat[2];
		dest[3] = mat[3];
		dest[4] = mat[4];
		dest[5] = mat[5];
		dest[6] = mat[6];
		dest[7] = mat[7];
		dest[8] = mat[8];
	}
	
	return dest;
};

/*
 * mat3.set
 * Copies the values of one mat3 to another
 *
 * Params:
 * mat - mat3 containing values to copy
 * dest - mat3 receiving copied values
 *
 * Returns:
 * dest
 */
mat3.set = function(mat, dest) {
	dest[0] = mat[0];
	dest[1] = mat[1];
	dest[2] = mat[2];
	dest[3] = mat[3];
	dest[4] = mat[4];
	dest[5] = mat[5];
	dest[6] = mat[6];
	dest[7] = mat[7];
	dest[8] = mat[8];
	return dest;
};

/*
 * mat3.identity
 * Sets a mat3 to an identity matrix
 *
 * Params:
 * dest - mat3 to set
 *
 * Returns:
 * dest
 */
mat3.identity = function(dest) {
	dest[0] = 1;
	dest[1] = 0;
	dest[2] = 0;
	dest[3] = 0;
	dest[4] = 1;
	dest[5] = 0;
	dest[6] = 0;
	dest[7] = 0;
	dest[8] = 1;
	return dest;
};

/*
 * mat4.transpose
 * Transposes a mat3 (flips the values over the diagonal)
 *
 * Params:
 * mat - mat3 to transpose
 * dest - Optional, mat3 receiving transposed values. If not specified result is written to mat
 *
 * Returns:
 * dest is specified, mat otherwise
 */
mat3.transpose = function(mat, dest) {
	// If we are transposing ourselves we can skip a few steps but have to cache some values
	if(!dest || mat == dest) { 
		var a01 = mat[1], a02 = mat[2];
		var a12 = mat[5];
		
        mat[1] = mat[3];
        mat[2] = mat[6];
        mat[3] = a01;
        mat[5] = mat[7];
        mat[6] = a02;
        mat[7] = a12;
		return mat;
	}
	
	dest[0] = mat[0];
	dest[1] = mat[3];
	dest[2] = mat[6];
	dest[3] = mat[1];
	dest[4] = mat[4];
	dest[5] = mat[7];
	dest[6] = mat[2];
	dest[7] = mat[5];
	dest[8] = mat[8];
	return dest;
};

/*
 * mat3.toMat4
 * Copies the elements of a mat3 into the upper 3x3 elements of a mat4
 *
 * Params:
 * mat - mat3 containing values to copy
 * dest - Optional, mat4 receiving copied values
 *
 * Returns:
 * dest if specified, a new mat4 otherwise
 */
mat3.toMat4 = function(mat, dest) {
	if(!dest) { dest = mat4.create(); }
	
	dest[0] = mat[0];
	dest[1] = mat[1];
	dest[2] = mat[2];
	dest[3] = 0;

	dest[4] = mat[3];
	dest[5] = mat[4];
	dest[6] = mat[5];
	dest[7] = 0;

	dest[8] = mat[6];
	dest[9] = mat[7];
	dest[10] = mat[8];
	dest[11] = 0;

	dest[12] = 0;
	dest[13] = 0;
	dest[14] = 0;
	dest[15] = 1;
	
	return dest;
}

/*
 * mat3.str
 * Returns a string representation of a mat3
 *
 * Params:
 * mat - mat3 to represent as a string
 *
 * Returns:
 * string representation of mat
 */
mat3.str = function(mat) {
	return '[' + mat[0] + ', ' + mat[1] + ', ' + mat[2] + 
		', ' + mat[3] + ', '+ mat[4] + ', ' + mat[5] + 
		', ' + mat[6] + ', ' + mat[7] + ', '+ mat[8] + ']';
};

/*
 * mat4 - 4x4 Matrix
 */
var mat4 = {};

/*
 * mat4.create
 * Creates a new instance of a mat4 using the default array type
 * Any javascript array containing at least 16 numeric elements can serve as a mat4
 *
 * Params:
 * mat - Optional, mat4 containing values to initialize with
 *
 * Returns:
 * New mat4
 */
mat4.create = function(mat) {
	var dest = new glMatrixArrayType(16);
	
	if(mat) {
		dest[0] = mat[0];
		dest[1] = mat[1];
		dest[2] = mat[2];
		dest[3] = mat[3];
		dest[4] = mat[4];
		dest[5] = mat[5];
		dest[6] = mat[6];
		dest[7] = mat[7];
		dest[8] = mat[8];
		dest[9] = mat[9];
		dest[10] = mat[10];
		dest[11] = mat[11];
		dest[12] = mat[12];
		dest[13] = mat[13];
		dest[14] = mat[14];
		dest[15] = mat[15];
	}
	
	return dest;
};

/*
 * mat4.set
 * Copies the values of one mat4 to another
 *
 * Params:
 * mat - mat4 containing values to copy
 * dest - mat4 receiving copied values
 *
 * Returns:
 * dest
 */
mat4.set = function(mat, dest) {
	dest[0] = mat[0];
	dest[1] = mat[1];
	dest[2] = mat[2];
	dest[3] = mat[3];
	dest[4] = mat[4];
	dest[5] = mat[5];
	dest[6] = mat[6];
	dest[7] = mat[7];
	dest[8] = mat[8];
	dest[9] = mat[9];
	dest[10] = mat[10];
	dest[11] = mat[11];
	dest[12] = mat[12];
	dest[13] = mat[13];
	dest[14] = mat[14];
	dest[15] = mat[15];
	return dest;
};

/*
 * mat4.identity
 * Sets a mat4 to an identity matrix
 *
 * Params:
 * dest - mat4 to set
 *
 * Returns:
 * dest
 */
mat4.identity = function(dest) {
	dest[0] = 1;
	dest[1] = 0;
	dest[2] = 0;
	dest[3] = 0;
	dest[4] = 0;
	dest[5] = 1;
	dest[6] = 0;
	dest[7] = 0;
	dest[8] = 0;
	dest[9] = 0;
	dest[10] = 1;
	dest[11] = 0;
	dest[12] = 0;
	dest[13] = 0;
	dest[14] = 0;
	dest[15] = 1;
	return dest;
};

/*
 * mat4.transpose
 * Transposes a mat4 (flips the values over the diagonal)
 *
 * Params:
 * mat - mat4 to transpose
 * dest - Optional, mat4 receiving transposed values. If not specified result is written to mat
 *
 * Returns:
 * dest is specified, mat otherwise
 */
mat4.transpose = function(mat, dest) {
	// If we are transposing ourselves we can skip a few steps but have to cache some values
	if(!dest || mat == dest) { 
		var a01 = mat[1], a02 = mat[2], a03 = mat[3];
		var a12 = mat[6], a13 = mat[7];
		var a23 = mat[11];
		
		mat[1] = mat[4];
		mat[2] = mat[8];
		mat[3] = mat[12];
		mat[4] = a01;
		mat[6] = mat[9];
		mat[7] = mat[13];
		mat[8] = a02;
		mat[9] = a12;
		mat[11] = mat[14];
		mat[12] = a03;
		mat[13] = a13;
		mat[14] = a23;
		return mat;
	}
	
	dest[0] = mat[0];
	dest[1] = mat[4];
	dest[2] = mat[8];
	dest[3] = mat[12];
	dest[4] = mat[1];
	dest[5] = mat[5];
	dest[6] = mat[9];
	dest[7] = mat[13];
	dest[8] = mat[2];
	dest[9] = mat[6];
	dest[10] = mat[10];
	dest[11] = mat[14];
	dest[12] = mat[3];
	dest[13] = mat[7];
	dest[14] = mat[11];
	dest[15] = mat[15];
	return dest;
};

/*
 * mat4.determinant
 * Calculates the determinant of a mat4
 *
 * Params:
 * mat - mat4 to calculate determinant of
 *
 * Returns:
 * determinant of mat
 */
mat4.determinant = function(mat) {
	// Cache the matrix values (makes for huge speed increases!)
	var a00 = mat[0], a01 = mat[1], a02 = mat[2], a03 = mat[3];
	var a10 = mat[4], a11 = mat[5], a12 = mat[6], a13 = mat[7];
	var a20 = mat[8], a21 = mat[9], a22 = mat[10], a23 = mat[11];
	var a30 = mat[12], a31 = mat[13], a32 = mat[14], a33 = mat[15];

	return	a30*a21*a12*a03 - a20*a31*a12*a03 - a30*a11*a22*a03 + a10*a31*a22*a03 +
			a20*a11*a32*a03 - a10*a21*a32*a03 - a30*a21*a02*a13 + a20*a31*a02*a13 +
			a30*a01*a22*a13 - a00*a31*a22*a13 - a20*a01*a32*a13 + a00*a21*a32*a13 +
			a30*a11*a02*a23 - a10*a31*a02*a23 - a30*a01*a12*a23 + a00*a31*a12*a23 +
			a10*a01*a32*a23 - a00*a11*a32*a23 - a20*a11*a02*a33 + a10*a21*a02*a33 +
			a20*a01*a12*a33 - a00*a21*a12*a33 - a10*a01*a22*a33 + a00*a11*a22*a33;
};

/*
 * mat4.inverse
 * Calculates the inverse matrix of a mat4
 *
 * Params:
 * mat - mat4 to calculate inverse of
 * dest - Optional, mat4 receiving inverse matrix. If not specified result is written to mat
 *
 * Returns:
 * dest is specified, mat otherwise
 */
mat4.inverse = function(mat, dest) {
	if(!dest) { dest = mat; }
	
	// Cache the matrix values (makes for huge speed increases!)
	var a00 = mat[0], a01 = mat[1], a02 = mat[2], a03 = mat[3];
	var a10 = mat[4], a11 = mat[5], a12 = mat[6], a13 = mat[7];
	var a20 = mat[8], a21 = mat[9], a22 = mat[10], a23 = mat[11];
	var a30 = mat[12], a31 = mat[13], a32 = mat[14], a33 = mat[15];
	
	var b00 = a00*a11 - a01*a10;
	var b01 = a00*a12 - a02*a10;
	var b02 = a00*a13 - a03*a10;
	var b03 = a01*a12 - a02*a11;
	var b04 = a01*a13 - a03*a11;
	var b05 = a02*a13 - a03*a12;
	var b06 = a20*a31 - a21*a30;
	var b07 = a20*a32 - a22*a30;
	var b08 = a20*a33 - a23*a30;
	var b09 = a21*a32 - a22*a31;
	var b10 = a21*a33 - a23*a31;
	var b11 = a22*a33 - a23*a32;
	
	// Calculate the determinant (inlined to avoid double-caching)
	var invDet = 1/(b00*b11 - b01*b10 + b02*b09 + b03*b08 - b04*b07 + b05*b06);
	
	dest[0] = (a11*b11 - a12*b10 + a13*b09)*invDet;
	dest[1] = (-a01*b11 + a02*b10 - a03*b09)*invDet;
	dest[2] = (a31*b05 - a32*b04 + a33*b03)*invDet;
	dest[3] = (-a21*b05 + a22*b04 - a23*b03)*invDet;
	dest[4] = (-a10*b11 + a12*b08 - a13*b07)*invDet;
	dest[5] = (a00*b11 - a02*b08 + a03*b07)*invDet;
	dest[6] = (-a30*b05 + a32*b02 - a33*b01)*invDet;
	dest[7] = (a20*b05 - a22*b02 + a23*b01)*invDet;
	dest[8] = (a10*b10 - a11*b08 + a13*b06)*invDet;
	dest[9] = (-a00*b10 + a01*b08 - a03*b06)*invDet;
	dest[10] = (a30*b04 - a31*b02 + a33*b00)*invDet;
	dest[11] = (-a20*b04 + a21*b02 - a23*b00)*invDet;
	dest[12] = (-a10*b09 + a11*b07 - a12*b06)*invDet;
	dest[13] = (a00*b09 - a01*b07 + a02*b06)*invDet;
	dest[14] = (-a30*b03 + a31*b01 - a32*b00)*invDet;
	dest[15] = (a20*b03 - a21*b01 + a22*b00)*invDet;
	
	return dest;
};

/*
 * mat4.toRotationMat
 * Copies the upper 3x3 elements of a mat4 into another mat4
 *
 * Params:
 * mat - mat4 containing values to copy
 * dest - Optional, mat4 receiving copied values
 *
 * Returns:
 * dest is specified, a new mat4 otherwise
 */
mat4.toRotationMat = function(mat, dest) {
	if(!dest) { dest = mat4.create(); }
	
	dest[0] = mat[0];
	dest[1] = mat[1];
	dest[2] = mat[2];
	dest[3] = mat[3];
	dest[4] = mat[4];
	dest[5] = mat[5];
	dest[6] = mat[6];
	dest[7] = mat[7];
	dest[8] = mat[8];
	dest[9] = mat[9];
	dest[10] = mat[10];
	dest[11] = mat[11];
	dest[12] = 0;
	dest[13] = 0;
	dest[14] = 0;
	dest[15] = 1;
	
	return dest;
};

/*
 * mat4.toMat3
 * Copies the upper 3x3 elements of a mat4 into a mat3
 *
 * Params:
 * mat - mat4 containing values to copy
 * dest - Optional, mat3 receiving copied values
 *
 * Returns:
 * dest is specified, a new mat3 otherwise
 */
mat4.toMat3 = function(mat, dest) {
	if(!dest) { dest = mat3.create(); }
	
	dest[0] = mat[0];
	dest[1] = mat[1];
	dest[2] = mat[2];
	dest[3] = mat[4];
	dest[4] = mat[5];
	dest[5] = mat[6];
	dest[6] = mat[8];
	dest[7] = mat[9];
	dest[8] = mat[10];
	
	return dest;
};

/*
 * mat4.toInverseMat3
 * Calculates the inverse of the upper 3x3 elements of a mat4 and copies the result into a mat3
 * The resulting matrix is useful for calculating transformed normals
 *
 * Params:
 * mat - mat4 containing values to invert and copy
 * dest - Optional, mat3 receiving values
 *
 * Returns:
 * dest is specified, a new mat3 otherwise
 */
mat4.toInverseMat3 = function(mat, dest) {
	// Cache the matrix values (makes for huge speed increases!)
	var a00 = mat[0], a01 = mat[1], a02 = mat[2];
	var a10 = mat[4], a11 = mat[5], a12 = mat[6];
	var a20 = mat[8], a21 = mat[9], a22 = mat[10];
	
	var b01 = a22*a11-a12*a21;
	var b11 = -a22*a10+a12*a20;
	var b21 = a21*a10-a11*a20;
		
	var d = a00*b01 + a01*b11 + a02*b21;
	if (!d) { return null; }
	var id = 1/d;
	
	if(!dest) { dest = mat3.create(); }
	
	dest[0] = b01*id;
	dest[1] = (-a22*a01 + a02*a21)*id;
	dest[2] = (a12*a01 - a02*a11)*id;
	dest[3] = b11*id;
	dest[4] = (a22*a00 - a02*a20)*id;
	dest[5] = (-a12*a00 + a02*a10)*id;
	dest[6] = b21*id;
	dest[7] = (-a21*a00 + a01*a20)*id;
	dest[8] = (a11*a00 - a01*a10)*id;
	
	return dest;
};

/*
 * mat4.multiply
 * Performs a matrix multiplication
 *
 * Params:
 * mat - mat4, first operand
 * mat2 - mat4, second operand
 * dest - Optional, mat4 receiving operation result. If not specified result is written to mat
 *
 * Returns:
 * dest if specified, mat otherwise
 */
mat4.multiply = function(mat, mat2, dest) {
	if(!dest) { dest = mat }
	
	// Cache the matrix values (makes for huge speed increases!)
	var a00 = mat[0], a01 = mat[1], a02 = mat[2], a03 = mat[3];
	var a10 = mat[4], a11 = mat[5], a12 = mat[6], a13 = mat[7];
	var a20 = mat[8], a21 = mat[9], a22 = mat[10], a23 = mat[11];
	var a30 = mat[12], a31 = mat[13], a32 = mat[14], a33 = mat[15];
	
	var b00 = mat2[0], b01 = mat2[1], b02 = mat2[2], b03 = mat2[3];
	var b10 = mat2[4], b11 = mat2[5], b12 = mat2[6], b13 = mat2[7];
	var b20 = mat2[8], b21 = mat2[9], b22 = mat2[10], b23 = mat2[11];
	var b30 = mat2[12], b31 = mat2[13], b32 = mat2[14], b33 = mat2[15];
	
	dest[0] = b00*a00 + b01*a10 + b02*a20 + b03*a30;
	dest[1] = b00*a01 + b01*a11 + b02*a21 + b03*a31;
	dest[2] = b00*a02 + b01*a12 + b02*a22 + b03*a32;
	dest[3] = b00*a03 + b01*a13 + b02*a23 + b03*a33;
	dest[4] = b10*a00 + b11*a10 + b12*a20 + b13*a30;
	dest[5] = b10*a01 + b11*a11 + b12*a21 + b13*a31;
	dest[6] = b10*a02 + b11*a12 + b12*a22 + b13*a32;
	dest[7] = b10*a03 + b11*a13 + b12*a23 + b13*a33;
	dest[8] = b20*a00 + b21*a10 + b22*a20 + b23*a30;
	dest[9] = b20*a01 + b21*a11 + b22*a21 + b23*a31;
	dest[10] = b20*a02 + b21*a12 + b22*a22 + b23*a32;
	dest[11] = b20*a03 + b21*a13 + b22*a23 + b23*a33;
	dest[12] = b30*a00 + b31*a10 + b32*a20 + b33*a30;
	dest[13] = b30*a01 + b31*a11 + b32*a21 + b33*a31;
	dest[14] = b30*a02 + b31*a12 + b32*a22 + b33*a32;
	dest[15] = b30*a03 + b31*a13 + b32*a23 + b33*a33;
	
	return dest;
};

/*
 * mat4.multiplyVec3
 * Transforms a vec3 with the given matrix
 * 4th vector component is implicitly '1'
 *
 * Params:
 * mat - mat4 to transform the vector with
 * vec - vec3 to transform
 * dest - Optional, vec3 receiving operation result. If not specified result is written to vec
 *
 * Returns:
 * dest if specified, vec otherwise
 */
mat4.multiplyVec3 = function(mat, vec, dest) {
	if(!dest) { dest = vec }
	
	var x = vec[0], y = vec[1], z = vec[2];
	
	dest[0] = mat[0]*x + mat[4]*y + mat[8]*z + mat[12];
	dest[1] = mat[1]*x + mat[5]*y + mat[9]*z + mat[13];
	dest[2] = mat[2]*x + mat[6]*y + mat[10]*z + mat[14];
	
	return dest;
};

/*
 * mat4.multiplyVec4
 * Transforms a vec4 with the given matrix
 *
 * Params:
 * mat - mat4 to transform the vector with
 * vec - vec4 to transform
 * dest - Optional, vec4 receiving operation result. If not specified result is written to vec
 *
 * Returns:
 * dest if specified, vec otherwise
 */
mat4.multiplyVec4 = function(mat, vec, dest) {
	if(!dest) { dest = vec }
	
	var x = vec[0], y = vec[1], z = vec[2], w = vec[3];
	
	dest[0] = mat[0]*x + mat[4]*y + mat[8]*z + mat[12]*w;
	dest[1] = mat[1]*x + mat[5]*y + mat[9]*z + mat[13]*w;
	dest[2] = mat[2]*x + mat[6]*y + mat[10]*z + mat[14]*w;
	dest[3] = mat[3]*x + mat[7]*y + mat[11]*z + mat[15]*w;
	
	return dest;
};

/*
 * mat4.translate
 * Translates a matrix by the given vector
 *
 * Params:
 * mat - mat4 to translate
 * vec - vec3 specifying the translation
 * dest - Optional, mat4 receiving operation result. If not specified result is written to mat
 *
 * Returns:
 * dest if specified, mat otherwise
 */
mat4.translate = function(mat, vec, dest) {
	var x = vec[0], y = vec[1], z = vec[2];
	
	if(!dest || mat == dest) {
		mat[12] = mat[0]*x + mat[4]*y + mat[8]*z + mat[12];
		mat[13] = mat[1]*x + mat[5]*y + mat[9]*z + mat[13];
		mat[14] = mat[2]*x + mat[6]*y + mat[10]*z + mat[14];
		mat[15] = mat[3]*x + mat[7]*y + mat[11]*z + mat[15];
		return mat;
	}
	
	var a00 = mat[0], a01 = mat[1], a02 = mat[2], a03 = mat[3];
	var a10 = mat[4], a11 = mat[5], a12 = mat[6], a13 = mat[7];
	var a20 = mat[8], a21 = mat[9], a22 = mat[10], a23 = mat[11];
	
	dest[0] = a00;
	dest[1] = a01;
	dest[2] = a02;
	dest[3] = a03;
	dest[4] = a10;
	dest[5] = a11;
	dest[6] = a12;
	dest[7] = a13;
	dest[8] = a20;
	dest[9] = a21;
	dest[10] = a22;
	dest[11] = a23;
	
	dest[12] = a00*x + a10*y + a20*z + mat[12];
	dest[13] = a01*x + a11*y + a21*z + mat[13];
	dest[14] = a02*x + a12*y + a22*z + mat[14];
	dest[15] = a03*x + a13*y + a23*z + mat[15];
	return dest;
};

/*
 * mat4.scale
 * Scales a matrix by the given vector
 *
 * Params:
 * mat - mat4 to scale
 * vec - vec3 specifying the scale for each axis
 * dest - Optional, mat4 receiving operation result. If not specified result is written to mat
 *
 * Returns:
 * dest if specified, mat otherwise
 */
mat4.scale = function(mat, vec, dest) {
	var x = vec[0], y = vec[1], z = vec[2];
	
	if(!dest || mat == dest) {
		mat[0] *= x;
		mat[1] *= x;
		mat[2] *= x;
		mat[3] *= x;
		mat[4] *= y;
		mat[5] *= y;
		mat[6] *= y;
		mat[7] *= y;
		mat[8] *= z;
		mat[9] *= z;
		mat[10] *= z;
		mat[11] *= z;
		return mat;
	}
	
	dest[0] = mat[0]*x;
	dest[1] = mat[1]*x;
	dest[2] = mat[2]*x;
	dest[3] = mat[3]*x;
	dest[4] = mat[4]*y;
	dest[5] = mat[5]*y;
	dest[6] = mat[6]*y;
	dest[7] = mat[7]*y;
	dest[8] = mat[8]*z;
	dest[9] = mat[9]*z;
	dest[10] = mat[10]*z;
	dest[11] = mat[11]*z;
	dest[12] = mat[12];
	dest[13] = mat[13];
	dest[14] = mat[14];
	dest[15] = mat[15];
	return dest;
};

/*
 * mat4.rotate
 * Rotates a matrix by the given angle around the specified axis
 * If rotating around a primary axis (X,Y,Z) one of the specialized rotation functions should be used instead for performance
 *
 * Params:
 * mat - mat4 to rotate
 * angle - angle (in radians) to rotate
 * axis - vec3 representing the axis to rotate around 
 * dest - Optional, mat4 receiving operation result. If not specified result is written to mat
 *
 * Returns:
 * dest if specified, mat otherwise
 */
mat4.rotate = function(mat, angle, axis, dest) {
	var x = axis[0], y = axis[1], z = axis[2];
	var len = Math.sqrt(x*x + y*y + z*z);
	if (!len) { return null; }
	if (len != 1) {
		len = 1 / len;
		x *= len; 
		y *= len; 
		z *= len;
	}
	
	var s = Math.sin(angle);
	var c = Math.cos(angle);
	var t = 1-c;
	
	// Cache the matrix values (makes for huge speed increases!)
	var a00 = mat[0], a01 = mat[1], a02 = mat[2], a03 = mat[3];
	var a10 = mat[4], a11 = mat[5], a12 = mat[6], a13 = mat[7];
	var a20 = mat[8], a21 = mat[9], a22 = mat[10], a23 = mat[11];
	
	// Construct the elements of the rotation matrix
	var b00 = x*x*t + c, b01 = y*x*t + z*s, b02 = z*x*t - y*s;
	var b10 = x*y*t - z*s, b11 = y*y*t + c, b12 = z*y*t + x*s;
	var b20 = x*z*t + y*s, b21 = y*z*t - x*s, b22 = z*z*t + c;
	
	if(!dest) { 
		dest = mat 
	} else if(mat != dest) { // If the source and destination differ, copy the unchanged last row
		dest[12] = mat[12];
		dest[13] = mat[13];
		dest[14] = mat[14];
		dest[15] = mat[15];
	}
	
	// Perform rotation-specific matrix multiplication
	dest[0] = a00*b00 + a10*b01 + a20*b02;
	dest[1] = a01*b00 + a11*b01 + a21*b02;
	dest[2] = a02*b00 + a12*b01 + a22*b02;
	dest[3] = a03*b00 + a13*b01 + a23*b02;
	
	dest[4] = a00*b10 + a10*b11 + a20*b12;
	dest[5] = a01*b10 + a11*b11 + a21*b12;
	dest[6] = a02*b10 + a12*b11 + a22*b12;
	dest[7] = a03*b10 + a13*b11 + a23*b12;
	
	dest[8] = a00*b20 + a10*b21 + a20*b22;
	dest[9] = a01*b20 + a11*b21 + a21*b22;
	dest[10] = a02*b20 + a12*b21 + a22*b22;
	dest[11] = a03*b20 + a13*b21 + a23*b22;
	return dest;
};

/*
 * mat4.rotateX
 * Rotates a matrix by the given angle around the X axis
 *
 * Params:
 * mat - mat4 to rotate
 * angle - angle (in radians) to rotate
 * dest - Optional, mat4 receiving operation result. If not specified result is written to mat
 *
 * Returns:
 * dest if specified, mat otherwise
 */
mat4.rotateX = function(mat, angle, dest) {
	var s = Math.sin(angle);
	var c = Math.cos(angle);
	
	// Cache the matrix values (makes for huge speed increases!)
	var a10 = mat[4], a11 = mat[5], a12 = mat[6], a13 = mat[7];
	var a20 = mat[8], a21 = mat[9], a22 = mat[10], a23 = mat[11];

	if(!dest) { 
		dest = mat 
	} else if(mat != dest) { // If the source and destination differ, copy the unchanged rows
		dest[0] = mat[0];
		dest[1] = mat[1];
		dest[2] = mat[2];
		dest[3] = mat[3];
		
		dest[12] = mat[12];
		dest[13] = mat[13];
		dest[14] = mat[14];
		dest[15] = mat[15];
	}
	
	// Perform axis-specific matrix multiplication
	dest[4] = a10*c + a20*s;
	dest[5] = a11*c + a21*s;
	dest[6] = a12*c + a22*s;
	dest[7] = a13*c + a23*s;
	
	dest[8] = a10*-s + a20*c;
	dest[9] = a11*-s + a21*c;
	dest[10] = a12*-s + a22*c;
	dest[11] = a13*-s + a23*c;
	return dest;
};

/*
 * mat4.rotateY
 * Rotates a matrix by the given angle around the Y axis
 *
 * Params:
 * mat - mat4 to rotate
 * angle - angle (in radians) to rotate
 * dest - Optional, mat4 receiving operation result. If not specified result is written to mat
 *
 * Returns:
 * dest if specified, mat otherwise
 */
mat4.rotateY = function(mat, angle, dest) {
	var s = Math.sin(angle);
	var c = Math.cos(angle);
	
	// Cache the matrix values (makes for huge speed increases!)
	var a00 = mat[0], a01 = mat[1], a02 = mat[2], a03 = mat[3];
	var a20 = mat[8], a21 = mat[9], a22 = mat[10], a23 = mat[11];
	
	if(!dest) { 
		dest = mat 
	} else if(mat != dest) { // If the source and destination differ, copy the unchanged rows
		dest[4] = mat[4];
		dest[5] = mat[5];
		dest[6] = mat[6];
		dest[7] = mat[7];
		
		dest[12] = mat[12];
		dest[13] = mat[13];
		dest[14] = mat[14];
		dest[15] = mat[15];
	}
	
	// Perform axis-specific matrix multiplication
	dest[0] = a00*c + a20*-s;
	dest[1] = a01*c + a21*-s;
	dest[2] = a02*c + a22*-s;
	dest[3] = a03*c + a23*-s;
	
	dest[8] = a00*s + a20*c;
	dest[9] = a01*s + a21*c;
	dest[10] = a02*s + a22*c;
	dest[11] = a03*s + a23*c;
	return dest;
};

/*
 * mat4.rotateZ
 * Rotates a matrix by the given angle around the Z axis
 *
 * Params:
 * mat - mat4 to rotate
 * angle - angle (in radians) to rotate
 * dest - Optional, mat4 receiving operation result. If not specified result is written to mat
 *
 * Returns:
 * dest if specified, mat otherwise
 */
mat4.rotateZ = function(mat, angle, dest) {
	var s = Math.sin(angle);
	var c = Math.cos(angle);
	
	// Cache the matrix values (makes for huge speed increases!)
	var a00 = mat[0], a01 = mat[1], a02 = mat[2], a03 = mat[3];
	var a10 = mat[4], a11 = mat[5], a12 = mat[6], a13 = mat[7];
	
	if(!dest) { 
		dest = mat 
	} else if(mat != dest) { // If the source and destination differ, copy the unchanged last row
		dest[8] = mat[8];
		dest[9] = mat[9];
		dest[10] = mat[10];
		dest[11] = mat[11];
		
		dest[12] = mat[12];
		dest[13] = mat[13];
		dest[14] = mat[14];
		dest[15] = mat[15];
	}
	
	// Perform axis-specific matrix multiplication
	dest[0] = a00*c + a10*s;
	dest[1] = a01*c + a11*s;
	dest[2] = a02*c + a12*s;
	dest[3] = a03*c + a13*s;
	
	dest[4] = a00*-s + a10*c;
	dest[5] = a01*-s + a11*c;
	dest[6] = a02*-s + a12*c;
	dest[7] = a03*-s + a13*c;
	
	return dest;
};

/*
 * mat4.frustum
 * Generates a frustum matrix with the given bounds
 *
 * Params:
 * left, right - scalar, left and right bounds of the frustum
 * bottom, top - scalar, bottom and top bounds of the frustum
 * near, far - scalar, near and far bounds of the frustum
 * dest - Optional, mat4 frustum matrix will be written into
 *
 * Returns:
 * dest if specified, a new mat4 otherwise
 */
mat4.frustum = function(left, right, bottom, top, near, far, dest) {
	if(!dest) { dest = mat4.create(); }
	var rl = (right - left);
	var tb = (top - bottom);
	var fn = (far - near);
	dest[0] = (near*2) / rl;
	dest[1] = 0;
	dest[2] = 0;
	dest[3] = 0;
	dest[4] = 0;
	dest[5] = (near*2) / tb;
	dest[6] = 0;
	dest[7] = 0;
	dest[8] = (right + left) / rl;
	dest[9] = (top + bottom) / tb;
	dest[10] = -(far + near) / fn;
	dest[11] = -1;
	dest[12] = 0;
	dest[13] = 0;
	dest[14] = -(far*near*2) / fn;
	dest[15] = 0;
	return dest;
};

/*
 * mat4.perspective
 * Generates a perspective projection matrix with the given bounds
 *
 * Params:
 * fovy - scalar, vertical field of view
 * aspect - scalar, aspect ratio. typically viewport width/height
 * near, far - scalar, near and far bounds of the frustum
 * dest - Optional, mat4 frustum matrix will be written into
 *
 * Returns:
 * dest if specified, a new mat4 otherwise
 */
mat4.perspective = function(fovy, aspect, near, far, dest) {
	var top = near*Math.tan(fovy*Math.PI / 360.0);
	var right = top*aspect;
	return mat4.frustum(-right, right, -top, top, near, far, dest);
};

/*
 * mat4.ortho
 * Generates a orthogonal projection matrix with the given bounds
 *
 * Params:
 * left, right - scalar, left and right bounds of the frustum
 * bottom, top - scalar, bottom and top bounds of the frustum
 * near, far - scalar, near and far bounds of the frustum
 * dest - Optional, mat4 frustum matrix will be written into
 *
 * Returns:
 * dest if specified, a new mat4 otherwise
 */
mat4.ortho = function(left, right, bottom, top, near, far, dest) {
	if(!dest) { dest = mat4.create(); }
	var rl = (right - left);
	var tb = (top - bottom);
	var fn = (far - near);
	dest[0] = 2 / rl;
	dest[1] = 0;
	dest[2] = 0;
	dest[3] = 0;
	dest[4] = 0;
	dest[5] = 2 / tb;
	dest[6] = 0;
	dest[7] = 0;
	dest[8] = 0;
	dest[9] = 0;
	dest[10] = -2 / fn;
	dest[11] = 0;
	dest[12] = -(left + right) / rl;
	dest[13] = -(top + bottom) / tb;
	dest[14] = -(far + near) / fn;
	dest[15] = 1;
	return dest;
};

/*
 * mat4.ortho
 * Generates a look-at matrix with the given eye position, focal point, and up axis
 *
 * Params:
 * eye - vec3, position of the viewer
 * center - vec3, point the viewer is looking at
 * up - vec3 pointing "up"
 * dest - Optional, mat4 frustum matrix will be written into
 *
 * Returns:
 * dest if specified, a new mat4 otherwise
 */
mat4.lookAt = function(eye, center, up, dest) {
	if(!dest) { dest = mat4.create(); }
	
	var eyex = eye[0],
		eyey = eye[1],
		eyez = eye[2],
		upx = up[0],
		upy = up[1],
		upz = up[2],
		centerx = center[0],
		centery = center[1],
		centerz = center[2];

	if (eyex == centerx && eyey == centery && eyez == centerz) {
		return mat4.identity(dest);
	}
	
	var z0,z1,z2,x0,x1,x2,y0,y1,y2,len;
	
	//vec3.direction(eye, center, z);
	z0 = eyex - center[0];
	z1 = eyey - center[1];
	z2 = eyez - center[2];
	
	// normalize (no check needed for 0 because of early return)
	len = 1/Math.sqrt(z0*z0 + z1*z1 + z2*z2);
	z0 *= len;
	z1 *= len;
	z2 *= len;
	
	//vec3.normalize(vec3.cross(up, z, x));
	x0 = upy*z2 - upz*z1;
	x1 = upz*z0 - upx*z2;
	x2 = upx*z1 - upy*z0;
	len = Math.sqrt(x0*x0 + x1*x1 + x2*x2);
	if (!len) {
		x0 = 0;
		x1 = 0;
		x2 = 0;
	} else {
		len = 1/len;
		x0 *= len;
		x1 *= len;
		x2 *= len;
	};
	
	//vec3.normalize(vec3.cross(z, x, y));
	y0 = z1*x2 - z2*x1;
	y1 = z2*x0 - z0*x2;
	y2 = z0*x1 - z1*x0;
	
	len = Math.sqrt(y0*y0 + y1*y1 + y2*y2);
	if (!len) {
		y0 = 0;
		y1 = 0;
		y2 = 0;
	} else {
		len = 1/len;
		y0 *= len;
		y1 *= len;
		y2 *= len;
	}
	
	dest[0] = x0;
	dest[1] = y0;
	dest[2] = z0;
	dest[3] = 0;
	dest[4] = x1;
	dest[5] = y1;
	dest[6] = z1;
	dest[7] = 0;
	dest[8] = x2;
	dest[9] = y2;
	dest[10] = z2;
	dest[11] = 0;
	dest[12] = -(x0*eyex + x1*eyey + x2*eyez);
	dest[13] = -(y0*eyex + y1*eyey + y2*eyez);
	dest[14] = -(z0*eyex + z1*eyey + z2*eyez);
	dest[15] = 1;
	
	return dest;
};

/*
 * mat4.str
 * Returns a string representation of a mat4
 *
 * Params:
 * mat - mat4 to represent as a string
 *
 * Returns:
 * string representation of mat
 */
mat4.str = function(mat) {
	return '[' + mat[0] + ', ' + mat[1] + ', ' + mat[2] + ', ' + mat[3] + 
		', '+ mat[4] + ', ' + mat[5] + ', ' + mat[6] + ', ' + mat[7] + 
		', '+ mat[8] + ', ' + mat[9] + ', ' + mat[10] + ', ' + mat[11] + 
		', '+ mat[12] + ', ' + mat[13] + ', ' + mat[14] + ', ' + mat[15] + ']';
};

/*
 * quat4 - Quaternions 
 */
quat4 = {};

/*
 * quat4.create
 * Creates a new instance of a quat4 using the default array type
 * Any javascript array containing at least 4 numeric elements can serve as a quat4
 *
 * Params:
 * quat - Optional, quat4 containing values to initialize with
 *
 * Returns:
 * New quat4
 */
quat4.create = function(quat) {
	var dest = new glMatrixArrayType(4);
	
	if(quat) {
		dest[0] = quat[0];
		dest[1] = quat[1];
		dest[2] = quat[2];
		dest[3] = quat[3];
	}
	
	return dest;
};

/*
 * quat4.set
 * Copies the values of one quat4 to another
 *
 * Params:
 * quat - quat4 containing values to copy
 * dest - quat4 receiving copied values
 *
 * Returns:
 * dest
 */
quat4.set = function(quat, dest) {
	dest[0] = quat[0];
	dest[1] = quat[1];
	dest[2] = quat[2];
	dest[3] = quat[3];
	
	return dest;
};

/*
 * quat4.calculateW
 * Calculates the W component of a quat4 from the X, Y, and Z components.
 * Assumes that quaternion is 1 unit in length. 
 * Any existing W component will be ignored. 
 *
 * Params:
 * quat - quat4 to calculate W component of
 * dest - Optional, quat4 receiving calculated values. If not specified result is written to quat
 *
 * Returns:
 * dest if specified, quat otherwise
 */
quat4.calculateW = function(quat, dest) {
	var x = quat[0], y = quat[1], z = quat[2];

	if(!dest || quat == dest) {
		quat[3] = -Math.sqrt(Math.abs(1.0 - x*x - y*y - z*z));
		return quat;
	}
	dest[0] = x;
	dest[1] = y;
	dest[2] = z;
	dest[3] = -Math.sqrt(Math.abs(1.0 - x*x - y*y - z*z));
	return dest;
}

/*
 * quat4.inverse
 * Calculates the inverse of a quat4
 *
 * Params:
 * quat - quat4 to calculate inverse of
 * dest - Optional, quat4 receiving inverse values. If not specified result is written to quat
 *
 * Returns:
 * dest if specified, quat otherwise
 */
quat4.inverse = function(quat, dest) {
	if(!dest || quat == dest) {
		quat[0] *= -1;
		quat[1] *= -1;
		quat[2] *= -1;
		return quat;
	}
	dest[0] = -quat[0];
	dest[1] = -quat[1];
	dest[2] = -quat[2];
	dest[3] = quat[3];
	return dest;
}

/*
 * quat4.length
 * Calculates the length of a quat4
 *
 * Params:
 * quat - quat4 to calculate length of
 *
 * Returns:
 * Length of quat
 */
quat4.length = function(quat) {
	var x = quat[0], y = quat[1], z = quat[2], w = quat[3];
	return Math.sqrt(x*x + y*y + z*z + w*w);
}

/*
 * quat4.normalize
 * Generates a unit quaternion of the same direction as the provided quat4
 * If quaternion length is 0, returns [0, 0, 0, 0]
 *
 * Params:
 * quat - quat4 to normalize
 * dest - Optional, quat4 receiving operation result. If not specified result is written to quat
 *
 * Returns:
 * dest if specified, quat otherwise
 */
quat4.normalize = function(quat, dest) {
	if(!dest) { dest = quat; }
	
	var x = quat[0], y = quat[1], z = quat[2], w = quat[3];
	var len = Math.sqrt(x*x + y*y + z*z + w*w);
	if(len == 0) {
		dest[0] = 0;
		dest[1] = 0;
		dest[2] = 0;
		dest[3] = 0;
		return dest;
	}
	len = 1/len;
	dest[0] = x * len;
	dest[1] = y * len;
	dest[2] = z * len;
	dest[3] = w * len;
	
	return dest;
}

/*
 * quat4.multiply
 * Performs a quaternion multiplication
 *
 * Params:
 * quat - quat4, first operand
 * quat2 - quat4, second operand
 * dest - Optional, quat4 receiving operation result. If not specified result is written to quat
 *
 * Returns:
 * dest if specified, quat otherwise
 */
quat4.multiply = function(quat, quat2, dest) {
	if(!dest) { dest = quat; }
	
	var qax = quat[0], qay = quat[1], qaz = quat[2], qaw = quat[3];
	var qbx = quat2[0], qby = quat2[1], qbz = quat2[2], qbw = quat2[3];
	
	dest[0] = qax*qbw + qaw*qbx + qay*qbz - qaz*qby;
	dest[1] = qay*qbw + qaw*qby + qaz*qbx - qax*qbz;
	dest[2] = qaz*qbw + qaw*qbz + qax*qby - qay*qbx;
	dest[3] = qaw*qbw - qax*qbx - qay*qby - qaz*qbz;
	
	return dest;
}

/*
 * quat4.multiplyVec3
 * Transforms a vec3 with the given quaternion
 *
 * Params:
 * quat - quat4 to transform the vector with
 * vec - vec3 to transform
 * dest - Optional, vec3 receiving operation result. If not specified result is written to vec
 *
 * Returns:
 * dest if specified, vec otherwise
 */
quat4.multiplyVec3 = function(quat, vec, dest) {
	if(!dest) { dest = vec; }
	
	var x = vec[0], y = vec[1], z = vec[2];
	var qx = quat[0], qy = quat[1], qz = quat[2], qw = quat[3];

	// calculate quat * vec
	var ix = qw*x + qy*z - qz*y;
	var iy = qw*y + qz*x - qx*z;
	var iz = qw*z + qx*y - qy*x;
	var iw = -qx*x - qy*y - qz*z;
	
	// calculate result * inverse quat
	dest[0] = ix*qw + iw*-qx + iy*-qz - iz*-qy;
	dest[1] = iy*qw + iw*-qy + iz*-qx - ix*-qz;
	dest[2] = iz*qw + iw*-qz + ix*-qy - iy*-qx;
	
	return dest;
}

/*
 * quat4.toMat3
 * Calculates a 3x3 matrix from the given quat4
 *
 * Params:
 * quat - quat4 to create matrix from
 * dest - Optional, mat3 receiving operation result
 *
 * Returns:
 * dest if specified, a new mat3 otherwise
 */
quat4.toMat3 = function(quat, dest) {
	if(!dest) { dest = mat3.create(); }
	
	var x = quat[0], y = quat[1], z = quat[2], w = quat[3];

	var x2 = x + x;
	var y2 = y + y;
	var z2 = z + z;

	var xx = x*x2;
	var xy = x*y2;
	var xz = x*z2;

	var yy = y*y2;
	var yz = y*z2;
	var zz = z*z2;

	var wx = w*x2;
	var wy = w*y2;
	var wz = w*z2;

	dest[0] = 1 - (yy + zz);
	dest[1] = xy - wz;
	dest[2] = xz + wy;

	dest[3] = xy + wz;
	dest[4] = 1 - (xx + zz);
	dest[5] = yz - wx;

	dest[6] = xz - wy;
	dest[7] = yz + wx;
	dest[8] = 1 - (xx + yy);
	
	return dest;
}

/*
 * quat4.toMat4
 * Calculates a 4x4 matrix from the given quat4
 *
 * Params:
 * quat - quat4 to create matrix from
 * dest - Optional, mat4 receiving operation result
 *
 * Returns:
 * dest if specified, a new mat4 otherwise
 */
quat4.toMat4 = function(quat, dest) {
	if(!dest) { dest = mat4.create(); }
	
	var x = quat[0], y = quat[1], z = quat[2], w = quat[3];

	var x2 = x + x;
	var y2 = y + y;
	var z2 = z + z;

	var xx = x*x2;
	var xy = x*y2;
	var xz = x*z2;

	var yy = y*y2;
	var yz = y*z2;
	var zz = z*z2;

	var wx = w*x2;
	var wy = w*y2;
	var wz = w*z2;

	dest[0] = 1 - (yy + zz);
	dest[1] = xy - wz;
	dest[2] = xz + wy;
	dest[3] = 0;

	dest[4] = xy + wz;
	dest[5] = 1 - (xx + zz);
	dest[6] = yz - wx;
	dest[7] = 0;

	dest[8] = xz - wy;
	dest[9] = yz + wx;
	dest[10] = 1 - (xx + yy);
	dest[11] = 0;

	dest[12] = 0;
	dest[13] = 0;
	dest[14] = 0;
	dest[15] = 1;
	
	return dest;
}

/*
 * quat4.slerp
 * Performs a spherical linear interpolation between two quat4
 *
 * Params:
 * quat - quat4, first quaternion
 * quat2 - quat4, second quaternion
 * slerp - interpolation amount between the two inputs
 * dest - Optional, quat4 receiving operation result. If not specified result is written to quat
 *
 * Returns:
 * dest if specified, quat otherwise
 */
quat4.slerp = function(quat, quat2, slerp, dest) {
    if(!dest) { dest = quat; }
    
	var cosHalfTheta =  quat[0]*quat2[0] + quat[1]*quat2[1] + quat[2]*quat2[2] + quat[3]*quat2[3];
	
	if (Math.abs(cosHalfTheta) >= 1.0){
	    if(dest != quat) {
		    dest[0] = quat[0];
		    dest[1] = quat[1];
		    dest[2] = quat[2];
		    dest[3] = quat[3];
		}
		return dest;
	}
	
	var halfTheta = Math.acos(cosHalfTheta);
	var sinHalfTheta = Math.sqrt(1.0 - cosHalfTheta*cosHalfTheta);

	if (Math.abs(sinHalfTheta) < 0.001){
		dest[0] = (quat[0]*0.5 + quat2[0]*0.5);
		dest[1] = (quat[1]*0.5 + quat2[1]*0.5);
		dest[2] = (quat[2]*0.5 + quat2[2]*0.5);
		dest[3] = (quat[3]*0.5 + quat2[3]*0.5);
		return dest;
	}
	
	var ratioA = Math.sin((1 - slerp)*halfTheta) / sinHalfTheta;
	var ratioB = Math.sin(slerp*halfTheta) / sinHalfTheta; 
	
	dest[0] = (quat[0]*ratioA + quat2[0]*ratioB);
	dest[1] = (quat[1]*ratioA + quat2[1]*ratioB);
	dest[2] = (quat[2]*ratioA + quat2[2]*ratioB);
	dest[3] = (quat[3]*ratioA + quat2[3]*ratioB);
	
	return dest;
}


/*
 * quat4.str
 * Returns a string representation of a quaternion
 *
 * Params:
 * quat - quat4 to represent as a string
 *
 * Returns:
 * string representation of quat
 */
quat4.str = function(quat) {
	return '[' + quat[0] + ', ' + quat[1] + ', ' + quat[2] + ', ' + quat[3] + ']'; 
}

 quat4.fromAngleAxis = function(angle, axis, dest) {
        // The quaternion representing the rotation is
        //   q = cos(A/2)+sin(A/2)*(x*i+y*j+z*k)
        if (!dest) dest = quat4.create();
        
        var half = angle * 0.5;
        var s = Math.sin(half);
        dest[3] = Math.cos(half);
        dest[0] = s * axis[0];
        dest[1] = s * axis[1];
        dest[2] = s * axis[2];
        
        return dest;
    };


SimpleFullscreenControl = function() {
	var that = this;
	this.element = undefined;
	this.changeCallback = function() {
		that.fullscreenChange();
	}
}

SimpleFullscreenControl.prototype.enterFullscreenHook = function(element) {
	console.log('overload enterFullscreenHook');
}

SimpleFullscreenControl.prototype.leaveFullscreenHook = function(element) {
	console.log('overload leaveFullscreenHook');
}

SimpleFullscreenControl.prototype.attach = function(divId) {
	if (this.element != undefined) {
		detach();
	}
	this.element = document.getElementById(divId);
	if (this.element == null) {
		this.element = undefined;
		console.log('could not find ' + divId + 'did not attach full screen control.');
		return;
	}
	document.addEventListener('fullscreenchange', this.changeCallback, false);
	document.addEventListener('mozfullscreenchange', this.changeCallback, false);
	document.addEventListener('webkitfullscreenchange', this.changeCallback, false);
}

SimpleFullscreenControl.prototype.detach = function() {
	this.leaveFullscreen();
	this.element = undefined;
	document.removeEventListener('fullscreenchange', this.changeCallback, false);
	document.removeEventListener('mozfullscreenchange', this.changeCallback, false);
	document.removeEventListener('webkitfullscreenchange', this.changeCallback, false);
}

SimpleFullscreenControl.prototype.fullscreenChange = function() {
	if (document.webkitFullscreenElement === this.element ||
		document.mozFullscreenElement === this.element ||
		document.mozFullScreenElement === this.element) {
		this.enterFullscreenHook(this.element);
	} else {
		this.leaveFullscreenHook(this.element);
	}
}

SimpleFullscreenControl.prototype.enterFullscreen = function() {
	this.element.requestFullscreen = this.element.requestFullscreen    ||
									 this.element.mozRequestFullscreen ||
									 this.element.webkitRequestFullscreen;
	this.element.requestFullscreen();
}

SimpleFullscreenControl.prototype.leaveFullscreen = function() {
	document.webkitCancelFullScreen();
}

SimplePointerLockControl = function() {
	var that = this;
	this.element = undefined;
	this.changeCallback = function() {
		that.pointerLockChange();
	}
	this.moveCallback = function(e) {
		var movementX = e.movementX       ||
                 		e.mozMovementX    ||
                  		e.webkitMovementX ||
                  		0,
      		movementY = e.movementY       ||
                  		e.mozMovementY    ||
                  		e.webkitMovementY ||
                  		0;
		that.pointerMoveHook(movementX, movementY);
	}
}

SimplePointerLockControl.prototype.lockHook = function(element) {
	console.log('overload lockHook');
}

SimplePointerLockControl.prototype.unlockHook = function(element) {
	console.log('overload unlockHook');
}

SimplePointerLockControl.prototype.pointerMoveHook = function(x, y) {
	console.log('overload pointerMoveHook -- (' + x + ',' + y + ')');
}

SimplePointerLockControl.prototype.attach = function(divId) {
	if (this.element != undefined) {
		this.detach();
	}
	this.element = document.getElementById(divId);
	if (this.element == null) {
		this.element = undefined;
		console.log('could not find ' + divId + 'did not attach pointer lock control.');
		return;
	}
	document.addEventListener('pointerlockchange', this.changeCallback, false);
	document.addEventListener('mozpointerlockchange', this.changeCallback, false);
	document.addEventListener('webkitpointerlockchange', this.changeCallback, false);
}

SimplePointerLockControl.prototype.detach = function() {
	this.unlock();
	this.element = undefined;
	document.removeEventListener('pointerlockchange', this.changeCallback, false);
	document.removeEventListener('mozpointerlockchange', this.changeCallback, false);
	document.removeEventListener('webkitpointerlockchange', this.changeCallback, false);

}

SimplePointerLockControl.prototype.pointerLockChange = function() {
	if (document.mozPointerLockElement === this.element ||
		document.webkitPointerLockElement === this.element) {
		this.lockHook(this.element);
		document.addEventListener("mousemove", this.moveCallback, false);
	} else {
		document.removeEventListener("mousemove", this.moveCallback, false);
		this.unlockHook(this.element);
	}
}

SimplePointerLockControl.prototype.lock = function() {
	this.element.requestPointerLock = this.element.requestPointerLock    ||
									  this.element.mozRequestPointerLock ||
									  this.element.webkitRequestPointerLock;
	this.element.requestPointerLock();
}

SimplePointerLockControl.prototype.unlock = function() {
	document.webkitExitPointerLock();
}

SimplePointerLockControl.prototype.islocked = function() {
	return document.webkitPointerLockElement == this.element;
}

installHooks = function() {
	window.simpleFullscreenControl.enterFullscreenHook = function(element) {
		console.log('booting out of fullscreen');
		window.simpleFullscreenControl.leaveFullscreen();
	}

	window.simpleFullscreenControl.leaveFullscreenHook = function(element) {
		console.log('out of fullscreen');
	}
	window.simplePointerLockControl.lockHook = function(element) {
		//window.simplePointerLockControl.unlock();
		this.element.innerHTML = '<p class="notice">(0, 0)</p>';
	}
	window.simplePointerLockControl.unlockHook = function(element) {
		var html = '<p class="notice">Click me!</p>'
		this.element.innerHTML = html;
	}
	window.simplePointerLockControl.pointerMoveHook = function(x, y) {
		var html = '<p class="notice">(' + x + ',' + y + ')</p>';
		this.element.innerHTML = html;
	}
}

installEvents = function(divId) {
	var element = document.getElementById(divId);
	if (element == null) {
		console.log('could not find ' + divId + 'could not install click handler');
		return;
	}
	element.addEventListener('click', function() {
		window.simplePointerLockControl.lock();
	}, false);
	console.log('installed click handler in ' + divId);
}


dumpShaderProgram = function(webGL, sp) {
	var attributes = webGL.getProgramParameter(sp, webGL.ACTIVE_ATTRIBUTES);
	var uniforms = webGL.getProgramParameter(sp, webGL.ACTIVE_UNIFORMS);
	for (var i = 0; i < attributes; i++) {
		var attribute = webGL.getActiveAttrib(sp, i);
		console.log('Active Attribute ' + i);
		console.log(attribute);
	}
	for (var i = 0; i < uniforms; i++) {
		var uniform = webGL.getActiveUniform(sp, i);
		console.log('Active Uniform ' + i);
		console.log(uniform);
	}
}

FPSController = function() {
	this.forwardKey = false;
	this.backwardKey = false;
	this.leftKey = false;
	this.rightKey = false;
	this.webGL = null;
	this.captureKeys = false;
}

FPSController.prototype.animateCallback = function(t) {
	var that = this;
	if (this.lastAnimationTime == undefined) {
		this.lastAnimationTime = t;
		return;
	}
	var dt = t - this.lastAnimationTime;
	this.lastAnimationTime = t;
	var color = t % 256;
	this.webGL.viewport(0, 0, 640, 480);
	this.webGL.clearColor(0.0, 0.0, 0.0, 1.0);
	this.webGL.clearDepth(1.0);
	this.webGL.clear(this.webGL.COLOR_BUFFER_BIT|this.webGL.DEPTH_BUFFER_BIT);
	this.webGL.disable(this.webGL.DEPTH_TEST);
	this.webGL.lineWidth(2.0);
	if (this.moveEnabled) {
		this.moveView(this.forwardKey, this.backwardKey, this.leftKey, this.rightKey, dt / 1000.0);	
	}
	this.viewMatrix = mat4.lookAt(this.eyePoint, this.lookAtPoint, this.upVector);
	this.projectionViewMatrix = mat4.create();
	mat4.multiply(this.projectionMatrix, this.viewMatrix, this.projectionViewMatrix);
	this.drawGrid();
}

FPSController.prototype.lockHook = function(element) {
	var that = this;
	document.onkeydown = function(e) { that.keydownHook(e); };
	document.onkeyup = function(e) { that.keyupHook(e); };
}

FPSController.prototype.unlockHook = function(element) {
}

FPSController.prototype.moveHook = function(x, y) {
	this.rotateView(x, y);
}

FPSController.prototype.clickHook = function() {
	this.pointerLockControl.lock();
}

FPSController.prototype.rotateViewAround = function(deltaAngle, axis) {
	var frontDirection = vec3.create();
	vec3.subtract(this.lookAtPoint, this.eyePoint, frontDirection);
	vec3.normalize(frontDirection);
	var q = quat4.create();
	quat4.fromAngleAxis(deltaAngle, axis, q);
	quat4.multiplyVec3(q, frontDirection);
	this.lookAtPoint = vec3.create(this.eyePoint);
	vec3.add(this.lookAtPoint, frontDirection);
}

FPSController.prototype.rotateView = function(x, y) {
	var frontDirection = vec3.create();
	var strafeDirection = vec3.create();
	vec3.subtract(this.lookAtPoint, this.eyePoint, frontDirection);
	vec3.normalize(frontDirection);
	vec3.cross(frontDirection, this.upVector, strafeDirection);
	vec3.normalize(strafeDirection);
	if (this.yawEnabled) {
		this.rotateViewAround(-x/360.0, this.upVector);	
	}
	if (this.pitchEnabled) {
		this.rotateViewAround(-y/360.0, strafeDirection);	
	}
	
}

FPSController.prototype.moveView = function(w,s,a,d, dt) {
	var frontDirection = vec3.create();
	var strafeDirection = vec3.create();
	vec3.subtract(this.lookAtPoint, this.eyePoint, frontDirection);
	vec3.normalize(frontDirection);
	vec3.cross(frontDirection, this.upVector, strafeDirection);
	vec3.normalize(strafeDirection);

	var forwardScale = 0.0;
	var strafeScale = 0.0;

	if (w) {
		forwardScale += 1.0;
	}
	if (s) {
		forwardScale -= 1.0;
	}
	if (a) {
		strafeScale -= 1.0;
	}
	if (d) {
		strafeScale += 1.0;
	}


	var velocity = 2.0 * dt;

	forwardScale *= velocity;
	strafeScale *= velocity;

	vec3.scale(frontDirection, forwardScale);
	vec3.scale(strafeDirection, strafeScale);

	vec3.add(this.eyePoint, frontDirection);
	vec3.add(this.eyePoint, strafeDirection);
	vec3.add(this.lookAtPoint, frontDirection);
	vec3.add(this.lookAtPoint, strafeDirection);
}

FPSController.prototype.drawGrid = function() {
	var webGL = this.webGL;

	webGL.enableVertexAttribArray(0);
	webGL.enableVertexAttribArray(1);
	webGL.bindBuffer(this.webGL.ARRAY_BUFFER, this.gridVertexBuffer);
	webGL.vertexAttribPointer(0, 4, webGL.FLOAT, false, 28, 12);
	webGL.bindBuffer(this.webGL.ARRAY_BUFFER, this.gridVertexBuffer);
	webGL.vertexAttribPointer(1, 3, webGL.FLOAT, false, 28, 0);
	var cameraTransformUniformIndex = webGL.getUniformLocation(this.gridShaderProgram, 'cameraTransform');
	webGL.useProgram(this.gridShaderProgram);
	webGL.uniformMatrix4fv(cameraTransformUniformIndex, false, this.projectionViewMatrix);
	webGL.drawArrays(webGL.LINES, 0, this.numPoints);
	webGL.disableVertexAttribArray(0);
	webGL.disableVertexAttribArray(1);
	webGL.flush();
}

FPSController.prototype.prepare = function() {
	this.upVector = vec3.create([0.0, 1.0, 0.0]);
	this.eyePoint = vec3.create([1.0, 1.0, -1.0]);
	this.lookAtPoint = vec3.create([2.0, 1.0, -2.0]);
	// Projection matrix
	this.projectionMatrix = mat4.perspective(45.0, 640.0/480.0, 1.0, 50.0);
	// View matrix
	this.viewMatrix = mat4.lookAt(this.eyePoint, this.lookAtPoint, this.upVector);
	this.projectionViewMatrix = mat4.create();
	mat4.multiply(this.projectionMatrix, this.viewMatrix, this.projectionViewMatrix);
	console.log(this.projectionViewMatrix);

	// Skybox data
	this.skyboxTexture = this.webGL.createTexture();
	this.gridVertexBuffer = this.webGL.createBuffer();

	// Grid data
	this.webGL.bindBuffer(this.webGL.ARRAY_BUFFER, this.gridVertexBuffer);
	var gridData = [];
	this.numPoints = 0;
	for (var i = 0; i <= 20; i++) {
		var x = i * 1.0;
		var y = 0.0;
		var z0 = 0.0;
		var z1 = -20.0;
		var r = 0.0;
		var g = 1.0;
		var b = 0.0;
		var a = 1.0;
		gridData.push(x);
		gridData.push(y);
		gridData.push(z0);

		gridData.push(r);
		gridData.push(g);
		gridData.push(b);
		gridData.push(a);

		this.numPoints++;
		gridData.push(x);
		gridData.push(y);
		gridData.push(z1);

		gridData.push(r);
		gridData.push(g);
		gridData.push(b);
		gridData.push(a);
		this.numPoints++;
	}

	for (var i = 0; i <= 20; i++) {
		var x0 = 0.0;
		var x1 = 20.0;
		var y = 0.0;
		var z = i * -1.0;
		var r = 0.0;
		var g = 1.0;
		var b = 0.0;
		var a = 1.0;
		gridData.push(x0);
		gridData.push(y);
		gridData.push(z);
		gridData.push(r);
		gridData.push(g);
		gridData.push(b);
		gridData.push(a);
		this.numPoints++;
		gridData.push(x1);
		gridData.push(y);
		gridData.push(z);
		gridData.push(r);
		gridData.push(g);
		gridData.push(b);
		gridData.push(a);
		this.numPoints++;
	}

	for (var i = 0; i <= 20; i++) {
		var x = 20.0;
		var y0 = 0.0;
		var y1 = 20.0;
		var z = i * -1.0;
		var r = 0.65;
		var g = 0.17;
		var b = 0.17;
		var a = 1.0;
		gridData.push(x);
		gridData.push(y0);
		gridData.push(z);

		gridData.push(r);
		gridData.push(g);
		gridData.push(b);
		gridData.push(a);

		this.numPoints++;
		gridData.push(x);
		gridData.push(y1);
		gridData.push(z);

		gridData.push(r);
		gridData.push(g);
		gridData.push(b);
		gridData.push(a);
		this.numPoints++;
	}

	for (var i = 0; i <= 20; i++) {
		var x = 20.0;
		var y = i * 1.0;
		var z0 = 0.0;
		var z1 = -20.0;
		var r = 0.65;
		var g = 0.17;
		var b = 0.17;
		var a = 1.0;
		gridData.push(x);
		gridData.push(y);
		gridData.push(z0);
		gridData.push(r);
		gridData.push(g);
		gridData.push(b);
		gridData.push(a);
		this.numPoints++;
		gridData.push(x);
		gridData.push(y);
		gridData.push(z1);
		gridData.push(r);
		gridData.push(g);
		gridData.push(b);
		gridData.push(a);
		this.numPoints++;
	}

		for (var i = 0; i <= 20; i++) {
		var x = i * 1.0;
		var y0 = 0.0;
		var y1 = 20.0;
		var z = -20.0;
		var r = 0.65;
		var g = 0.6;
		var b = 0.3;
		var a = 1.0;
		gridData.push(x);
		gridData.push(y0);
		gridData.push(z);

		gridData.push(r);
		gridData.push(g);
		gridData.push(b);
		gridData.push(a);

		this.numPoints++;
		gridData.push(x);
		gridData.push(y1);
		gridData.push(z);

		gridData.push(r);
		gridData.push(g);
		gridData.push(b);
		gridData.push(a);
		this.numPoints++;
	}

	for (var i = 0; i <= 20; i++) {
		var x0 = 0.0;
		var x1 = 20.0;
		var y = i * 1.0;
		var z = -20.0;
		var r = 0.65;
		var g = 0.6;
		var b = 0.3;
		var a = 1.0;
		gridData.push(x0);
		gridData.push(y);
		gridData.push(z);
		gridData.push(r);
		gridData.push(g);
		gridData.push(b);
		gridData.push(a);
		this.numPoints++;
		gridData.push(x1);
		gridData.push(y);
		gridData.push(z);
		gridData.push(r);
		gridData.push(g);
		gridData.push(b);
		gridData.push(a);
		this.numPoints++;
	}

	this.webGL.bufferData(this.webGL.ARRAY_BUFFER, new Float32Array(gridData), this.webGL.STATIC_DRAW);

	// Grid program
	this.gridVertexShader = this.webGL.createShader(this.webGL.VERTEX_SHADER);
	this.gridFragmentShader = this.webGL.createShader(this.webGL.FRAGMENT_SHADER);
	this.webGL.shaderSource(this.gridVertexShader, '' +
		'precision highp float;'+
		'attribute vec3 vPosition;'+
		'attribute vec4 vColor;'+
		'uniform mat4 cameraTransform;'+
		'varying vec4 fColor;'+
		'void main() {'+
    		'fColor = vColor;'+
    		'vec4 vPosition4 = vec4(vPosition.x, vPosition.y, vPosition.z, 1.0);'+
    		'gl_Position = cameraTransform*vPosition4;'+
		'}');
	this.webGL.compileShader(this.gridVertexShader);
	console.log('Log from vertexShader: ' + this.webGL.getShaderInfoLog(this.gridVertexShader));
	this.webGL.shaderSource(this.gridFragmentShader, '' +
		'precision mediump float;'+
		'varying vec4 fColor;'+
		'void main() {'+
    		'gl_FragColor = fColor;'+
		'}');
	this.webGL.compileShader(this.gridFragmentShader);
	console.log('Log from fragmentShader: ' + this.webGL.getShaderInfoLog(this.gridFragmentShader));

	console.log('Vertex Shader Type: ' + this.webGL.getShaderParameter(this.gridVertexShader, this.webGL.SHADER_TYPE));
	console.log('Fragment Shader Type: ' + this.webGL.getShaderParameter(this.gridFragmentShader, this.webGL.SHADER_TYPE));

	console.log('Vertex Shader Compiled: ' + this.webGL.getShaderParameter(this.gridVertexShader, this.webGL.COMPILE_STATUS));
	console.log('Fragment Shader Compiled: ' + this.webGL.getShaderParameter(this.gridFragmentShader, this.webGL.COMPILE_STATUS));

	this.gridShaderProgram = this.webGL.createProgram();
	this.webGL.attachShader(this.gridShaderProgram, this.gridVertexShader);
	this.webGL.attachShader(this.gridShaderProgram, this.gridFragmentShader);
	this.webGL.linkProgram(this.gridShaderProgram);
	this.webGL.validateProgram(this.gridShaderProgram);
	console.log('Log from shaderProgram: ' + this.webGL.getProgramInfoLog(this.gridShaderProgram));
	dumpShaderProgram(this.webGL, this.gridShaderProgram);
}

FPSController.prototype.keydownHook = function(event) {
	if (this.pointerLockControl.islocked()) {
		var keyCode = event.keyCode;
		if (keyCode == 87) {
			this.forwardKey = true;
		}
		if (keyCode == 83) {
			this.backwardKey = true;
		}
		if (keyCode == 65) {
			this.leftKey = true;
		}
		if (keyCode == 68) {
			this.rightKey = true;
		}
	}
	
}

FPSController.prototype.keyupHook = function(event) {
	if (this.pointerLockControl.islocked()) {
		var keyCode = event.keyCode;
		if (keyCode == 87) {
			this.forwardKey = false;
		}
		if (keyCode == 83) {
			this.backwardKey = false;
		}
		if (keyCode == 65) {
			this.leftKey = false;
		}
		if (keyCode == 68) {
			this.rightKey = false;
		}
	}
}

var globalState = {
	'views': []
}

animateCallback = function(t) {
	for (var i = 0; i < globalState.views.length; i++) {
		globalState.views[i].animateCallback(t);
	}
	window.requestAnimationFrame(animateCallback);	
}

addView = function(canvasId, moveEnabled, yawEnabled, pitchEnabled) {
	var canvasElement = document.getElementById(canvasId);
	canvasElement.width = 640;
	canvasElement.height = 480;
	canvasElement.controller = new FPSController();
	canvasElement.controller.moveEnabled = moveEnabled;
	canvasElement.controller.yawEnabled = yawEnabled;
	canvasElement.controller.pitchEnabled = pitchEnabled;
	canvasElement.controller.webGL = canvasElement.getContext("experimental-webgl");
	window.requestAnimationFrame(function(t) { canvasElement.controller.animateCallback(t); });
	canvasElement.controller.pointerLockControl = new SimplePointerLockControl();
	canvasElement.controller.pointerLockControl.attach(canvasId);
	canvasElement.controller.pointerLockControl.lockHook = function(e) { canvasElement.controller.lockHook(e); };
	canvasElement.controller.pointerLockControl.unlockHook = function(e) { canvasElement.controller.unlockHook(e); };
	canvasElement.controller.pointerLockControl.pointerMoveHook = function(x, y) { canvasElement.controller.moveHook(x, y); };
	canvasElement.addEventListener('click', function(e) { canvasElement.controller.clickHook(e); }, false);
	canvasElement.controller.prepare();

	globalState.views.push(canvasElement.controller);	
}

pointerLockMain = function() {
	window.simpleFullscreenControl = new SimpleFullscreenControl();
	window.simpleFullscreenControl.attach('simple-pointer-lock');
	window.simplePointerLockControl = new SimplePointerLockControl();
	window.simplePointerLockControl.attach('simple-pointer-lock');
	installHooks();
	installEvents('simple-pointer-lock');
	window.requestAnimationFrame = window.requestAnimationFrame       || 
					              window.webkitRequestAnimationFrame || 
					              window.mozRequestAnimationFrame    || 
					              window.oRequestAnimationFrame      || 
					              window.msRequestAnimationFrame;

    addView('webGLFrontBufferMovement', true, false, false);
    addView('webGLFrontBufferYaw', false, true, false);
    addView('webGLFrontBufferPitch', false, false, true);
    addView('webGLFrontBuffer', true, true, true);
	window.requestAnimationFrame(animateCallback);
}

window.onload = pointerLockMain;

</script>

{% endblock %}
