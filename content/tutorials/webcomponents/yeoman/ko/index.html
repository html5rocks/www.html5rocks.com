{% extends "tutorial.html" %}
{% load mixin from templatefilters %}

{% block pagebreadcrumb %}{{ tut.title }}{% endblock %}

{% block head %}
<style>
.screenshot{
  width:100%;
}
.inline-list{
  margin-left:3em;
  list-style:square;
}
</style>
{% endblock %}

{% block iscompatible %}
  return 'register' in document;
{% endblock %}

{% block html5badge %}
<!-- Your HTML5 badge (tech class icons used in the article) goes here -->
{% endblock %}

{% block share_image %}
<!--<meta itemprop="image" content="images/your_social_sharing_img.png">-->
{% endblock %}

{% block content %}

<p>{% include "warning.html" %}</p>
<h2 id="toc-intro">소개</h2>

<p>안녕하세요. 웹 앱을 작성하는 누구나 자신의 생산성을 유지하는 것이 얼마나 중요한지 알고 있습니다. 여러분이 제대로된 보일러플레이트를 찾아서 개발 환경을 설치하고 작업 흐름을 시험하고 여러분의 모든 소스들의 최소화 및 압축과 같은 귀찮은 작업을 걱정할 때 그에 대한 도전이 시작됩니다.</p>
<p>다행스럽게도 최근의 프론트엔드 도구들은 이러한 일을 대부분 자동화하는 것을 도와줘서 강력한 앱의 작성에만 집중할 수 있게 해줍니다. 이 글은 웹 앱 개발 시 <a href="http://html5-demos.appspot.com/static/webcomponents/index.html#1">Web Components</a>를 위한 polyfill 및 sugar 라이브러리인 <a href="http://polymer-project.org">Polymer</a>를 사용하는 앱 생성의 간소화하는 작업흐름 도구인 <a href="http://yeoman.io">Yeoman</a>을 어떻게 사용하는지 보여줍니다.</p>
<p><img src="image_0.png" class="screenshot"></p>
<p class="notice"><b>주목:</b> 만약 여러분이 웹 컴포넌트가 처음이라면, 그것들이 제공하는 웹 플랫폼의 기능들에 대한 환상적인 (문서들)[http://www.polymer-project.org/getting-started.html]을 읽어보기를 권합니다. [Custom Element](http://www.polymer-project.org/platform/custom-elements.html), [Shadow DOM](http://www.polymer-project.org/platform/shadow-dom.html), [HTML Imports](http://www.polymer-project.org/platform/html-imports.html) 등을 가능하게 하는 Polymer를 통해 그것들을 어떻게 사용하는지에 대한 가이드입니다.</p>

<h2 id="toc-meet-tools">Yo, Grunt 그리고 Bower를 만나보자</h2>

<p>Yeoman은 여러분의 생산성 향상을 위한 3개의 도구를 가진 모자 쓴 남자입니다.</p>
<ul>
<li>
<p><a href="http://yeoman.io">yo</a>는 프레임워크에 특화된 기반 구조(scaffold)들의 생태계를 제공하는 구조화 도구로 제가 이전에 말한 귀찮은 작업들 중 일부를 수행하는데 사용할 수 있는 생성기를 호출합니다. </p>
</li>
<li>
<p><a href="http://gruntjs.com">grunt</a>는 여러분의 프로젝트를 빌드하고 미리 보고 테스트하는데 사용됩니다. 여러분은 Yeoman팀에서 제공하는 태스크들과 <a href="https://github.com/gruntjs/grunt-contrib">grunt-contrib</a>로부터의 도움에 감사하게 될 겁니다.</p>
</li>
<li>
<p><a href="http://bower.io">bower</a>는 의존성을 관리하는데 사용됩니다. 따라서 여러분은 더이상 여러분의 스크립트들을 수동으로 다운로드하고 관리하지 않아도 됩니다.</p>
</li>
</ul>
<p>하나 혹은 2개의 명령어를 통해 Yeoman은 여러분의 앱(혹은 모델과 같은 독립적인 코드 조각들)을 위한 보일러플레이트를 작성하고 여러분의 Sass를 컴파일하고 CSS, JS, HTML과 이미지들을 작게 줄이거나 합칠 할 수 있으며 현재 디렉토리에서 간단한 웹서버를 실핼할 수 있도록 합니다. 또한 여러분이 단위 테스트 등을 할 수도 있습니다.</p>
<p>여러분은 <a href="http://npmjs.org">Node Packaged Modules</a> (npm)으로부터 생성기를 설치할 수 있으며 거기에는 오픈소스 커뮤니티에서 작성한 많은 그리고 현재 사용 가능한 220개 이상의 <a href="http://yeoman.io/community-generators.html">생성기</a>가 있습니다. 인기있는 생성기에는 <a href="https://github.com/yeoman/generator-angular">generator-angular</a>, <a href="https://github.com/yeoman/generator-backbone">generator-backbone</a> 그리고 <a href="https://github.com/yeoman/generator-ember">generator-ember</a>가 있습니다.</p>
<p><img src="image_1.png" class="screenshot"/></p>
<p>최근 버전의 <a href="http://nodejs.org">Node.js</a>가 설치되어 있다면 여러분은 당장 터미널을 열어 다음을 실행하세요.</p>
<pre class="prettyprint"><code>$ npm instal -g yo
</code></pre>
<p>저것이 전부입니다. 여러분은 이제 Yo, Grunt 그리고 Bower를 설치했고 커맨드라인에서 그것들을 즉시 실행할 수 있습니다. 여기 <code>yo</code>의 실행 결과가 있습니다.</p>
<p><img src="image_2.png" class="screenshot"/></p>
<p class="notice"><b>주의:</b> 만약 여러분이 백본과 같은 다른 프레임워크를 이용하여 어플리케이션을 완성하고자 할 떄 Yeoman을 어떻게 쓰는지에 대해 읽어보고 싶으시다면, [Yeoman 작업흐름을 이용한 앱 빌드](http://net.tutsplus.com/tutorials/javascript-ajax/building-apps-with-the-yeoman-workflow/)가 흥미로울 것입니다.</p>

<h2 id="toc-polymer-generator">Polymer 생성기</h2>

<p>제가 이전에 이야기한 것과 같이 Polymer는 모던 브라우저들에서 웹 컴포넌트의 사용을 가능하게 하는 polyfill 및 sugar 라이브러리입니다. 이 프로젝트는 개발자들이 미래의 플랫폼을 이용하여 앱을 구축할 수 있도록 해주며 진행 중인 규격이 보다 향상되도록 W3C에 제안을 가능하게 해줍니다.</p>
<p><img src="image_3.png" class="screenshot"/></p>
<p><a href="https://github.com/yeoman/generator-polymer">generator-polymer</a>는 여러분이 Yeoman을 이용한 Polymer 앱의 기반 구조에 도움을 주는 새로운 생성기로 커맨드라인을 통해 쉽게 Polymer (사용자) 요소를 쉽게 생성하고 사용자화 해주고 그것들을 HTML Imports를 이용하여 추가할 수 있게 해줍니다. 이것은 여러분의 보일러플레이트 코드를 작성하는 시간을 절약해줍니다.</p>
<p>다음 실행을 통해 Polymer의 생성기를 설치해봅시다.</p>
<pre class="prettyprint"><code>$ npm install generator-polymer -g
</code></pre>
<p>저것이 전부입니다. 이제 여러분의 앱은 웹 컴포넌트의 강력함을 손에 넣었습니다!</p>
<p>새롭게 설치된 우리의 생성기는 여러분이 이용할 수 있는 작고 특별한 조각들을 가지고 있습니다.</p>
<ul>
<li>
<p><code>polymer:element</code>는 새로운 개별 Polymer 요소를 구조화하는데 사용됩니다.<br/><code>yo polymer:element carousel</code>이 그 예입니다.</p>
</li>
<li>
<p><code>polymer:app</code>는 여러분의 초기 index.html와 프로젝트에 대한 Grunt 태스크들과 빌드 설정을 포함한 Gruntfile.js 그리고 프로젝트에 적합한 폴더 구조와 같은 기반구조를 만드는데 사용됩니다. 또한 여러분의 프로젝트를 위한 Sass Bootstrap을 이용하는 옵션도 제공합니다.</p>
</li>
</ul>
<h2 id="toc-build-app">Polymer 앱을 만들어보자!</h2>

<p>몇몇 사용자 Polymer 요소들과 우리의 새로운 생성기을 사용하여 간단한 블로그를 구축할 것이다.</p>
<p><img src="image_4.png" class="screenshot"/></p>
<p>시작을 위해 터미널에서 <code>mkdir my-new-project &amp;&amp; cd $_</code>를 사용하여 새로운 디렉토리를 생성하고 cd를 통해 않으로 들어가봅시다. 이제 여러분은 다음 실행을 통해 여러분의 Polymer 앱에 시동을 걸 수 있습니다.</p>
<pre class="prettyprint"><code>$ yo polymer
</code></pre>
<p><img src="image_5.png" class="screenshot"/></p>
<p>이것은 Bower를 통해 최신 버전의 Polymer를 가져오고 index.html와 디렉토리 구조, 여러분의 작업 흐름을 위한 Grunt 태스크를 구성합니다. 자, 그럼 준비가 완료될 때까지 커피나 한잔할까요?</p>
<p>좋습니다, 이제 우리는 이렇게 앱의 미리보기를 위해 <code>grunt server</code>를 실행할 수 있습니다. :</p>
<p><img src="image_6.png" class="screenshot"/></p>
<p>서버는 텍스트 편집기를 작동하여 사용자 요소를 편집하고 저장하면 자동으로 리로드되는 라이브 리로드(LiveReload)를 지원합니다. 이것은 여러분이 만든 앱의 현재 상태의 훌륭한 실시간 화면을 여러분에게 제공합니다.</p>
<p>다음으로, 블로그 포스트에서 설명하고 있는 새로운 Polymer 요소를 생성해봅시다.</p>
<pre class="prettyprint"><code>$ yo polymer:element post
</code></pre>
<p><img src="image_7.png" class="screenshot"/></p>
<p>Yeoman은 생성자를 포함 여부와 <code>index.html</code> 내의 기둥(Post) 요소를 포함하기 위해 HTML Import를 사용 여부와 같은 몇가지를 우리에게 질문합니다. 이제 처음 두개 옵션에 '아니오'라고 답하고 세번째 옵션은 공란으로 남겨둡시다.</p>
<p class="notice"><b>주의:</b> 만약 우리가 두번째 질문에 '예'라고 말하면, 생성기는 post.html을 포함하고 그것을 index.html에 포함한다. 또한 &lt;post-element&gt;를 선언하여 페이지 로딩 시에 요소를 렌더링합니다.</p>

<pre class="prettyprint"><code>$ yo polymer:element post

[?] Would you like to include constructor=''? No

[?] Import to your index.html using HTML imports? No

[?] Import other elements into this one? (e.g 'another_element.html' or leave blank)

   create app/elements/post.html
</code></pre>
<p>이것은 <code>/elements</code> 디렉토리의 post.html에 새로운 Polymer 요소를 생성합니다.</p>
<pre class="prettyprint"><code>&lt;polymer-element name="post-element"  attributes=""&gt;

  &lt;template&gt;

    &lt;style&gt;
      @host { :scope {display: block;} }
    &lt;/style&gt;

    &lt;span&gt;I'm &lt;b&gt;post-element&lt;/b&gt;. This is my Shadow DOM.&lt;/span&gt;

  &lt;/template&gt;

  &lt;script&gt;

    Polymer('post-element', {

      //applyAuthorStyles: true,

      //resetStyleInheritance: true,

      created: function() { },

      enteredView: function() { },

      leftView: function() { },

      attributeChanged: function(attrName, oldVal, newVal) { }

    });

  &lt;/script&gt;

&lt;/polymer-element&gt;
</code></pre>
<p>포함하고 있는 것은 다음과 같습니다.</p>
<ul>
<li>
<p><a href="http://www.polymer-project.org/platform/custom-elements.html">사용자 요소</a>를 위한 보일러플레이트 코드는 여러분의 페이지 내에 사용자 DOM 엘리먼트 형식을 사용할 수 있도록 해줍니다. (예. &lt;post-element&gt;)</p>
</li>
<li>
<p>클라이언트측 '네이티브' 템플레이팅을 위한 <a href="http://www.html5rocks.com/tutorials/webcomponents/template/">템플릿 태그</a>과 요소의 스타일을 캡슐화하기 위한 <a href="http://www.html5rocks.com/en/tutorials/webcomponents/shadowdom-201/">스코프 스타일</a></p>
</li>
<li>
<p>요소의 <a href="http://www.polymer-project.org/polymer.html#element-declaration">등록</a> 보일러플레이트와 <a href="http://www.polymer-project.org/polymer.html#lifecyclemethods">생명주기 이벤트</a>.</p>
</li>
</ul>
<h3 id="toc-data">실제 데이터 소스로 작업하기</h3>

<p>우리의 블로그는 새로운 포스트를 읽고 쓰기 위한 공간이 필요할 것입니다. 실제 데이터 서비스를 이용한 작업의 시연을 위해, 우리는 <a href="https://developers.google.com/google-apps/spreadsheets/">Google Apps Spreadsheets API</a>를 이용할 것입니다. 이것은 우리가 Google Docs를 이용하여 생성된 모든 스프레드쉬트의 내용을 읽을 수 있도록 해줄 것입니다.</p>
<p>이것을 설치해보도록 합시다. :</p>
<ol>
<li>
<p>여러분의 브라우저(여기서는 크롬을 추천합니다.)를 열고 <a href="https://docs.google.com/spreadsheet/ccc?key=0AhcraNy3sgspdDhuQ2pvN21JVW9NeVA0M1h4eGo3RGc#gid=0">이 Google Docs Spreadsheet</a>를 열어봅시다. 이것은 다음과 같은 필드들을 포함하고 있는 샘플 포스트 데이터입니다. : <ul class="inline-list">
  <li>ID</li>
  <li>제목</li>
  <li>저자</li>
  <li>내용</li>
  <li>날짜</li>
  <li>키워드</li>
  <li>(저자의) 이메일</li>
  <li>(포스트의 슬러그 URL을 위한) 슬러그(Slug)</li>
</ul></p>
</li>
<li>
<p><strong>File</strong> 메뉴로 가서 스프레드쉬트의 복사본을 생성하기 위해 <strong>Make a copy</strong>를 선택하세요. 여가삼아 내용을 수정하거나, 포스트를 추가나 삭제는 여러분의 자유입니다.</p>
</li>
<li>
<p><strong>File</strong> 메뉴로 한번 더 가서 <strong>Publish to the web</strong>을 선택하세요.</p>
</li>
<li>
<p><strong>start publishing</strong>을 클릭하세요.</p>
</li>
<li>
<p><strong>발행된 데이터의 링크얻기(Get a link to the published data)</strong>라는 이름으로 마지막 텍스트 상자에서 제공된 URL의 <strong>key</strong> 일부를 복사할 수 있습니다. 그것이 이렇게 생겼습니다. <a href="https://docs.google.com/spreadsheet/ccc?key=0AhcraNy3sgspdDhuQ2pvN21JVW9NeVA0M1h4eGo3RGc#gid=0">https://docs.google.com/spreadsheet/ccc?key=0AhcraNy3sgspdDhuQ2pvN21JVW9NeVA0M1h4eGo3RGc#gid=0</a></p>
</li>
<li>
<p>이어지는 URL의 <strong>your-key-goes-here</strong>(여러분의-키는-여기로-갑니다)에 <strong>key</strong>를 붙여넣으세요. : <strong><a href="https://spreadsheets.google.com/feeds/list/your-key-goes-here/od6/public/values?alt=json-in-script&amp;callback=">https://spreadsheets.google.com/feeds/list/your-key-goes-here/od6/public/values?alt=json-in-script&amp;callback=</a></strong>. <a href="https://spreadsheets.google.com/feeds/list/0AhcraNy3sgspdDhuQ2pvN21JVW9NeVA0M1h4eGo3RGc/od6/public/values?alt=json-in-script">https://spreadsheets.google.com/feeds/list/0AhcraNy3sgspdDhuQ2pvN21JVW9NeVA0M1h4eGo3RGc/od6/public/values?alt=json-in-script</a> 같은 것들이 위와 같이 키를 사용하는 예가 될 수 있을 것입니다.</p>
</li>
<li>
<p>여러분은 여러분의 브라우저에 URL을 붙여넣고 여러분의 블로그 콘텐츠의 JSON 버전을 보기 위해 그것을 파헤쳐볼 수도 있습니다. 만약 URL로 나중에 여러분이 반복적으로 화면에 출력하기 위한 이 데이터의 형식을 리뷰하는데는 아주 약간의 시간만이 걸립니다.</p>
</li>
</ol>
<p>여러분의 브라우저에서 JSON 출력은 약간 무섭게 보이겠지만, 절대 걱정하지 마세요! 우리는 그저 여러분의 포스트에만 관심을 가지고 있습니다.</p>
<p>Google Spreadsheets API는 여러분의 블로그에 있는 각 필드들을 특별한 접두어 <code>post.gsx$</code>를 붙여 출력합니다. 예를 들어 <code>post.gsx$title.$t</code>, <code>post.gsx$author.$t</code>, <code>post.gsx$content.$t</code> 등. 우리가 우리의 JSON 출력에 존재하는 각 "행"을 순회하고자 할 때 각 포스트의 관계된 값을 돌려주는 이 필드들을 참조할 겁니다.</p>
<p>이제 여러분은많은 양의 마크업을 여러분의 스프레드쉬트의 데이터와 <a href="http://www.polymer-project.org/docs/polymer/databinding.html">바인딩</a>할 수 있는새롭게 구성된 포스트 요소를 수정할 수 있게 되었습니다. 그렇게 하기 위해서, 우리는 우리가 앞서 생성했던 포스트의 타이틀, 저자, 내용과 다른 필드 등을 읽을<code>post</code> 속성에 대해 소개할 것입니다. (우리가 나중에 덧붙일) <code>selected</code> 속성은 오로지 사용자가 올바른 슬러그(slug)로 네비게이션했을 때 포스트를 보여주기 위해 사용될 것입니다.</p>
<pre class="prettyprint"><code>&lt;polymer-element name="post-element" attributes="post selected"&gt;

  &lt;template&gt;

    &lt;style&gt;
      @host { :scope {display: block;} }
    &lt;/style&gt;

      &lt;div class="col-lg-4"&gt;

          &lt;template if="[[post.gsx$slug.$t === selected]]"&gt;

            &lt;h2&gt;
              &lt;a href="#[[post.gsx$slug.$t]]"&gt;
                [[post.gsx$title.$t  ]]
              &lt;/a&gt;
            &lt;/h2&gt;

            &lt;p&gt;By [[post.gsx$author.$t]]&lt;/p&gt;

            &lt;p&gt;[[post.gsx$content.$t]]&lt;/p&gt;

            &lt;p&gt;Published on: [[post.gsx$date.$t]]&lt;/p&gt;

            &lt;small&gt;Keywords: [[post.gsx$keywords.$t]]&lt;/small&gt;

          &lt;/template&gt;

        &lt;/div&gt;

  &lt;/template&gt;

  &lt;script&gt;

    Polymer('post-element', {

      created: function() { },

      enteredView: function() { },

      leftView: function() { },

      attributeChanged: function(attrName, oldVal, newVal) { }

    });

  &lt;/script&gt;

&lt;/polymer-element&gt;
</code></pre>
<p>다음으로, <code>yo polymer:element blog</code>의 실행을 통해 여러분의 블로그를 위한 포스트와 레이아웃들의 컬렉션을 모두 포함하고 있는 blog 요소를 생성해봅시다.</p>
<pre class="prettyprint"><code>$ yo polymer:element blog

[?] Would you like to include constructor=''? No

[?] Import to your index.html using HTML imports? Yes

[?] Import other elements into this one? (e.g 'another_element.html' or leave blank) post.html

   create app/elements/blog.html
</code></pre>
<p>이때 우리는 우리가 페이지에서 보여주길 원하는 블로그를 <a href="http://www.polymer-project.org/platform/html-imports.html">HTML imports</a>을 사용하여 삽입할 것입니다. 특별히 세번째 프롬프트에서 우리는 우리가 포함하고자 하는 요소로써 <code>post.html</code>를 지정하였습니다.</p>
<p>앞에서 본 바와 같이, 새로운 요소 파일이 (blog.html)로 생성되어 /elements 디렉토리에 추가되면서 post.html을 삽입하고 템플릿 태그 내에 <post-element>를 포함할 것입니다.</p>
<pre class="prettyprint"><code>&lt;link rel="import" href="post.html"&gt;

&lt;polymer-element name="blog-element"  attributes=""&gt;

  &lt;template&gt;

    &lt;style&gt;
      @host { :scope {display: block;} }
    &lt;/style&gt;

    &lt;span&gt;I'm &lt;b&gt;blog-element&lt;/b&gt;. This is my Shadow DOM.&lt;/span&gt;

        &lt;post-element&gt;&lt;/post-element&gt;

  &lt;/template&gt;

  &lt;script&gt;

    Polymer('blog-element', {

      //applyAuthorStyles: true,

      //resetStyleInheritance: true,

      created: function() { },

      enteredView: function() { },

      leftView: function() { },

      attributeChanged: function(attrName, oldVal, newVal) { }

    });

  &lt;/script&gt;

&lt;/polymer-element&gt;
</code></pre>
<p>우리가 index에 <a href="http://www.polymer-project.org/platform/html-imports.html">HTML imports</a>(HTML 문서를 다른 HTML 문서들에서 포함하고 재사용하는 방법)를 사용하여 blog 요소를 포함할 것인지에 대해 질의한 것과 같이 우리는 또한 그것이 문서의 '<head>'에 정확하게 추가되었는지에 대해 검증할 수 있습니다.</p>
<pre class="prettyprint"><code>&lt;!doctype html&gt;
    &lt;head&gt;

        &lt;meta charset="utf-8"&gt;

        &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;

        &lt;title&gt;&lt;/title&gt;

        &lt;meta name="description" content=""&gt;

        &lt;meta name="viewport" content="width=device-width"&gt;

        &lt;link rel="stylesheet" href="styles/main.css"&gt;

        &lt;!-- build:js scripts/vendor/modernizr.js --&gt;

        &lt;script src="bower_components/modernizr/modernizr.js"&gt;&lt;/script&gt;

        &lt;!-- endbuild --&gt;

        &lt;!-- Place your HTML imports here --&gt;

        &lt;link rel="import" href="elements/blog.html"&gt;

    &lt;/head&gt;

    &lt;body&gt;

        &lt;div class="container"&gt;

            &lt;div class="hero-unit" style="width:90%"&gt;

                &lt;blog-element&gt;&lt;/blog-element&gt;

            &lt;/div&gt;

        &lt;/div&gt;

      &lt;script&gt;
        document.addEventListener('WebComponentsReady', function() {
            // Perform some behaviour
        });
      &lt;/script&gt;

        &lt;!-- build:js scripts/vendor.js --&gt;

        &lt;script src="bower_components/polymer/polymer.min.js"&gt;&lt;/script&gt;

        &lt;!-- endbuild --&gt;

&lt;/body&gt;

&lt;/html&gt;
</code></pre>
<p>환상적이군요!</p>
<h3 id="toc-dependencies">Bower를 이용한 의존성 추가하기</h3>

<p>다음으로 posts.json을 읽기 위한 <a href="https://github.com/Polymer/polymer-elements/tree/master/polymer-jsonp">Polymer JSONP</a> 유틸리티 요소를 사용하기 위한 우리의 요소들을 편집해봅시다. 여러분은 git 저장소의 복제하거나 <code>bower install polymer-elements</code>을 실행하여 Bower를 통해 'polymer-elements'를 설치하여 어댑터를 가져올 수 있습니다.</p>
<p><img src="image_9.png" class="screenshot"/></p>
<p>일단 유티리티를 받으면, 여러분은 다음과 같이 여러분의 blog.html 요소를 추가하는 것처럼 그것을 포함하는 것이 필요할 것입니다.</p>
<pre class="prettyprint"><code>&lt;link rel="import" href="../bower_components/polymer-jsonp/polymer-jsonp.html"&gt;
</code></pre>
<p>그리고, 그를 위한 태그를 포함시키고 마지막 부분에 <code>&amp;callback=</code>를 추가하여 앞에 나온 스프레드쉬트를 우리의 블로그에 포스팅하기 위한 <code>url</code>를 넣어야 합니다.</p>
<pre class="prettyprint"><code>&lt;polymer-jsonp auto url="https://spreadsheets.google.com/feeds/list/your-key-value/od6/public/values?alt=json-in-script&amp;callback=" response="[[posts]]"&gt;&lt;/polymer-jsonp&gt;
</code></pre>
<p class="notice"><b>주의:</b>  만약 여러분이 꼼짝도 할 수 없다면 튜토리얼을 계속하기 위해 여러분의 URL 값으로 <a href="https://spreadsheets.google.com/feeds/list/0AhcraNy3sgspdDhuQ2pvN21JVW9NeVA0M1h4eGo3RGc/od6/public/values?alt=json-in-script">https://spreadsheets.google.com/feeds/list/0AhcraNy3sgspdDhuQ2pvN21JVW9NeVA0M1h4eGo3RGc/od6/public/values?alt=json-in-script</a>에 있는 제 스프레드쉬트를 편하게 사용하셔도 됩니다.</p>

<p>여기에서, 이제 우리는 일단 읽어진 우리의 스프레드쉬트를 순환하기 위한 템플릿들을 추가할 수 있습니다. 처음에 슬러그(slug)에서 가리키는 포스트의 링크를 가진 제목을 목차를 출력합니다.</p>
<pre class="prettyprint"><code>&lt;!-- Table of contents --&gt;

&lt;ul&gt;

  &lt;template repeat="[[post in posts.feed.entry]]"&gt;

    &lt;li&gt;&lt;a href="#[[post.gsx$slug.$t]]"&gt;[[post.gsx$title.$t]]&lt;/a&gt;&lt;/li&gt;

  &lt;/template&gt;

&lt;/ul&gt;
</code></pre>
<p>The second renders one instance of <code>post-element</code> for each entry found, passing the post content through to it accordingly. Notice that we’re passing through a <code>post</code> attribute representing the post content for a single spreadsheet row and a <code>selected</code> attribute which we will populate with a route.</p>
<pre class="prettyprint"><code>&lt;!-- Post content --&gt;

&lt;template repeat="[[post in posts.feed.entry]]"&gt;

  &lt;post-element post="[[post]]" selected="[[route]]"&gt;&lt;/post-element&gt;

&lt;/template&gt;
</code></pre>
<p>The <code>repeat</code> attribute you see being used in our template creates and maintains an instance with [[ bindings ]] for every element in the array collection of our posts, when it is provided.</p>
<p><img src="image_10.png" class="screenshot"/></p>
<p>Now in order for us to get the current [[route]] populated, we’re going to cheat and use a library called Flatiron director which binds to [[route]] whenever the URL hash changes. </p>
<p>Thankfully there’s a <a href="https://github.com/Polymer/more-elements/tree/master/flatiron-director">Polymer element</a> (part of the <a href="https://github.com/Polymer/more-elements">more-elements</a> package) that we can grab for it. Once copied to the /elements directory, we can reference it with <code>&lt;flatiron-director route="[[route]]" autoHash&gt;&lt;/flatiron-director&gt;</code>, specifying <code>route</code> as the property we wish to bind to and tell it to automatically read the value of any hash changes (autoHash).</p>
<p>Putting everything together we now get:</p>
<pre class="prettyprint"><code>&lt;link rel="import" href="post.html"&gt;

&lt;link rel="import" href="polymer-jsonp/polymer-jsonp.html"&gt;

&lt;link rel="import" href="flatiron-director/flatiron-director.html"&gt;

&lt;polymer-element name="blog-element"  attributes=""&gt;

  &lt;template&gt;

    &lt;style&gt;
      @host { :scope {display: block;} }
    &lt;/style&gt;

    &lt;div class="row"&gt;

      &lt;h1&gt;&lt;a href="/#"&gt;My Polymer Blog&lt;/a&gt;&lt;/h1&gt;

      &lt;flatiron-director route="[[route]]" autoHash&gt;&lt;/flatiron-director&gt;

      &lt;h2&gt;Posts&lt;/h2&gt;

      &lt;!-- Table of contents --&gt;

      &lt;ul&gt;

        &lt;template repeat="[[post in posts.feed.entry]]"&gt;

          &lt;li&gt;&lt;a href="#[[post.gsx$slug.$t]]"&gt;[[post.gsx$title.$t]]&lt;/a&gt;&lt;/li&gt;

        &lt;/template&gt;

      &lt;/ul&gt;

      &lt;!-- Post content --&gt;

      &lt;template repeat="[[post in posts.feed.entry]]"&gt;

        &lt;post-element post="[[post]]" selected="[[route]]"&gt;&lt;/post-element&gt;

      &lt;/template&gt;

    &lt;/div&gt;

    &lt;polymer-jsonp auto url="https://spreadsheets.google.com/feeds/list/0AhcraNy3sgspdHVQUGd2M2Q0MEZnRms3c3dDQWQ3V1E/od6/public/values?alt=json-in-script&amp;callback=" response="[[posts]]"&gt;&lt;/polymer-jsonp&gt;

  &lt;/template&gt;

  &lt;script&gt;

    Polymer('blog-element', {

      created: function() {},

      enteredView: function() { },

      leftView: function() { },

      attributeChanged: function(attrName, oldVal, newVal) { }

    });

  &lt;/script&gt;

&lt;/polymer-element&gt;
</code></pre>
<p><img src="image_11.png" class="screenshot"/></p>
<p>Woo! We now have a simple blog that's reading data from JSON and using two Polymer elements scaffolded with Yeoman. </p>
<h3 id="toc-third-party">Working with 3rd party elements</h3>

<p>The element ecosystem around Web Components has been growing lately with component gallery sites like <a href="http://customelements.io/">customelements.io</a> beginning to appear. Looking through the elements created by the community, I found one for fetching <a href="https://github.com/djalmaaraujo/gravatar-element">gravatar profiles</a> and we can actually grab and add it to our blog site too.</p>
<p><img src="image_12.png" class="screenshot"/></p>
<p>Copy the gravatar element sources to your <code>/elements</code> directory, include it via HTML imports in post.html and then add <gravatar-element> to your template, passing in the email field from our spreadsheet as the source of the username. Boom!</p>
<pre class="prettyprint"><code>&lt;link rel="import" href="gravatar-element/src/gravatar.html"&gt;

&lt;polymer-element name="post-element" attributes="post selected"&gt;

  &lt;template&gt;

    &lt;style&gt;
      @host { :scope {display: block;} }
    &lt;/style&gt;

      &lt;div class="col-lg-4"&gt;

          &lt;template if="[[post.gsx$slug.$t === selected]]"&gt;

            &lt;h2&gt;&lt;a href="#[[post.gsx$slug.$t]]"&gt;[[post.gsx$title.$t]]&lt;/a&gt;&lt;/h2&gt;

            &lt;p&gt;By [[post.gsx$author.$t]]&lt;/p&gt;

            &lt;gravatar-element username="[[post.gsx$email.$t]]" size="100"&gt;&lt;/gravatar-element&gt;

            &lt;p&gt;[[post.gsx$content.$t]]&lt;/p&gt;

            &lt;p&gt;[[post.gsx$date.$t]]&lt;/p&gt;

            &lt;small&gt;Keywords: [[post.gsx$keywords.$t]]&lt;/small&gt;

          &lt;/template&gt;

        &lt;/div&gt;

  &lt;/template&gt;

  &lt;script&gt;

    Polymer('post-element', {

      created: function() { },

      enteredView: function() { },

      leftView: function() { },

      attributeChanged: function(attrName, oldVal, newVal) { }

    });

  &lt;/script&gt;

&lt;/polymer-element&gt;
</code></pre>
<p>Let’s take a look at what this gives us:</p>
<p><img src="image_13.png" class="screenshot"/></p>
<p>Beautiful!</p>
<p>In a relatively short time, we've created a simple application composed of several web components without having to worry about writing boilerplate code, manually downloading dependencies or setting up a local server or build workflow. </p>
<h3 id="toc-optimization">Optimizing your application</h3>

<p>The Yeoman workflow includes another open-source project called <a href="http://gruntjs.com">Grunt</a> - a task runner that can run a number of build-specific tasks (defined in a Gruntfile) to produce an optimized version of your application. Running <code>grunt</code> on its own will execute a <code>default</code> task the generator has setup for linting, testing and building:</p>
<pre class="prettyprint"><code>grunt.registerTask('default', [

    'jshint',

    'test',

    'build'

]);
</code></pre>
<p>The <code>jshint</code> task above will check with your <code>.jshintrc</code> file to learn your preferences, then run it against all of the JavaScript files in your project. To get the full run down of your options with JSHint, check <a href="http://www.jshint.com/docs/#options">the docs</a>. </p>
<p>The <code>test</code> task looks a little like this, and can create and serve your app for the test framework we recommend out of the box, Mocha. It will also execute your tests for you:</p>
<pre class="prettyprint"><code>grunt.registerTask('test', [

    'clean:server',

    'createDefaultTemplate',

    'jst',

    'compass',

    'connect:test',

    'mocha'

]);
</code></pre>
<p>As our app in this case is fairly simplistic, we'll leave writing tests up to you as a separate exercise. There are a few other things we'll need to have our build process handle, so let's take a look at what the <code>grunt build</code> task defined in our <code>Gruntfile.js</code> will do:</p>
<pre class="prettyprint"><code>grunt.registerTask('build', [

    'clean:dist',    // Clears out your .tmp/ and dist/ folders

    'compass:dist',  // Compiles your Sassiness

    'useminPrepare', // Looks for &lt;!-- special blocks --&gt; in your HTML

    'imagemin',      // Optimizes your images!

    'htmlmin',       // Minifies your HTML files

    'concat',        // Task used to concatenate your JS and CSS

    'cssmin',        // Minifies your CSS files

    'uglify',        // Task used to minify your JS

    'copy',          // Copies files from .tmp/ and app/ into dist/

    'usemin'         // Updates the references in your HTML with the new files

]);
</code></pre>
<p>Run <code>grunt build</code> and a production ready version of your app should be built, ready for you to ship. Let’s try it out.</p>
<p><img src="image_14.png" class="screenshot"/></p>
<p>Success!</p>
<p>If you get stuck, a pre-built version of polymer-blog is available for you to check out <a href="https://github.com/addyosmani/polymer-blog">https://github.com/addyosmani/polymer-blog</a>.</p>
<p class="notice"><b>Note:</b> the most common issues users run into with Yeoman, Grunt and Bower are related to not having the sufficient administrator permissions. Please ensure you’ve followed the <a href="https://gist.github.com/isaacs/579814">recommended</a> installation steps for Node and NPM.</p>

<h3 id="toc-in-store">What more do we have in store?</h3>

<p>Web Components are still in a state of evolution and as such so is the tooling around them. </p>
<p>We’re currently looking at how one might go about concatenating their HTML imports for improved loading performance via projects like <a href="https://github.com/Polymer/labs/tree/master/vulcanize">Vulcanize</a> (a tool by the Polymer project) and how the ecosystem for components might work with a package manager like Bower. </p>
<p>We’ll let you know as and when we have better answers to these questions, but there are lots of exciting times ahead.</p>
<h3 id="toc-standalone-install">Installing Polymer standalone with Bower</h3>

<p>If you would prefer a lighter start to Polymer, you can install it standalone directly from Bower by running:</p>
<pre class="prettyprint"><code>bower install polymer
</code></pre>
<p>which will add it to your bower_components directory. You can then reference it in your application index manually and rock the future.</p>
<h2 id="toc-thoughts">어떻게 생각하십니까?</h2>

<p>이제 여러분은 Yeoman으로 웹 컴포넌트를 하는 Polymer 앱을 어떻게 구축하는지 알았습니다. 만약 여러분이 생성기에 대해 할 이야기가 있으시다면 댓글이나 버그 파일, 포스팅을 Yeoman 이슈 추적기에 남겨주세요. 만약 여러분의 사용에서만 생성기를 보다 낫게 동작할 수 있게 할 수 있더라도 우리가 향상할 수 있는 그 무엇이라도 알려주신다면 무척 고맙겠습니다. :) </p>{% endblock %}
