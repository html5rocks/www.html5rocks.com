{% extends "tutorial.html" %}
{% load mixin from templatefilters %}

{% block pagebreadcrumb %}{{ tut.title }}{% endblock %}

{% block head %}
<style>
figure img {
  border: 1px solid #ccc;
}
.tutorial section {
  overflow: visible;
}
.tutorial section iframe {
  width: 100%;
  border: none;
}
article.tutorial .notice.fact {
  position: relative;
  padding-left: 25px;
}
article.tutorial .notice.fact:before {
  position: absolute;
  top: -5px;
  left: -10px;
  text-transform: uppercase;
  -webkit-transform: rotateZ(-30deg);
  -moz-transform: rotateZ(-30deg);
  -o-transform: rotateZ(-30deg);
  -ms-transform: rotateZ(-30deg);
  transform: rotateZ(-30deg);
  /*color: rgb(80, 139, 136);*/
  color: rgb(237, 71, 50);
  font-weight: bold;
  content: "Fact";
}
.tutorial table td,
.tutorial table th {
  border: 1px solid #ccc;
  padding: 5px;
}
.tutorial table th {
  background: #444;
  color: white;
  padding: 10px;
  font-weight: normal;
}
.tutorial table em {
  margin-left: 15px;
}
.tutorial table tr {
  background: #fff;
}
.tutorial table tr:nth-child(odd) {
  background: #eee;
}
.disabledemos .demoarea {
  display: none !important;
}
.demoarea, .demodevtools {
  margin-top: 20px;
}
.demodevtools {
  display: inline-block;
  position: relative;
  vertical-align: top;
  margin-right: 1em;
}
.demodevtools:before {
  content: 'DevTools view:';
  position: absolute;
  top: -30px;
  left: 0;
  font-weight: bold;
  text-transform: uppercase;
}
.demoarea {
  padding: 10px;
  background: #fff;
  border: 1px dashed #000;
  display: inline-block;
  position: relative;
}
.demoarea:before {
  content: 'Live demo:';
  position: absolute;
  top: -30px;
  left: 0;
  font-weight: bold;
  text-transform: uppercase;
}
.featuresupported.no {
  display: none !important;
}
.talkinghead:before {
  background-image: url(/static/images/profiles/75/ericbidelman.75.png);
  background-position: 0px 0px !important;
}
#example4-log,
#example5-getDestInsertinoPoints {
  width: 100%;
  box-sizing: border-box;
}
#example4-log:before,
#example5-getDestInsertinoPoints:before {
  content: 'Output:';
}
#example5-getDestInsertinoPoints textarea, 
#example4-log textarea {
  outline:none;
  border:none;
  width:100%;
  height:70px;
  resize:none;
}
#inherit-buttons {
  margin-left: 15px;
  margin-top: 20px;
  display: inline-block;
  vertical-align: top;
}
#inherit-buttons button {
  display: block;
  margin-bottom: 10px;
}
.small-notice {
  font-size: 85%;
}
#example5.demoarea {
  display: block;
  margin-top: 30px;
}
#example5 [data-host]:before {
  top: 3px;
  left: 3px;
  position: absolute;
  content: '<div data-host>';
  color: #888;
}
#example5 [data-host] {
  padding: 25px;
  border: 3px solid black;
  display: inline-block;
  background: #eee;
  text-align: center;
  position: relative;
  float: left;
}
#example5 div {
  padding: 5px;
  border-radius: 3px;
  margin-bottom: 5px;
}
#example5 .blue {
  background: steelblue;
  color: white;
  display: inline-block;
}
#example5 .buttons {
  margin-left: 10px;
  float: left;
}
#example5 output {
  background: #eee;
  height: 150px;
  overflow: auto;
  padding: 10px;
  display: block;
  clear: both;
}
#example5 output span {
  font-style: italic;
  font-size: small;
  display: inline-block;
}
#example5 button {
  vertical-align: bottom;
  margin-bottom: 5px;
}
#example5.playing {
  /*cursor: none;*/
}
#example5 .cursor {
  /* Icon by Laurent Patain - http://thenounproject.com/____Lo */
  background-image: url(cursor.svg);
  width: 36px;
  height: 40px;
  background-size: contain;
  background-repeat: no-repeat;
  opacity: 0;
  pointer-events: none;
  position: absolute;
}
#example5.playing .cursor {

}

@-webkit-keyframes animation1 {
  from {
    opacity: 1;
    -webkit-transform: translate3d(70px, -40px, 0);
  }
  90% {
    opacity: 1;
    -webkit-transform: translate3d(70px, 280px, 0);
  }
  to {
    -webkit-transform: translate3d(70px, 280px, 0);
  }
}

@-webkit-keyframes animation2 {
  from {
    opacity: 1;
    -webkit-transform: translate3d(240px, -40px, 0);
  }
  90% {
    opacity: 1;
    -webkit-transform: translate3d(240px, 280px, 0);
  }
  to {
    -webkit-transform: translate3d(240px, 280px, 0);
  }
}

@-webkit-keyframes animation3 {
  from {
    opacity: 1;
    -webkit-transform: translate3d(240px, -40px, 0);
  }
  90% {
    opacity: 1;
    -webkit-transform: translate3d(240px, 128px, 0);
  }
  91% {
    opacity: 1;
    -webkit-transform: translate3d(240px, 128px, 0) rotateX(30deg);
  }
  to {
    opacity: 1;
    -webkit-transform: translate3d(240px, 128px, 0);
  }
}



@keyframes animation1 {
  from {
    opacity: 1;
    -webkit-transform: translate3d(70px, -40px, 0);
    transform: translate3d(70px, -40px, 0);
  }
  90% {
    opacity: 1;
    -webkit-transform: translate3d(70px, 280px, 0);
    transform: translate3d(70px, 280px, 0);
  }
  to {
    -webkit-transform: translate3d(70px, 280px, 0);
    transform: translate3d(70px, 280px, 0);
  }
}

@keyframes animation2 {
  from {
    opacity: 1;
    -webkit-transform: translate3d(240px, -40px, 0);
    transform: translate3d(240px, -40px, 0);
  }
  90% {
    opacity: 1;
    -webkit-transform: translate3d(240px, 280px, 0);
    transform: translate3d(240px, 280px, 0);
  }
  to {
    -webkit-transform: translate3d(240px, 280px, 0);
    transform: translate3d(240px, 280px, 0);
  }
}

@keyframes animation3 {
  from {
    opacity: 1;
    -webkit-transform: translate3d(240px, -40px, 0);
    transform: translate3d(240px, -40px, 0);
  }
  90% {
    opacity: 1;
    -webkit-transform: translate3d(240px, 128px, 0);
    transform: translate3d(240px, 128px, 0);
  }
  91% {
    opacity: 1;
    -webkit-transform: translate3d(240px, 128px, 0) rotateX(30deg);
    transform: translate3d(240px, 128px, 0) rotateX(30deg);
  }
  to {
    opacity: 1;
    -webkit-transform: translate3d(240px, 128px, 0);
    transform: translate3d(240px, 128px, 0);
  }
}

#example5.playing.animation1 .cursor {
  -webkit-animation: animation1 5s;
  animation: animation1 5s;
}
#example5.playing.animation2 .cursor {
  -webkit-animation: animation2 5s;
  animation: animation2 5s;
}
#example5.playing.animation3 .cursor {
  -webkit-animation: animation3 5s;
  animation: animation3 5s;
  -webkit-transform-origin: 50% 100%;
  -moz-transform-origin: 50% 100%;
  -ms-transform-origin: 50% 100%;
  -o-transform-origin: 50% 100%;
  transform-origin: 50% 100%;
}
</style>
{% endblock %}

{% block iscompatible %}
  return !!HTMLElement.prototype.createShadowRoot;
{% endblock %}

{% block html5badge %}
<!-- Your HTML5 badge (tech class icons used in the article) goes here -->
{% endblock %}

{% block share_image %}
<!--<meta itemprop="image" content="images/your_social_sharing_img.png">-->
{% endblock %}

{% block content %}

<p>This article discusses more of the amazing things you can do with Shadow DOM! It builds on the concepts discussed in <a href="/tutorials/webcomponents/shadowdom/">Shadow DOM 101</a>
and <a href="/tutorials/webcomponents/shadowdom-201/">Shadow DOM 201</a>.</p>
<p class="tip notice">In Chrome, turn on the "Enable experimental Web Platform features" in about:flags to experiment with everything covered in this article.</p>

<h2 id="toc-shadow-multiple">Using multiple shadow roots</h2>

<p>If you're hosting a party, it gets stuffy if everyone is crammed into the same room.
You want the option of distributing groups of people across multiple rooms. Elements hosting
Shadow DOM can do this too, that is to say, they can host more than one shadow
root at a time.</p>
<p>Let's see what happens if we try to attach multiple shadow roots to a host:</p>
<pre class="prettyprint">
&lt;div id="example1">Light DOM&lt;/div>
&lt;script>
var container = document.querySelector('#example1');
var root1 = container.createShadowRoot();
var root2 = container.createShadowRoot();
root1.innerHTML = '&lt;div>Root 1 FTW&lt;/div>';
root2.innerHTML = '&lt;div>Root 2 FTW&lt;/div>';
&lt;/script>
</pre>

<div class="demodevtools"> 
<img src="stacking.png" title="Attaching multiple shadow trees" alt="Attaching multiple shadow trees" style="width:250px;">
</div>

<div class="demoarea">
  <div id="example1">Light DOM</div>
</div>

<script>
(function() {
var container = document.querySelector('#example1');
var root1 = container.createShadowRoot();
var root2 = container.createShadowRoot();
root1.innerHTML = '<div>Root 1 FTW</div>';
root2.innerHTML = '<div>Root 2 FTW</div>';
})();
</script>

<p class="notice tip">In the DevTools, turn on "Show Shadow DOM" to be
  able to inspect ShadowRoots.</p>

<p>What renders is "Root 2 FTW", despite the fact that we had already attached a shadow tree.
This is because the last shadow tree added to a host, wins. It's a LIFO stack as
far as rendering is concerned. Examining the DevTools verifies this behavior.</p>
<p class="notice fact">Shadow trees added to a host are stacked in the order they're added,
starting with the most recent first. The last one added is the one that renders.</p>

<blockquote class="commentary talkinghead" id="youngest-tree">
The most recently added tree is called the <b>younger tree</b>. Previous trees are called <b>older trees</b>. In this example, <code>root2</code> is the younger tree and  <code>root1</code> is the older tree.
</blockquote>

<p>So what's the point of using multiple shadows if only the last is invited to the
rendering party? Enter shadow insertion points.</p>
<h3 id="toc-shadow-insertion">Shadow Insertion Points</h3>

<p>"Shadow insertion points" (<code>&lt;shadow&gt;</code>) are similar to normal <a href="/tutorials/webcomponents/shadowdom/#toc-separation-separate">insertion points</a> (<code>&lt;content&gt;</code>) in that they're placeholders. However, instead of being placeholders for a host's <em>content</em>, they're hosts for other <em>shadow trees</em>.
It's Shadow DOM Inception!</p>
<p>As you can probably imagine, things get more complicated the further you drill down
the rabbit hole. For this reason, the spec is very clear about what happens when
multiple <code>&lt;shadow&gt;</code> elements are in play:</p>
<p class="notice fact">If multiple <code>&lt;shadow></code> insertion points exist
in a shadow tree, only the first is recognized. The rest are ignored.</p>

<p>Looking back to our original example, the first shadow <code>root1</code> got left off the
invite list. Adding a <code>&lt;shadow&gt;</code> insertion point brings it back:</p>
<pre class="prettyprint">
&lt;div id="example2">Light DOM&lt;/div>
&lt;script>
var container = document.querySelector('#example2');
var root1 = container.createShadowRoot();
var root2 = container.createShadowRoot();
root1.innerHTML = '&lt;div>Root 1 FTW&lt;/div>&lt;content>&lt;/content>';
<b>root2.innerHTML = '&lt;div>Root 2 FTW&lt;/div>&lt;shadow>&lt;/shadow>';</b>
&lt;/script>
</pre>

<div class="demodevtools"> 
<img src="shadow-insertion-point.png" title="Shadow insertion points" alt="Shadow insertion points" style="width:250px;">
</div>

<div class="demoarea">
  <div id="example2">Light DOM</div>
</div>

<script>
(function() {
var container = document.querySelector('#example2');
var root1 = container.createShadowRoot();
var root2 = container.createShadowRoot();
root1.innerHTML = '<div>Root 1 FTW</div><content></content>';
root2.innerHTML = '<div>Root 2 FTW</div><shadow></shadow>';
})();
</script>

<p>There are a couple of interesting things about this example:</p>
<ol>
<li>"Root 2 FTW" still renders above "Root 1 FTW". This is because of where we've placed
the <code>&lt;shadow&gt;</code> insertion point. If you want the reverse, move the insertion point: <code>root2.innerHTML = '&lt;shadow&gt;&lt;/shadow&gt;&lt;div&gt;Root 2 FTW&lt;/div&gt;';</code>.</li>
<li>Notice there's now a <code>&lt;content&gt;</code> insertion point in root1. This makes
the text node "Light DOM" come along for the rendering ride.</li>
</ol>
<p><b id="toc-shadow-older">What's rendered at &lt;shadow&gt;?</b></p>
<p>Sometimes it's useful to know the older shadow tree being rendered at a <code>&lt;shadow&gt;</code>. You can get a reference to that tree through <code>.olderShadowRoot</code>:</p>
<pre class="prettyprint">
<b>root2.olderShadowRoot</b> === root1 //true
</pre>

<h2 id="toc-get-shadowroot">Obtaining a host's shadow root</h2>

<p>If an element is hosting Shadow DOM you can access its <a href="#youngest-tree">youngest shadow root</a>
using <code>.shadowRoot</code>:</p>
<pre class="prettyprint">
var root = host.createShadowRoot();
console.log(host.shadowRoot === root); // true
console.log(document.body.shadowRoot); // null
</pre>

<p>If you're worried about people crossing into your shadows, redefine
 <code>.shadowRoot</code> to be null:</p>
<pre class="prettyprint">
Object.defineProperty(host, 'shadowRoot', {
  get: function() { return null; },
  set: function(value) { }
});</pre>

<p>A bit of a hack, but it works. In the end, it's important to remember that while amazingly fantastic,
<strong>Shadow DOM has not been designed to be a security feature</strong>. Don't rely on it for
complete content isolation.</p>
<h2 id="toc-creating-js">Building Shadow DOM in JS</h2>

<p>If you prefer building DOM in JS, <code>HTMLContentElement</code> and <code>HTMLShadowElement</code>
have interfaces for that.</p>
<pre class="prettyprint">
&lt;div id="example3">
  &lt;span>Light DOM&lt;/span>
&lt;/div>
&lt;script>
var container = document.querySelector('#example3');
var root1 = container.createShadowRoot();
var root2 = container.createShadowRoot();

var div = document.createElement('div');
div.textContent = 'Root 1 FTW';
root1.appendChild(div);

 // HTMLContentElement
<b>var content = document.createElement('content');
content.select = 'span';</b> // selects any spans the host node contains
root1.appendChild(content);

var div = document.createElement('div');
div.textContent = 'Root 2 FTW';
root2.appendChild(div);

// HTMLShadowElement
<b>var shadow = document.createElement('shadow');</b>
root2.appendChild(shadow);
&lt;/script>
</pre>

<p>This example is nearly identical to the one in the <a href="#toc-shadow-insertion">previous section</a>.
The only difference is that now I'm using <code>select</code> to pull out the newly added <code>&lt;span&gt;</code>.</p>
<h2 id="toc-distributed-nodes">Working with insertion points</h2>

<p>Nodes that are selected out of the host element and "distribute" into the shadow tree
are called...drumroll...distributed nodes! They're allowed to cross the shadow boundary
when insertion points invite them in.</p>
<p>What's conceptually bizarre about insertion points is that they don't physically
move DOM. The host's nodes stay intact. Insertion points merely re-project nodes
from the host into the shadow tree. It's a presentation/rendering thing: <s>"Move these nodes over here"</s> "Render these nodes at this location."</p>
<p class="notice fact">You cannot traverse the DOM into a <code>&lt;content></code>.</p>

<p>For example:</p>
<pre class="prettyprint">
&lt;div>&lt;h2>Light DOM&lt;/h2>&lt;/div>
&lt;script>
var root = document.querySelector('div').createShadowRoot();
root.innerHTML = '&lt;content select="h2">&lt;/content>';

var h2 = document.querySelector('h2');
console.log(root.querySelector('content[select="h2"] h2')); // null;
console.log(root.querySelector('content').contains(h2)); // false
&lt;/script>
</pre>

<p>Voil√†! The <code>h2</code> isn't a child of the shadow DOM. This leads to another tid bit:</p>
<blockquote class="commentary talkinghead">
Insertion points are incredibly powerful. Think of them as a way to create a
"declarative API" for your Shadow DOM. A host element can include all the markup in the world,
but unless I invite it into my Shadow DOM with an insertion point, it's meaningless.
</blockquote>

<h3 id="toc-getDistributedNodes">Element.getDistributedNodes()</h3>

<p>We can't traverse into a <code>&lt;content&gt;</code>, but the <code>.getDistributedNodes()</code> API
allows us to query the distributed nodes at an insertion point:</p>
<pre class="prettyprint">
&lt;div id="example4">
  &lt;h2>Eric&lt;/h2>
  &lt;h2>Bidelman&lt;/h2>
  &lt;div>Digital Jedi&lt;/div>
  &lt;h4>footer text&lt;/h4>
&lt;/div>

&lt;template id="sdom">
  &lt;header>
    &lt;content select="h2">&lt;/content>
  &lt;/header>
  &lt;section>
    &lt;content select="div">&lt;/content>
  &lt;/section>
  &lt;footer>
    &lt;content select="h4:first-of-type">&lt;/content>
  &lt;/footer>
&lt;/template>

&lt;script>
var container = document.querySelector('#example4');

var root = container.createShadowRoot();

var t = document.querySelector('#sdom');
var clone = document.importNode(t.content, true);
root.appendChild(clone);

var html = [];
[].forEach.call(root.querySelectorAll('content'), function(el) {
  html.push(el.outerHTML + ': ');
  var nodes = el.getDistributedNodes();
  [].forEach.call(nodes, function(node) {
    html.push(node.outerHTML);
  });
  html.push('\n');
});
&lt;/script>
</pre>

<div id="example4" style="display:none">
  <h2>Eric</h2>
  <h2>Bidelman</h2>
  <div>Digital Jedi</div>
  <h4>footer text</h4>
</div>

<p><template id="sdom">
  <header>
    <content select="h2"></content>
  </header>
  <section>
    <content select="div"></content>
  </section>
  <footer>
    <content select="h4:first-of-type"></content>
  </footer>
</template></p>
<div id="example4-log" class="demoarea">
 <textarea readonly></textarea>
</div>

<script>
(function() {
if ('HTMLTemplateElement' in window) {
  var container = document.querySelector('#example4');

  var root1 = container.createShadowRoot();
  var t = document.querySelector('#sdom');
  var clone = document.importNode(t.content, true);
  root1.appendChild(clone);

  var html = [];
  [].forEach.call(root1.querySelectorAll('content'), function(el) {
    html.push(el.outerHTML + ': ');
    var nodes = el.getDistributedNodes();
    [].forEach.call(nodes, function(node) {
      html.push(node.outerHTML);
    });
    html.push('\n');
  });

  document.querySelector('#example4-log textarea').value = html.join('');
}
})();
</script>

<h3 id="toc-getDestinationInsertionPoints">Element.getDestinationInsertionPoints()</h3>

<p>Similar to <code>.getDistributedNodes()</code>, you can check what insertion points
a node is distributed into by calling its <code>.getDestinationInsertionPoints()</code>:</p>
<pre class="prettyprint"><code>&lt;div id="host"&gt;
  &lt;h2&gt;Light DOM&lt;/h2&gt;
&lt;/div&gt;

&lt;script&gt;
  var container = document.querySelector('div');

  var root1 = container.createShadowRoot();
  var root2 = container.createShadowRoot();
  root1.innerHTML = '&lt;content select="h2"&gt;&lt;/content&gt;';
  root2.innerHTML = '&lt;shadow&gt;&lt;/shadow&gt;';

  var h2 = document.querySelector('#host h2');
  var insertionPoints = h2.getDestinationInsertionPoints();
  [].forEach.call(insertionPoints, function(contentEl) {
    console.log(contentEl);
  });
&lt;/script&gt;
</code></pre>
<div id="example5-gip" style="display:none">
  <h2>Light DOM</h2>
</div>

<div id="example5-getDestInsertinoPoints" class="demoarea">
 <textarea readonly></textarea>
</div>

<script>
(function() {
if (!!Element.prototype.getDestinationInsertionPoints) { 
  var container = document.querySelector('#example5-gip');
  var h2 = container.querySelector('h2');

  var root1 = container.createShadowRoot();
  var root2 = container.createShadowRoot();
  root1.innerHTML = '<content select="h2"></content>';
  root2.innerHTML = '<shadow></shadow>';

  var html = [];
  var insertionPoints = h2.getDestinationInsertionPoints();
  [].forEach.call(insertionPoints, function(contentEl) {
    html.push(contentEl.outerHTML);
    html.push('\n');
  });

  document.querySelector('#example5-getDestInsertinoPoints textarea').value = html.join('');
}
})();
</script>

<h2 id="toc-shadow-visualizder">Tool: Shadow DOM Visualizer</h2>

<p>Understanding the black magic that is Shadow DOM is difficult. I remember trying
to wrap my head around it for the first time.</p>
<p>To help visualize how Shadow DOM rendering works, I've built a tool
using <a href="http://d3js.org/">d3.js</a>. Both markup boxes on the left-hand side are
editable. Feel free to paste in your own markup and play around to see how things
work and insertion points swizzle host nodes into the shadow tree.</p>
<figure>
<a href="http://html5-demos.appspot.com/static/shadowdom-visualizer/index.html"><img src="visualizer.png" title="Shadow DOM Visualizer" alt="Shadow DOM Visualizer"></a>
<figcaption><a href="http://html5-demos.appspot.com/static/shadowdom-visualizer/index.html">Launch Shadow DOM Visualizer</a></figcaption>
</figure>

<p>
<iframe width="420" height="315" src="http://www.youtube.com/embed/qnJ_s58ubxg" frameborder="0" allowfullscreen></iframe>
</p>

<p>Give it a try and let me know what you think!</p>
<h2 id="toc-events">Event Model</h2>

<p>Some events cross the shadow boundary and some do not. In the cases where events
cross the boundary, the event target is adjusted in order to maintain the
encapsulation that the shadow root's upper boundary provides. That is, <strong>events
are retargeted to look like they've come from the host element rather than internal
elements to the Shadow DOM</strong>.</p>
<p class="tip notice">Access <code>event.path</code> to see the adjusted event path.</p>

<p>If your browser supports Shadow DOM (it does<span class="featuresupported no">n't</span>),
you should see a play area below that helps visualize events. Elements in <span style="color:#ffcc00">yellow</span> are part of the Shadow DOM's markup. Elements in <span style="color:steelblue">blue</span> are
part of the host element. The <span style="color:#ffcc00">yellow</span> border
around "I'm a node in the host" signifies that it is a distributed node, passing
through the shadow's <code>&lt;content&gt;</code> insertion point.</p>
<p>The "Play Action" buttons show you different things to try. Give them a go to see
how the <code>mouseout</code> and <code>focusin</code> events bubble up to the main page.</p>
<div id="example5" class="demoarea">
  <div data-host>
    <div class="blue">I'm a node in the host</div>
  </div>

  <template style="display:none;"> <!-- display:none used for older browsers -->
    <style>
    .scopestyleforolderbrowsers * {
      border: 4px solid #FC0;
    }
    .scopestyleforolderbrowsers input {
      padding: 5px;
    }
    .scopestyleforolderbrowsers div {
      background: #FC0;
      padding: 5px;
      border-radius: 3px;
      margin: 5px 0;
    }
    content::-webkit-distributed(*) {
      border: 4px solid #FC0;
    }
    ::content * {
      border: 4px solid #FC0;
    }
    </style>
    <section class="scopestyleforolderbrowsers">
      <div>I'm a node in Shadow DOM</div>
      <div>I'm a node in Shadow DOM</div>
      <content></content>
      <input type="text" placeholder="I'm in Shadow DOM">
      <div>I'm a node in Shadow DOM</div>
      <div>I'm a node in Shadow DOM</div>
    </section>
  </template>

  <aside class="cursor"></aside>

  <div class="buttons">
    <button data-action="playAnimation" data-action-idx="1">Play Action 1</button><br>
    <button data-action="playAnimation" data-action-idx="2">Play Action 2</button><br>
    <button data-action="playAnimation" data-action-idx="3">Play Action 3</button><br>
    <button data-action="clearLog">Clear log</button>
  </div>

  <output></output>
</div>

<script>
(function() {
function stringify(node) {
  return node.outerHTML.match(".*?>")[0].replace('<', '&lt;').replace('>', '&gt;');
}

var out = document.querySelector('#example5 output');
var host = document.querySelector('#example5 [data-host]');
var wrapper = document.querySelector('#example5');

var root = host.createShadowRoot();
root.innerHTML = document.querySelector('#example5 template').innerHTML;

host.addEventListener('mouseout', function(e) {

  out.innerHTML += [
    '<span>[' + e.type + ']</span>', 
    'on:', stringify(e.target) + ',', 
    'from', stringify(e.fromElement),
    '&rarr;', stringify(e.toElement), '<br>'].join(' ');
  out.scrollTop = out.scrollHeight;
});

document.addEventListener('focusin', function(e) {
  out.innerHTML += [
    '<span>[' + e.type + ']</span>',
    'on:', stringify(e.target), '<br>'].join(' ');
  out.scrollTop = out.scrollHeight;
});

function clearLog() {
  out.innerHTML = '';
}

function cleanUpAnimations(node) {
  [].forEach.call(node.classList, function(c) {
    if (c.indexOf('animation') == 0) {
      node.classList.remove(c);
    }
  });
}

function playAnimation(idx) {
  clearLog();
  wrapper.classList.add('playing');
  wrapper.classList.add('animation' + idx);
}

wrapper.addEventListener('webkitAnimationEnd', function(e) {
  this.classList.remove('playing');
  cleanUpAnimations(this);
});

wrapper.addEventListener('animationend', function(e) {
  this.classList.remove('playing');
  cleanUpAnimations(this);
});

document.querySelector('#example5 .buttons').addEventListener('click', function(e) {
  if (e.target.tagName == 'BUTTON') {
    switch(e.target.dataset.action) {
      case 'clearLog':
        clearLog();
        break;
      case 'playAnimation':
        cleanUpAnimations(wrapper);
        playAnimation(parseInt(e.target.dataset.actionIdx));
        break;
      default:
        break;
    }
  }
});

})();
</script>

<p><strong>Play Action 1</strong></p>
<ul>
<li>This one is interesting. You should see a <code>mouseout</code> from the host element (<code>&lt;div data-host&gt;</code>)
to the <span style="color:steelblue">blue</span> node. Even though it's a distributed
node, it's still in the host, not the ShadowDOM. Mousing further down into 
<span style="color:#ffcc00">yellow</span> again causes a <code>mouseout</code> on the <span style="color:steelblue">blue</span> node.</li>
</ul>
<p><strong>Play Action 2</strong></p>
<ul>
<li>There is one <code>mouseout</code> that appears on host (at the very end). Normally you'd
see <code>mouseout</code> events trigger for all of the <span style="color:#ffcc00">yellow</span> blocks.
However, in this case these elements are internal to the Shadow DOM and the event
doesn't bubble through its upper boundary.</li>
</ul>
<p><strong>Play Action 3</strong></p>
<ul>
<li>Notice that when you click the input, the <code>focusin</code> doesn't appear on the
input but on the host node itself. It's been retargeted!</li>
</ul>
<h3 id="toc-events-stopped">Events that are always stopped</h3>

<p>The following events never cross the shadow boundary:</p>
<ul>
<li>abort</li>
<li>error</li>
<li>select</li>
<li>change</li>
<li>load</li>
<li>reset</li>
<li>resize</li>
<li>scroll</li>
<li>selectstart</li>
</ul>
<h2 id="toc-conclusion">Conclusion</h2>

<p>I hope you'll agree that <strong>Shadow DOM is incredibly powerful</strong>. For the first time ever, we have proper encapsulation without the extra baggage of <code>&lt;iframe&gt;</code>s or other older techniques. </p>
<p>Shadow DOM is certainly complex beast, but it's a beast worth adding to the web platform.
Spend some time with it. Learn it. Ask questions.</p>
<p>If you want to learn more, see Dominic's intro article <a href="/tutorials/webcomponents/shadowdom/">Shadow DOM 101</a>
and my <a href="/tutorials/webcomponents/shadowdom-201/">Shadow DOM 201: CSS &amp; Styling</a> article.</p>
<p class="small-notice">
Thanks to <a href="/profiles/#dominiccooney">Dominic Cooney</a> and 
<a href="https://plus.google.com/111648463906387632236/posts">Dimitri Glazkov</a> for reviewing
the content of this tutorial.
</p><script>
document.addEventListener('DOMContentLoaded', function(e) {
  if (!isCompatible()) {
    document.body.classList.add('disabledemos');
    $('.featuresupported').removeClass('no');
  }
});
</script>
{% endblock %}
