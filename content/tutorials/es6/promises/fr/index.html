{% extends "tutorial.html" %}
{% load mixin from templatefilters %}

{% block head %}
  {{ block.super }}
  <style>
    .get-example {
      display: none;
    }
    dt {
      display: block;
      margin: 0;
      font-weight: bold;
      color: #333;
    }
    dd {
      margin: 0 0 0.8em;
    }

    dl.inline dt {
      display: inline;
    }
    dl.inline dd {
      display: inline;
    }
    dl.inline dd::before {
      content:" - ";
    }
    dl.inline dd::after {
      content:"\A";
      white-space:pre;
    }
  </style>
{% endblock %}

{% block translator %}

<div class="translator">
  <strong>Traducteur :</strong> <a href="http://tddsworld.com/">Christophe Porteneuve</a>
</div>

{% endblock %}

{% block content %}

<p>Mesdames et messieurs, préparez-vous pour un tournant historique dans l’histoire du développement web…</p>
<p><em>[Roulement de tambour]</em></p>
<p>Les promesses sont enfin arrivées en natif dans JavaScript !</p>
<p><em>[Explosion de feux d’artifice, des confettis pailletés pleuvent, la foule est en délire]</em></p>
<p>À ce moment-là, vous appartenez à l’une des catégories suivantes :</p>

<ul>
  <li>Les gens autour de vous débordent de joie, mais vous ne savez pas vraiment ce qu’on est en train de célébrer.  Peut-être même ne savez-vous pas ce qu’est une « promesse ».  Vous hausseriez bien les épaules, mais le poids des confettis vous en empêche.  Si c’est votre cas, ne vous en faites pas, ça m’a pris un temps fou de comprendre pourquoi je devrais m’intéresser à ce truc.  <a href="#toc-async">Vous voudrez sans doute démarrer ici</a></li>
  <li>Vous levez les poings au ciel !  Il était temps, pas vrai ?  Vous avez déjà utilisé ce truc de Promesses mais ça vous embêtait que les diverses implémentations aient des API un peu différentes.  Quelle est l’API de la version JavaScript officielle ?  <a href="#toc-promise-terminology">Vous voudrez sans doute démarrer ici</a></li>
  <li>Vous connaissiez déjà tout ça et vous vous moquez de ceux qui sautillent partout comme si c’était tout neuf pour eux.  Prenez un moment pour vous délecter de votre propre supériorité, puis allez directement à la <a href="#toc-api">référence de l’API</a></li>
</ul>

<h2 id="toc-async">Pourquoi toute cette excitation ?</h2>

<p>JavaScript s’exécute avec un thread unique, ce qui signifie que deux morceaux de script ne peuvent pas s’exécuter en même temps, ils doivent être exécutés l’un après l’autre.  Dans les navigateurs, JavaScript partage son thread avec une tonne de trucs.  La liste exacte dépend du navigateur, mais typiquement JavaScript est dans la même file que l’affichage (<em lang="en">painting</em>), la mise à jour des styles, et la gestion des actions utilisateur (telles que la sélection de texte ou la manipulation de champs de formulaire).  Quand une de ces catégories connaît de l’activité, cela retarde d’autant les autres.</p>
<p>En tant qu’être humain, vous êtes multi-thread.  Vous pouvez taper avec plusieurs doigts, vous pouvez conduire tout en tenant une conversation.  La seule fonction bloquante que nous ayons est l’éternuement, durant lequel toute autre activité doit être suspendue.  C’est assez irritant, surtout si vous conduisez en tenant une conversation.  Vous ne voulez pas écrire du code qui donne envie d’éternuer.</p>
<p>Vous avez probablement eu recours aux événements et fonctions de rappel (<em lang="en">callback</em>) pour contourner ce problème.  Voici des événements :</p>
<pre class="prettyprint">var img1 = document.querySelector('.img-1');

img1.addEventListener('load', function() {
  // ouais génial, image chargée !
});

img1.addEventListener('error', function() {
  // argh tout est cassé
});</pre>

<p>Ça ne donne pas du tout envie d’éternuer.  On récupère l’image, on ajoute quelques gestionnaires d’événement (<em lang="en">listeners</em>), et JavaScript peut suspendre son exécution jusqu’à ce qu’un de ces gestionnaires soit déclenché.</p>
<p>Malheureusement, dans l’exemple ci-dessus, il est possible que ces événements aient eu lieu avant qu’on commence à les écouter, aussi nous devons contourner ce problème en utilisant la propriété « <code>complete</code> » des images :</p>

<pre class="prettyprint">var img1 = document.querySelector('.img-1');

function loaded() {
  // ouais génial, image chargée !
}

if (img1.complete) {
  loaded();
}
else {
  img1.addEventListener('load', loaded);
}

img1.addEventListener('error', function() {
  // argh tout est cassé
});</pre>

<p>Ça ne capture pas les images qui ont levé une erreur avant qu’on ait une opportunité de les écouter, malheureusement le DOM ne nous fournit aucun moyen de gérer ça.  Par ailleurs, ce code charge une image, mais les choses deviennent bien plus complexes quand on essaie de savoir si toute une série d’images a bien été chargée.</p>

<h2 id="toc-events-not-always-best">Les événements ne sont pas toujours le meilleur moyen</h2>

<p>Les événements sont parfaits pour gérer des situations qui peuvent survenir plusieurs fois sur le même objet—keyup, touchstart, etc.  Pour ces événements, vous ne vous souciez guère de ce qui se passait avant que vous n’attachiez un gestionnaire.  Mais lorsqu’il s’agit de succès/échec asynchrone, vous aimeriez idéalement quelque chose de ce genre :</p>

<pre class="prettyprint">img1.callThisIfLoadedOrWhenLoaded(function() {
  // chargée
}).orIfFailedCallThis(function() {
  // échouée
});

// et…
whenAllTheseHaveLoaded([img1, img2]).callThis(function() {
  // toutes chargées
}).orIfSomeFailedCallThis(function() {
  // au moins une a échoué
});</pre>

<p>C’est là ce que font les promesses, mais avec de meilleurs noms de méthodes.  Si les éléments HTML d’image avait une méthode « <code>ready</code> » qui renvoyait une promesse, on aurait pu faire :</p>

<pre class="prettyprint">img1.ready().then(function() {
  // chargée
}, function() {
  // échouée
});

// et…
Promise.all([img1.ready(), img2.ready()]).then(function() {
  // toutes chargées
}, function() {
  // au moins une a échoué
});</pre>

<p>Dans leur forme la plus basique, les promesses sont un peu comme des gestionnaires d’événement sauf que :</p>

<ul>
  <li>Une promesse ne peut réussir ou échouer qu’une seule fois.  Elle ne peut réussir ou échouer plusieurs fois, ni passer du succès à l’échec ou vice versa</li>
  <li>Si une promesse a réussi ou échoué et que vous ajoutez plus tard une fonction de rappel pour le succès ou l’échec, la bonne fonction sera appelée, même si l’événement a eu lieu plus tôt</li>
</ul>

<p>C’est extrêmement utile pour les succès/échecs asynchrones, car vous n’êtes pas tant intéressé par le moment exact auquel quelque chose devient disponible, que par le fait de pouvoir réagir à la conclusion.</p>

<h2 id="toc-promise-terminology">La terminologie des promesses</h2>

<p class="notice warning">
  <strong>Terminologie française</strong> (note du traducteur)<br/>
  La terminologie française pour les promesses n’est pas encore bien établie.  Le recours aux termes anglais est pour l’instant (décembre 2013) la norme.  Cet article tente toutefois de proposer des traductions appropriées, tout en maintenant ci-après une correspondance avec les termes anglais.  C’est la terminologie officielle, telle que calée dans Promises/A+ et dans la spécification ES6 des promesses, qui est retenue.
</p>


<p><a href="https://twitter.com/domenic">Domenic Denicola</a> a relu le premier jet de cet article et m’a attribué un 3/20 pour la terminologie.  Il m’a collé en retenue, m’a forcé à recopier <a href="https://github.com/domenic/promises-unwrapping/blob/master/docs/states-and-fates.md" hreflang="en">States and Fates</a> 100 fois, et a écrit une lettre inquiète à mes parents.  Malgré cela, je m’embrouille toujours pas mal sur la terminologie, mais voici les éléments principaux :</p>

<p>Une promesse peut être :</p>
<dl class="inline">
  <dt>accomplie <em lang="en">(fulfilled)</em></dt>
  <dd>L’action associée à la promesse a réussi</dd>
  <dt>rejetée <em lang="en">(rejected)</em></dt>
  <dd>L’action associée à la promesse a échoué</dd>
  <dt>en attente <em lang="en">(pending)</em></dt>
  <dd>N’est encore ni accomplie ni rejetée</dd>
  <dt>établie <em lang="en">(settled)</em></dt>
  <dd>Est accomplie ou rejetée</dd>
</dl>

<p>La spec utilise également le terme <strong>thenable</strong> pour décrire un objet assimilable à une promesse, au sens où il a une méthode « <code>then</code> ». Ce terme me rappelle l’ancien entraîneur de l’équipe anglaise de football <a href="http://fr.wikipedia.org/wiki/Terry_Venables">Terry Venables</a> aussi j’essaie de m’en servir le moins possible.</p>

<h2 id="toc-javascript-promises">Les promesses arrivent dans JavaScript !</h2>
<p>Les promesses sont là depuis un moment au travers de bibliothèques, telles que :</p>

<ul>
  <li><a href="https://github.com/kriskowal/q">Q</a></li>
  <li><a href="https://github.com/cujojs/when">when</a></li>
  <li><a href="http://msdn.microsoft.com/en-us/library/windows/apps/br211867.aspx">WinJS</a></li>
  <li><a href="https://github.com/tildeio/rsvp.js">RSVP.js</a></li>
</ul>

<p>Ces bibliothèques et les promesses natives à JavaScript partagent un comportement commun, standardisé, appelé <a href="https://github.com/promises-aplus/promises-spec">Promises/A+</a>.  Si vous utilisez jQuery, ils ont quelque chose de similaire appelé <a href="http://api.jquery.com/category/deferred-object/">Deferreds</a>.  Cependant, les Deferreds ne sont pas conformes à Promise/A+, ce qui les rend <a href="https://thewayofcode.wordpress.com/tag/jquery-deferred-broken/">subtilement différents et moins utiles</a>, aussi soyez prudents. jQuery a également <a href="http://api.jquery.com/Types/#Promise">un type Promise</a>, mais il s’agit juste d’un sous-ensemble des fonctionnalités de Deferred et souffre donc des mêmes problèmes.</p>
<p>Même si les implémentations des promesses présentent un comportement standardisé, leurs APIs générales diffèrent.  Les promesses JavaScript ont une API similaire à RSVP.js.  Voici comment créer une promesse :</p>

<pre class="prettyprint">var promise = new Promise(function(resolve, reject) {
  // faire un truc, peut-être asynchrone, puis…

  if (/* tout a bien marché */) {
    resolve("Ces trucs ont marché !");
  }
  else {
    reject(Error("Ça a foiré"));
  }
});</pre>

<p>Le constructeur de promesse prend un argument, une fonction de rappel à deux paramètres, <code>resolve</code> et <code>reject</code>.  Vous faites ce que vous voulez dans le rappel, peut-être quelque chose d’asynchrone, puis appelez <code>resolve</code> quand tout a marché, sinon vous appelez <code>reject</code>.</p>
<p>Comme pour « <code>throw</code> » en bon vieux JavaScript, il est recommandé, mais pas obligatoire, d’appeler <code>reject</code> avec un objet <code>Error</code>.  L’avantage des objets <code>Error</code> c’est qu’ils capturent la pile d’appels, ce qui rend les outils de débogage plus pratiques.</p>
<p>Voici comment utiliser une promesse :</p>

<pre class="prettyprint">promise.then(function(result) {
  console.log(result); // "Ces trucs ont marché !"
}, function(err) {
  console.log(err); // Error: "Ça a foiré"
});</pre>

<p>La méthode <code>then</code> prend deux arguments : une fonction de rappel en cas de succès, et une autre en cas d’échec. Les deux sont optionnels, de sorte que vous pouvez en fournir un seulement pour le succès ou pour l’échec.</p>
<p>Les promesses JavaScript sont nées au sein du DOM sous le nom « <em lang="en">Futures</em> », et ont finalement atterri dans JavaScript.  Les avoir dans JavaScript plutôt que dans le DOM est une très bonne chose, car cela les rend disponibles dans des contextes hors-navigateur tels que Node.js (quant à les voir utilisées par les APIs noyaux de Node, c’est une autre histoire).</p>
<p>Bien qu’il s’agisse d’une fonctionnalité de JavaScript, le DOM n’a pas peur de s’en servir.  En fait, toutes les nouvelles APIs DOM ayant des succès/échecs asynchrones utiliseront les promesses.  Ça a déjà commencé avec <a href="https://dvcs.w3.org/hg/quota/raw-file/tip/Overview.html#idl-def-StorageQuota">Gestion de Quota</a>, <a href="http://dev.w3.org/csswg/css-font-loading/#font-face-set-ready">Événements de Chargement de Fontes</a>, <a href="https://github.com/slightlyoff/ServiceWorker/blob/cf459d473ae09f6994e8539113d277cbd2bce939/service_worker.ts#L17">ServiceWorker</a>, <a href="http://webaudio.github.io/web-midi-api/#widl-Navigator-requestMIDIAccess-Promise-MIDIOptions-options">Web MIDI</a>, <a href="https://github.com/whatwg/streams#basereadablestream">Flux</a>, et d’autres encore.</p>

<h2 id="toc-browser-support">Prise en charge par les navigateurs &amp; polyfill</h2>

<p>Il y a déjà des implémentations (partielles) des promesses dans les navigateurs disponibles aujourd’hui.</p>

<p>Dans Chrome, faites comme les Chromains. <a href="https://www.google.com/intl/fr/chrome/browser/canary.html">Téléchargez Canary</a>, qui a les promesses activées par défaut. Alternativement, si vous êtes plus fan de Firefox, <a href="http://nightly.mozilla.org/">récupérez leur dernière <em lang="en">nightly</em></a>, qui a également les promesses.</p>

<p>Aucun des deux n’a pour le moment une implémentation complète ou parfaitement conforme. Vous pouvez suivre <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=918806">les avancées de Firefox sur bugzilla</a>, et <a href="http://www.chromestatus.com/features/5681726336532480">celles de Chrome sur le panneau de supervision des fonctionnalités</a>.</p>

<p>Pour amener ces navigateurs à prendre en charge toute la spec, ou pour ajouter les promesses à d’autres navigateurs et à Node.js, jetez un œil au <a href="https://github.com/jakearchibald/ES6-Promises/blob/master/README.md">polyfill</a> (2k gzippé).</p>

<h2 id="toc-lib-compatibility">Compatibilité avec les autres bibliothèques</h2>

<p>L’API des promesses JavaScript traitera tout objet avec une méthode « <code>then</code> » comme assimilable à une promesse (ou <em lang="en">thenable</em> en jargon promesses <em>*soupir*</em>), et à l’exception de <code>Promise.cast</code>, il n’y a aucune différence faite entre les instances de promesses JavaScript et les objets assimilables à des promesses.  Du coup, si vous utilisez une bibliothèque qui renvoie une promesse Q, c’est sans souci, ça cohabitera bien avec les nouvelles promesses JavaScript.</p>
<p>Cecit étant, comme je l’ai mentionné plus haut, les Deferreds de jQuery sont un peu… pénibles.  Heureusement vous pouvez les convertir en promesses standard, ce qu’il est bon de faire aussi tôt que possible :</p>

<pre class="prettyprint">var jsPromise = Promise.cast($.ajax('/whatever.json'));</pre>

<p>Ici, l’appel jQuery <code>$.ajax</code> renvoie un <code>Deferred</code>.  Puisqu’il dispose bien d’une méthode <code>then</code>, <code>Promise.cast</code> peut le transformer en promesse JavaScript.  Toutefois, il arrive que les Deferreds passent plusieurs arguments à leurs fonctions de rappel, par exemple :</p>

<pre class="prettyprint">var jqDeferred = $.ajax('/whatever.json');

jqDeferred.then(function(response, statusText, xhrObj) {
  // ...
}, function(xhrObj, textStatus, err) {
  // ...
});</pre>

<p>Tandis que les promesses JS ignorent tout argument au-delà du premier :</p>

<pre class="prettyprint">jsPromise.then(function(response) {
  // ...
}, function(xhrObj) {
  // ...
});</pre>

<p>…heureusement c’est généralement ce que vous voulez, ou à tout le moins ça donne accès à ce que vous voulez.  Qui plus est, sachez que jQuery ne respecte pas la convention qui veut qu’on passe des objets <code>Error</code> aux fonctions de rejet.</p>

<h2 id="toc-coding-with-promises">Simplifier du code asynchrone complexe</h2>

<p>Allez, codons quelque chose.  Imaginons qu’on veuille :</p>

<ol>
  <li>Démarrer un spinner pour indiquer le chargement</li>
  <li>Récupérer le descriptif JSON d’une histoire, qui nous donnera le titre et les URLs de chaque chapitre</li>
  <li>Ajouter le titre à la page</li>
  <li>Récupérer chaque chapitre</li>
  <li>Ajouter l’histoire à la page</li>
  <li>Arrêter le spinner</li>
</ol>

<p>…mais aussi avertir l’utilisateur si quelque chose foire en chemin.  On voudra là aussi arrêter le spinner, sinon il continuera à tournoyer, finira par avoir le vertige, et ira se vautrer dans un autre élément d’interface.</p>

<p>Naturellement, vous n’utiliseriez pas normalement JavaScript pour fournir une histoire, <a href="http://jakearchibald.com/2013/progressive-enhancement-is-faster/">servir le HTML va plus vite</a>, mais ce schéma est plutôt fréquent lorsqu’on travaille avec des APIs : de multiples récupérations de données, puis une action lorsque tout est prêt.</p>

<p>Pour commencer, occupons-nous de la récupération des données depuis le réseau :</p>

<h2 id="toc-promisifying-xmlhttprequest">Enrober XMLHttpRequest dans une promesse</h2>

<p>Les vieilles APIs seront mises à jour pour utiliser les promesses, si cela est possible en maintenant la compatibilité descendante.  <code>XMLHttpRequest</code> est un candidat manifeste, mais en attendant écrivons une fonction simple pour faire une requête GET :</p>

<pre class="prettyprint">function get(url) {
  // Renvoie une nouvelle promesse.
  return new Promise(function(resolve, reject) {
    // Fais le boulot XHR habituel
    var req = new XMLHttpRequest();
    req.open('GET', url);

    req.onload = function() {
      // Ceci est appelé même pour une 404 etc.
      // aussi vérifie le statut
      if (req.status == 200) {
        // Accomplit la promesse avec le texte de la réponse
        resolve(req.response);
      }
      else {
        // Sinon rejette avec le texte du statut
        // qui on l’éspère sera une erreur ayant du sens
        reject(Error(req.statusText));
      }
    };

    // Gère les erreurs réseau
    req.onerror = function() {
      reject(Error("Erreur réseau"));
    };

    // Lance la requête
    req.send();
  });
}</pre>

<p>À présent servons-nous-en :</p>

<pre class="prettyprint">get('story.json').then(function(response) {
  console.log("Succès !", response);
}, function(error) {
  console.error("Échec !", error);
});</pre>

<p><span class="live-example get-example"><a href="story.json">Cliquez ici pour voir ça en action</a>, regardez la console des DevTools pour voir le résultat.</span> Désormais nous pouvons faire des requêtes HTTP sans avoir à taper manuellement <code>XMLHttpRequest</code>, ce qui est génial parce que moins je vois la casse Camel exaspérante de <code>XMLHttpRequest</code>, mieux je me porte.</p>

<h2 id="toc-chaining">Chaînage</h2>

<p>La méthode « <code>then</code> » ne s’arrête pas là, vous pouvez chaîner les <code>then</code> afin de transformer des valeurs ou d’exécuter des actions asynchrones supplémentaires l’une après l’autre.</p>

<h3 id="toc-transforming-values">Tranformer des valeurs</h3>

<p>Vous pouvez transformer les valeurs simplement en retournant la nouvelle valeur :</p>

<pre class="prettyprint">var promise = new Promise(function(resolve, reject) {
  resolve(1);
});

promise.then(function(val) {
  console.log(val); // 1
  return val + 2;
}).then(function(val) {
  console.log(val); // 3
});</pre>

<p>À titre d’exemple pratique, revenons à :</p>

<pre class="prettyprint">get('story.json').then(function(response) {
  console.log("Succès !", response);
});</pre>

<p>La répons est du JSON, mais pour le moment nous la recevons comme du texte brut.  Nous pourrions modifier notre fonction <code>get</code> pour utiliser le <code><a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest#responseType">responseType</a></code> JSON, mais on peut aussi régler ça à l’aide des promesses :</p>

<pre class="prettyprint">get('story.json').then(function(response) {
  return JSON.parse(response);
}).then(function(response) {
  console.log("Ouais du JSON !", response);
});</pre>

<p>Vu que <code>JSON.parse</code> ne prend qu’un seul argument et renvoie la valeur transformée, on peut se permettre un raccourci :</p>

<pre class="prettyprint">get('story.json').then(JSON.parse).then(function(response) {
  console.log("Ouais du JSON !", response);
});</pre>

<p><span class="live-example json-example"><a href="story.json">Cliquez ici pour voir ça en action</a>, regardez la console des DevTools pour voir le résultat.</span> En fait, on pourrait faire une fonction <code>getJSON</code> très facilement :</p>

<pre class="prettyprint">function getJSON(url) {
  return get(url).then(JSON.parse);
}</pre>

<p><code>getJSON</code> renvoie toujours une promesse, laquelle requête une URL puis analyse la réponse en tant que JSON.</p>

<h3 id="toc-promises-queues">Files d’actions asynchrones</h3>

<p>Vous pouvez aussi chaîner les <code>then</code> pour exécuter des actions asynchrones séquentiellement.</p>
<p>Quand vous renvoyez quelque chose depuis une fonction de rappel de <code>then</code>, c’est un peu magique.  Si vous renvoyez une valeur, le prochain <code>then</code> est appelé avec cette valeur.  Mais si vous renvoyez quelque chose d’assimilable à une promesse, le prochain <code>then</code> l’attend, et ne sera appelé que lorsque cette promesse est établie (s’accomplit ou échoue).  Par exemple :</p>

<pre class="prettyprint">getJSON('story.json').then(function(story) {
  return getJSON(story.chapterUrls[0]);
}).then(function(chapter1) {
  console.log("J’ai le chapitre 1 !", chapter1);
});</pre>

<p>Ici nous faisons une requête asynchrone vers « story.json », lequel nous fournit une série d’URLs à requêter, puis nous requêtons la première de celles-ci.  C’est là que les promesses commencent véritablement à se distinguer des approches simples à base de fonctions de rappels.  Vous pourriez même faire une méthode de confort pour récupérer des chapitres :</p>

<pre class="prettyprint">var storyPromise;

function getChapter(i) {
  storyPromise = storyPromise || getJSON('story.json');

  return storyPromise.then(function(story) {
    return getJSON(story.chapterUrls[i]);
  })
}

// et c’est facile à utiliser :
getChapter(0).then(function(chapter) {
  console.log(chapter);
  return getChapter(1);
}).then(function(chapter) {
  console.log(chapter);
});</pre>

<p>Nous ne téléchargeons pas « story.json » jusqu’à ce que <code>getChapter</code> soit appelée, mais la (ou les) prochaine(s) fois que <code>getChapter</code> sera appelée elle réutilisera la promesse relative à l’histoire, de sorte que story.json ne sera chargée qu’une fois.  Vive les promesses !</p>

<h2 id="toc-error-handling">Gestion des erreurs</h2>

<p>Comme nous l’avons vu plus tôt, <code>then</code> prend deux arguments, le premier pour les succès, le second pour les échecs (en jargon de promesses, l’acomplissement et le rejet, respectivement) :</p>

<pre class="prettyprint">get('story.json').then(function(response) {
  console.log("Succès !", response);
}, function(error) {
  console.log("Échec !", error);
});</pre>

<p>Vous pouvez aussi utiliser <code>catch</code> :</p>

<pre class="prettyprint">get('story.json').then(function(response) {
  console.log("Succès !", response);
}).catch(function(error) {
  console.log("Échec !", error);
});</pre>

<p>La méthode <code>catch</code> n’a rien de spécial, c’est juste du sucre syntaxique pour <code>then(undefined, func)</code>, mais c’est plus lisible.  Notez que les deux exemples ci-dessus ne se comportent pas pareil, le dernier est équivalent à :</p>

<pre class="prettyprint">get('story.json').then(function(response) {
  console.log("Succès !", response);
}).then(undefined, function(error) {
  console.log("Échec !", error);
});</pre>

<p>La différence est subtile, mais extrêmement utile.  Les rejets de promesses sautent automatiquement au prochain <code>then</code> doté d’une fonction de rappel pour le rejet (ou au prochain <code>catch</code>, puisque ça revient au même).  Quand vous faites <code>then(func1, func2)</code>, <code>func1</code> ou <code>func2</code> sera appelée, mais jamais les deux. Mais en faisant <code>then(func1).catch(func2)</code>, les deux seront appelées si <code>func1</code> rejette, puisqu’elles constituent des étapes distinctes de la chaîne.  Prenez le code suivant :</p>

<pre class="prettyprint">asyncThing1().then(function() {
  return asyncThing2();
}).then(function() {
  return asyncThing3();
}).catch(function(err) {
  return asyncRecovery1();
}).then(function() {
  return asyncThing4();
}, function(err) {
  return asyncRecovery2();
}).catch(function(err) {
  console.log("T’inquiète donc pas");
}).then(function() {
  console.log("Tout fini !");
});</pre>

<p>Le déroulé du code ci-dessus est très similaire à celui d’un JavaScript classique à base de <code>try/catch</code>, les erreurs qui surviennent dans le « try » vont immédiatement dans le bloc « catch ».  Voici un diagramme de flux (parce que j’adore les diagrammes de flux) :</p>

<div style="max-width: 495px; margin: 10px auto">
  <div style="position: relative; padding-top: 93%;">
    <iframe style="position:absolute;top:0;left:0;width:100%;height:100%;overflow:hidden" src="fr-promise-flow.svg" frameborder="0" allowtransparency="true"></iframe>
  </div>
</div>

<p>Suivez les lignes vertes pour les promesses qui s’accomplissent, ou les rouges pour celles qui sont rejetées.</p>

<h3 id="toc-exceptions-and-promises">Exceptions et promesses JavaScript</h3>

<p>Les rejets surviennent quand une promesse est explicitement rejetée, mais aussi de façon implicite quand une erreur est levée dans une fonction de rappel passée au constructeur :</p>

<pre class="prettyprint">var jsonPromise = new Promise(function(resolve, reject) {
  // JSON.parse lève une erreur si on lui file du
  // JSON invalide, donc ceci rejette implicitement :
  resolve(JSON.parse("Trop pas du JSON"));
});

jsonPromise.then(function(data) {
  // Ceci n’arrive jamais :
  console.log("Ça a marché !", data);
}).catch(function(err) {
  // En revanche, ceci arrive :
  console.log("Ça a échoué !", err);
});</pre>

<p>Du coup, il est utile de faire tout votre travail relatif aux promesses au sein de la fonction de rappel passée au constructeur, afin que les erreurs soient automatiquement rattrapées et converties en rejets.</p>
<p>Il en va de même pour les erreurs levées dans les fonctions de rappel passées à <code>then</code> :</p>

<pre class="prettyprint">get('/').then(JSON.parse).then(function() {
  // Ça n’arrive jamais, '/' est une page HTML, pas du JSON,
  // donc JSON.parse lève une erreur
  console.log("Ça a marché !", data);
}).catch(function(err) {
  // En revanche, ceci arrive :
  console.log("Ça a échoué !", err);
});</pre>

<h3 id="toc-errors-in-practice">La gestion d’erreurs en pratique</h3>

<p>Pour notre histoire et nos chapitres, nous pouvons utiliser <code>catch</code> pour afficher une erreur à l’utilisateur :</p>

<pre class="prettyprint">getJSON('story.json').then(function(story) {
  return getJSON(story.chapterUrls[0]);
}).then(function(chapter1) {
  addHtmlToPage(chapter1.html);
}).catch(function() {
  addTextToPage("L’affichage du chapitre a échoué");
}).then(function() {
  document.querySelector('.spinner').style.display = 'none';
});</pre>

<p>Si le requêtage de <code>story.chapterUrls[0]</code> échoue (ex. HTTP 500 ou utilisateur hors-ligne), le code sautera tous les rappels de succès, y compris celui dans <code>getJSON</code> qui essaie d'analyser la réponse en tant que JSON, ainsi que celui qui ajoute <code>chapter1.html</code> à la page.  Au lieu de ça, il ira dans le rappel de <code>catch</code>.  En vertu de quoi le texte « L’affichage du chapitre a échoué » sera ajouté à la page si l’une quelconque des actions précédentes échoue.</p>

<p>Comme pour le <code>try/catch</code> JavaScript, l’erreur est capturée et les codes ultérieurs continuent à s’exécuter, de sorte que le spinner est masqué, ce qui correspond à ce que nous voulons.  Le code ci-dessus constitue une version non-bloquante, asynchrone, de celui-ci :</p>

<pre class="prettyprint">try {
  var story = getJSONSync('story.json');
  var chapter1 = getJSONSync(story.chapterUrls[0]);
  addHtmlToPage(chapter1.html);
}
catch (e) {
  addTextToPage("L’affichage du chapitre a échoué");
}

document.querySelector('.spinner').style.display = 'none';</pre>

<p>Vous pourriez vouloir recourir à <code>catch</code> uniquement à des fins de journalisation, sans compenser l’erreur pour autant.  Dans ce cas, il vous suffit de relever l’erreur.  On pourrait faire ça dans notre méthode <code>getJSON</code> :</p>

<pre class="prettyprint">function getJSON(url) {
  return get(url).then(JSON.parse).catch(function(err) {
    console.log("getJSON a échoué sur ", url, err);
    throw err;
  });
}</pre>

<p>Bien, nous avons réussi à requêter un chapitre, mais nous les voulons tous.  Voyons comment réaliser ça.</p>

<h2 id="toc-parallelism-sequencing">Parallélisme et séquençage : avoir le meilleur des deux mondes</h2>

<p>Réfléchir en asynchrone n’est pas facile.  Si vous avez du mal à démarrer, essayez d’écrire le code comme s’il était synchrone.  Dans notre cas :</p>

<pre class="prettyprint">try {
  var story = getJSONSync('story.json');
  addHtmlToPage(story.heading);

  story.chapterUrls.forEach(function(chapterUrl) {
    var chapter = getJSONSync(chapterUrl);
    addHtmlToPage(chapter.html);
  });

  addTextToPage("Tout fini !");
}
catch (err) {
  addTextToPage("Argh, cassé : " + err.message);
}

document.querySelector('.spinner').style.display = 'none';</pre>

<p>Ça marche (<a href="fr-sync-example.html">voir l’exemple</a>) ! Mais c’est synchrone et ça bloque le navigateur le temps que les contenus chargent.  Pour rendre ce travail asynchrone nous aurons recours à <code>then</code> afin de faire que chaque tâche s’exécute après la précédente.</p>

<pre class="prettyprint">getJSON('story.json').then(function(story) {
  addHtmlToPage(story.heading);

  // TODO: pour chaque URL dans story.chapterUrls, requêter et afficher
}).then(function() {
  // Et on a tout fini !
  addTextToPage("Tout fini !");
}).catch(function(err) {
  // Récupère toute erreur survenue en chemin
  addTextToPage("Argh, cassé : " + err.message);
}).then(function() {
  // Toujours masquer le spinner
  document.querySelector('.spinner').style.display = 'none';
});</pre>

<p>Mais comment boucler à travers les URLs et les requêter dans l’ordre ?  Le code suivant <strong>ne marche pas</strong> :</p>

<pre class="prettyprint">story.chapterUrls.forEach(function(chapterUrl) {
  // Récupère le chapitre
  getJSON(chapterUrl).then(function(chapter) {
    // et ajoute-le à la page
    addHtmlToPage(chapter.html);
  });
});</pre>

<p>La méthode <code>forEach</code> n’est pas adaptée à l’asynchrone, du coup nos chapitres apparaîtraient dans l’ordre quelconque où on les récupère, ce qui est en gros la façon dont Pulp Fiction a été écrit.  Mais on n’est pas dans Pulp Fiction, alors corrigeons ça…</p>

<h3 id="toc-creating-sequences">Créer une séquence</h3>

<p>Nous voulons transformer notre tableau <code>chapterUrls</code> en une séquence de promesses.  On peut y arriver en utilisant <code>then</code> :</p>

<pre class="prettyprint">// Commencer avec une promesse qui s’accomplit à tous les coups
var sequence = Promise.resolve();

// Boucler à travers chaque URL de chapitre
story.chapterUrls.forEach(function(chapterUrl) {
  // Ajouter ces actions à la fin de la séquence
  sequence = sequence.then(function() {
    return getJSON(chapterUrl);
  }).then(function(chapter) {
    addHtmlToPage(chapter.html);
  });
});</pre>

<p>C’est la première fois que nous voyons <code>Promise.resolve</code>, laquelle crée une promesse qui s’accomplit avec la valeur que vous lui passerez, quelle qu’elle soit.  Si vous lui passez un objet assimilable à une promesse (un objet qui a une méthode <code>then</code>), elle créera une nouvelle promesse qui s’accomplit ou est rejetée de façon identique, en pratique un clone de la vôtre.  Si vous lui passez toute autre valeur (ex. <code>Promise.resolve('Salut')</code>), elle créera une promesse qui s’accomplit avec cette valeur.  Si vous l’appelez sans valeur, comme ci-dessus, la promesse créée s’accomplit avec <code>undefined</code>.</p>

<p>On trouve aussi <code>Promise.reject(val)</code>, qui crée une promesse rejetée avec la valeur que vous avez passée (ou <code>undefined</code>).</p>

<p>Nous pouvons nettoyer un peu le code ci-dessus en tirant parti de <code><a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce">array.reduce</a></code> :</p>

<pre class="prettyprint">// Boucler à travers chaque URL de chapitre
story.chapterUrls.reduce(function(sequence, chapterUrl) {
  // Ajouter ces actions à la fin de la séquence
  return sequence.then(function() {
    return getJSON(chapterUrl);
  }).then(function(chapter) {
    addHtmlToPage(chapter.html);
  });
}, Promise.resolve());</pre>

<p>Ça fait la même chose que l’exemple précédent, mais ça n’a pas besoin d’une variable <code>sequence</code> distincte.  La fonction de rappel passée à <code>reduce</code> est appelée pour chaque élément du tableau.  « <code>sequence</code> » est <code>Promise.resolve()</code> la première fois, puis pour le reste des appels elle sera ce qu’aura retourné l'invocation précédente de notre fonction de rappel.  <code>array.reduce</code> est extrêmement utile lorsqu’il s’agit de ramener un tableau à une valeur unique, laquelle dans ce cas précis est une promesse.</p>

<p>Si on combine tout ça…</p>

<pre class="prettyprint">getJSON('story.json').then(function(story) {
  addHtmlToPage(story.heading);

  return story.chapterUrls.reduce(function(sequence, chapterUrl) {
    // Une fois la promesse du dernier chapitre terminée…
    return sequence.then(function() {
      // …récupérer le prochain chapitre
      return getJSON(chapterUrl);
    }).then(function(chapter) {
      // …et l’ajouter à la page
      addHtmlToPage(chapter.html);
    });
  }, Promise.resolve());
}).then(function() {
  // Et on a tout fini !
  addTextToPage("Tout fini !");
}).catch(function(err) {
  // Récupère toute erreur survenue en chemin
  addTextToPage("Argh, cassé : " + err.message);
}).then(function() {
  // Toujours masquer le spinner
  document.querySelector('.spinner').style.display = 'none';
});</pre>

<p>Et nous y voilà (<a href="fr-async-example.html">voir l’exemple</a>), une déclinaison totalement asynchrone de notre version synchrone.  Mais nous pouvons faire mieux.  Pour le moment, notre page se télécharge comme ceci :</p>

<figure>
  <img src="promise1.gif">
</figure>

<p>Les navigateurs sont plutôt doués pour télécharger plusieurs choses à la fois, du coup nous perdons en performance en téléchargeant nos chapitres l’un après l’autre.  Ce que nous voulons faire, c’est télécharger tous les chapitres en même temps, puis les traiter lorsqu’ils arrivent.  Heureusement il y a une API pour ça :</p>

<pre class="prettyprint">Promise.all(arrayOfPromises).then(function(arrayOfResults) {
  //...
});</pre>

<p><code>Promise.all</code> prend un tableau de promesses et crée une promesse qui s’accomplit quand toutes celles passées se sont accomplies.  Vous obtenez un tableau des résultats (selon ce que chaque promesse a fourni en s’accomplissant) dans le même ordre que les promesses passées en argument.</p>

<pre class="prettyprint">getJSON('story.json').then(function(story) {
  addHtmlToPage(story.heading);

  // Prends un tableau de promesses et attend-les
  return Promise.all(
    // Convertis les URLs de chapitres en
    // un tableau de promesses de JSON de chapitre
    story.chapterUrls.map(getJSON)
  );
}).then(function(chapters) {
  // À ce stade nous avons les JSONs de tous les chapitres,
  // dans l’ordre ! On itère dessus…
  chapters.forEach(function(chapter) {
    // …et on les ajoute à la page
    addHtmlToPage(chapter.html);
  });
  addTextToPage("Tout fini !");
}).catch(function(err) {
  // Récupère toute erreur survenue jusqu’ici
  addTextToPage("Argh, cassé : " + err.message);
}).then(function() {
  document.querySelector('.spinner').style.display = 'none';
});</pre>

<p>Selon la connexion, cela peut économiser plusieurs secondes par rapport au chargement un par un (<a href="fr-async-all-example.html">voir l’exemple</a>), et c’est moins de code que notre première tentative.  Les chapitres peuvent être téléchargés dans un ordre quelconque mais ils apparaîtront dans le bon ordre à l’écran.</p>

<figure>
  <img src="promise2.gif">
</figure>

<p>Ceci dit, nous pouvons encore améliorer la performance perçue.  Lorsque le chapitre un arrive nous devrions l’ajouter à la page.  Ainsi l’utilisateur peut commencer à le lire avant que le reste des chapitres n’arrive.  Quand le chapitre trois arrive, on ne voudrait toutefois pas l’ajouter tout de suite car l’utilisateur pourrait ne pas se rendre compte que le chapitre deux est manquant.  Mais quand le chapitre deux arrive enfin, on ajouterait les chapitres deux et trois, etc.</p>

<p>Pour réussir ça, nous récupérons le JSON de tous nos chapitres en parallèle, puis créons une séquence pour les ajouts sur le document :</p>

<pre class="prettyprint">getJSON('story.json').then(function(story) {
  addHtmlToPage(story.heading);

  // Convertir les URLs de chapitres en
  // un tableau de promesses de JSON de chapitre.
  // Ainsi on est sûrs de les télécharger en parallèle.
  return story.chapterUrls.map(getJSON)
    .reduce(function(sequence, chapterPromise) {
      // Utiliser reduce pour chaîner les promesses,
      // en ajoutant du contenu à la page pour chaque chapitre
      return sequence.then(function() {
        // Attendre l’ensemble de la séquence définie jusqu’ici,
        // puis attendre l’arrivée du chapitre courant.
        return chapterPromise;
      }).then(function(chapter) {
        addHtmlToPage(chapter.html);
      });
    }, Promise.resolve());
}).then(function() {
  addTextToPage("Tout fini !");
}).catch(function(err) {
  // Récupère toute erreur survenue jusqu’ici
  addTextToPage("Argh, cassé : " + err.message);
}).then(function() {
  document.querySelector('.spinner').style.display = 'none';
});</pre>

<p>Et nous y sommes (<a href="fr-async-best-example.html">voir l’exemple</a>), le meilleur des deux mondes ! Il faut un peu de temps pour afficher tout le contenu, mais l’utilisateur a accès au premier morceau aussitôt que possible.</p>

<figure>
  <img src="promise3.gif">
</figure>

<p>Dans cet exemple un peu simpliste, tous les chapitres arrivent à peu près en même temps, mais l’avantage de les afficher l’un après l’autre est plus manifeste lorsqu’il y en a davantage, et de plus gros.</p>

<p>Si on faisait la même chose mais avec des <a href="https://gist.github.com/jakearchibald/0e652d95c07442f205ce">fonctions de rappel et événements façon Node.js</a> ça prendrait environ le double de code, mais surtout ce serait moins facile à suivre.  Néanmoins, ce n’est pas le bout de la route pour les promesses, car en les combinant avec d’autres fonctionnalités de ES6 elles sont encore plus faciles à utiliser…</p>

<h2 class="toc-generators">Niveau bonus : Promesses et Générateurs</h2>

<p>Dans ce qui suit, nous allons utiliser tout un tas de nouvelles fonctionnalités ES6, mais vous n’en avez pas besoin pour comprendre comment utiliser les promesses dès aujourd’hui.  Pensez-y plutôt comme à une bande-annonce pour des fonctionnalités <em lang="en">blockbusters</em> à venir</p>

<p>ES6 nous donne également les <a href="http://wiki.ecmascript.org/doku.php?id=harmony:generators">générateurs</a>, qui permettent aux fonctions de sortir à un endroit précis, comme un <code>return</code>, mais de reprendre leur exécution par la suite au même point et avec le même état.  Par exemple :</p>

<pre class="prettyprint">function *addGenerator() {
  var i = 0;
  while (true) {
    i += yield i;
  }
}</pre>

<p>Remarquez l’astérisque avant le nom de la fonction, c’est ce qui en fait un générateur.  Le mot-clé <code>yield</code> est notre point de sortie/reprise.  Nous pouvons utiliser ce générateur ainsi :</p>

<pre class="prettyprint">var adder = addGenerator();
adder.next().value; // 0
adder.next(5).value; // 5
adder.next(5).value; // 10
adder.next(5).value; // 15
adder.next(50).value; // 65</pre>

<p>Mais que cela signifie-t-il pour les promesses ?  Eh bien, vous pouvez tirer parti de ce comportement de sortie/reprise pour écrire du code asynchrone qui ressemble à (et est aussi facile à lire que) du code synchrone.  Ne vous souciez pas trop de comprendre la fonction suivante ligne à ligne, mais sachez que c’est une fonction de confort qui nous permet d’utiliser <code>yield</code> pour attendre qu’une promesse soit établie :</p>

<pre class="prettyprint">function spawn(generatorFunc) {
  function continuer(verb, arg) {
    var result;
    try {
      result = generator[verb](arg);
    } catch (err) {
      return Promise.reject(err);
    }
    if (result.done) {
      return result.value;
    } else {
      return Promise.cast(result.value).then(onFulfilled, onRejected);
    }
  }
  var generator = generatorFunc();
  var onFulfilled = continuer.bind(continuer, "next");
  var onRejected = continuer.bind(continuer, "throw");
  return onFulfilled();
}</pre>

<p>…fonction que j’ai pratiquement <a href="https://github.com/kriskowal/q/blob/db9220d714b16b96a05e9a037fa44ce581715e41/q.js#L500">copiée telle quelle depuis Q</a>, mais adaptée aux promesses JavaScript.  Grâce à elle, nous pouvons écrire notre dernier exemple, notre meilleur scénario, qui mélange tout un tas de bonnes choses issues d’ES6, pour aboutir à ceci :</p>

<pre class="prettyprint">spawn(function *() {
  try {
    // 'yield' produit en pratique une attente asynchrone,
    // renvoyant le résultat de la promesse
    let story = yield getJSON('story.json');
    addHtmlToPage(story.heading);

    // Convertis nos URLs de chapitres en
    // un tableau de promesses de JSON de chapitre.
    // Ainsi on est sûrs de les télécharger en parallèle.
    let chapterPromises = story.chapterUrls.map(getJSON);

    for (let chapterPromise of chapterPromises) {
      // Attends que chaque chapitre soit prêt,
      // puis ajoute-le à la page
      let chapter = yield chapterPromise;
      addHtmlToPage(chapter.html);
    }

    addTextToPage("Tout fini !");
  }
  catch (err) {
    // try/catch marche normalement, les promesses rejetées sont levées ici
    addTextToPage("Argh, cassé : " + err.message);
  }
  document.querySelector('.spinner').style.display = 'none';
});</pre>

<p>Ça marche exactement comme avant, mais c’est tellement plus facile à lire.  Ça marche dans Chrome Canary dès aujourd’hui (<a href="fr-async-generators-example.html">voir l’exemple</a>), mais il vous faut d’abord aller dans <strong>about:flags</strong> et activer <strong>Activer la fonctionnalité expérimentale JavaScript</strong>.</p>

<p>Ce code mélange plein de nouveautés ES6 : les promesses, les générateurs, <code>let</code>, <code>for…of</code>.  Quand on <code>yield</code> une promesse, la fonction de confort <code>spawn</code> attend que la promesse se résolve et renvoie la valeur finale.  Si la promesse est rejetée, <code>spawn</code> fait en sorte que notre instruction <code>yield</code> lève une exception, laquelle est capturée par un <code>try/catch</code> JavaScript classique.  Voilà un code asynchrone incroyablement simple !</p>

<h2 id="toc-api">Référence API des Promesses</h2>

<p>Toutes les méthodes marchent dans les compilations nocturnes de Chrome et Firefox, sauf mention contraire. <a href="https://github.com/jakearchibald/ES6-Promises/blob/master/README.md">Le polyfill</a> fournit l’API ci-dessous pour tous les navigateurs.</p>

<h3>Méthodes statiques</h3>
<dl>
  <dt><code>Promise.cast(promise);</code></dt>
  <dd>
    Renvoie <code>promise</code> (uniquement si <code>promise.constructor == Promise</code>)
    <p class="notice"><b>Note :</b> Uniquement implémenté dans Chrome pour le moment</p>
  </dd>
  <dt><code>Promise.cast(obj);</code></dt>
  <dd>
    Crée une promesse qui s’accomplit avec <code>obj</code>.
    <p class="notice"><b>Note :</b> Uniquement implémenté dans Chrome pour le moment</p>
  </dd>
  <dt><code>Promise.resolve(thenable);</code></dt>
  <dd>
    Crée une nouvelle promesse à partir de <code>thenable</code>. Un <em lang="en">thenable</em> est assimilable à une promesse dans la mesure où il a une méthode <code>then</code>.
    Cette méthode crée également une nouvelle promesse si on lui passe une véritable promesse JavaScript, ce qui la rend moins efficace pour la conversion que <code>Promise.cast</code>.
    <p class="notice"><b>Note :</b> Chrome la nomme à tort <code>Promise.resolved</code></p>
  </dd>
  <dt><code>Promise.resolve(obj);</code></dt>
  <dd>
    Crée une promesse qui s’accomplit avec <code>obj</code>.  Équivalent à <code>Promise.cast</code> dans cette situation.
    <p class="notice"><b>Note :</b> Chrome la nomme à tort <code>Promise.resolved</code></p>
  </dd>
  <dt><code>Promise.reject(obj);</code></dt>
  <dd>
    Crée une promesse qui est rejetée avec <code>obj</code>.  Pour des raisons de cohérence et de débogage (ex. piles d’appels), <code>obj</code> devrait être <code>instanceof Error</code>
    <p class="notice"><b>Note :</b> Chrome la nomme à tort <code>Promise.rejected</code>
  </p>
  <dt>
  <dt><code>Promise.all(array);</code></dt>
  <dd>
    Crée une promesse qui s’accomplit quand tous les éléments du tableau se sont accomplis, ou est rejetée si (et quand) un élément du tableau est rejeté.  Chaque élément du tableau est passé à <code>Promise.cast</code>, ainsi le tableau d’origine peut mélanger des objets assimilables à des promesses et d’autres objets.  La valeur d’acomplissement est un tableau (dont l’ordre est préservé) des valeurs d’accomplissement individuelles.  La valeur de rejet est la première valeur de rejet.
    <p class="notice"><b>Note :</b> Uniquement implémenté dans Chrome pour le moment</p>
  </dd>
  <dt><code>Promise.race(array);</code></dt>
  <dd>
    Crée une promesse qui s’accomplit dès qu’un des éléments s’accomplit, ou est rejetée dès qu’un des éléments est rejeté.
    <p class="notice"><b>Note :</b> Uniquement implémenté dans Chrome pour le moment sous le nom <code>Promise.one</code>.  Par ailleurs, je ne suis pas convaincu de son utilité, je préfèrerais avoir un opposé à <code>Promise.all</code> qui n’est rejetée que si tous les éléments sont rejetés.</p>
  </dd>
</dl>

<h3>Constructeur</h3>

<pre class="prettyprint">new Promise(function(resolve, reject) {});</pre>
<dl>
  <dt><code>resolve(thenable)</code></dt>
  <dd>Votre promesse sera accomplie ou rejetée avec le résultat de <code>thenable</code></dd>
  <dt><code>resolve(obj)</code></dt>
  <dd>Votre promesse sera accomplie avec <code>obj</code></dd>
  <dt><code>reject(obj)</code></dt>
  <dd>Votre promesse sera rejettée avec <code>obj</code>. Pour des raisons de cohérence et de débogage (ex. piles d’appels), <code>obj</code> devrait être <code>instanceof Error</code>. Toute erreur levée dans la fonction de rappel passée au constructeur sera implicitement passée à <code>reject()</code>.</dd>
</dl>

<!-- RESUME L10N -->
<h3>Méthodes d’instance</h3>
<dl>
  <dt><code>promise.then(onFulfilled, onRejected)</code></dt>
  <dd>
    <code>onFulfilled</code> est appelé quand/si <code>promise</code> s’accomplit.
    <code>onRejected</code> est appelé quand/si <code>promise</code> est rejetée.
    Les deux sont optionnels, et en cas d’omission le prochain <code>onFulfilled</code>/<code>onRejected</code> de la chaîne est appelé.
    Les deux fonctions de rappel prennent un unique paramètre, à savoir la valeur d’accomplissement ou la raison du rejet, respectivement.
    <code>then</code> renvoie une nouvelle promesse équivalente à la valeur renvoyée par <code>onFulfilled</code>/<code>onRejected</code> une fois passée au travers de <code>Promise.resolve</code>.
    Si une erreur est levée dans la fonction de rappel, la promesse renvoyée est rejetée avec cette erreur.</dd>
  <dt><code>promise.catch(onRejected)</code></dt>
  <dd>Sucre syntaxique pour <code>promise.then(undefined, onRejected)</code></dd>
</dl>

<p>Tous mes remerciements à Anne van Kesteren, Domenic Denicola, Tom Ashworth, Remy Sharp, Addy Osmani, Arthur Evans et Yutaka Hirano qui ont relu ceci et proposé des corrections et recommandations.</p>

<script src="promise-2.0.4.min.js"></script>
<script>
  function get(url) {
    // Renvoie une nouvelle promesse.
    // On fait tout le boulot dans le callback du constructeur, donc on peut faire
    // un return dès cette ligne.
    return new Promise(function(resolve, reject) {
      // Fais le boulot XHR habituel
      var req = new XMLHttpRequest();
      req.open('GET', url);

      req.onload = function() {
        // Ceci est appelé même pour une 404 etc.
        // aussi vérifie le statut
        if (req.status == 200) {
          // Accomplit la promesse avec le texte de la réponse
          resolve(req.response);
        }
        else {
          // Sinon rejette avec le texte du statut
          // qui on l’éspère sera une erreur ayant du sens
          reject(Error(req.statusText));
        }
      };

      // Gère les erreurs réseau
      req.onerror = function() {
        reject(Error("Erreur réseau"));
      };

      // Lance la requête
      req.send();
    });
  }

  Array.prototype.slice.call(document.querySelectorAll('.live-example')).forEach(function(el) {
    el.style.display = "inline";
  });

  document.querySelector('.get-example a').addEventListener('click', function(event) {
    if (event.button !== 0) {
      return;
    }

    get(this.href).then(
      console.log.bind(console, "Succès !"),
      console.error.bind(console, "Échec !")
    );
    event.preventDefault();
  });

  document.querySelector('.json-example a').addEventListener('click', function(event) {
    if (event.button !== 0) {
      return;
    }

    get(this.href).then(JSON.parse).then(
      console.log.bind(console, "Ouais du JSON !"),
      console.error.bind(console, "Échec !")
    );
    event.preventDefault();
  });
</script>

{% endblock %}
