{% extends "tutorial.html" %}

{% block pagebreadcrumb %}{{ tut.title }}{% endblock %}

{% block head %}
<style>
.browser-screenshot-list {
	list-style-type: none;
	overflow: hidden;
}
.browser-screenshot-list li {
	float: left;
	height: 120px;
	margin: 15px;
	text-decoration: underline;
	overflow: hidden;
}
.browser-screenshot-list img {
	max-width: 200px;
	height: auto !important;
	display: block;
}
.browser-screenshot-list.wide li {
	height: 150px;
}
.browser-screenshot-list.wide img {
	max-width: 350px;
}
ul .prettyprint {
	font-size: 0.9em;
	line-height: 1.3;
}
</style>
{% endblock %}

{% block iscompatible %}
  return !!('checkValidity' in document.createElement('form'))
{% endblock %}

{% block html5badge %}
<img src="/static/images/identity/html5-badge-h-css3-semantics.png" width="165" height="64" alt="This article is powered by HTML5 CSS3 &amp; Styling and Semantics" title="This article is powered by HTML5 CSS3 &amp; Styling and Semantics" />
{% endblock %}

{% block share_image %}
<meta itemprop="image" content="/static/images/tutorials/constraintvalidation/Chrome.png">
{% endblock %}

{% block content %}

<h2 id="toc-introduction">Introduction</h2>

<p>Validating forms has notoriously been a painful development experience.  Implementing client side validation in a user friendly, developer friendly, and accessible way is hard.  Before HTML5 there was no means of implementing validation natively; therefore, developers have resorted to a variety of JavaScript based solutions.</p> 

<p>To help ease the burden on developers, HTML5 introduced a concept known as <a href="http://www.whatwg.org/specs/web-apps/current-work/#constraint-validation">constraint validation</a> - a native means of implementing client side validation on web forms.</p>

<p>Yet, despite being available in the latest version of all major browsers, constraint validation is a topic largely relegated to presentations and demos.  My goal in writing this is to shed some light on the new APIs to help developers make better web forms for everyone.</p>

<p>In this tutorial I will:</p>
<ul>
	<li>Present a comprehensive overview of what constraint validation is.</li>
	<li>Dig into the current limitations of the spec and browser implementations.</li>
	<li>Discuss how you can use HTML5 constraint validation in your forms now.</li>
</ul>

<h2 id="toc-what-is-it">What is Constraint Validation?</h2>

<p>The core of constraint validation is an algorithm browsers run when a form is submitted to determine its validity.  To make this determination, the algorithm utilizes new HTML5 attributes <code><a href="http://www.whatwg.org/specs/web-apps/current-work/#attr-input-min">min</a></code>, <code><a href="http://www.whatwg.org/specs/web-apps/current-work/#attr-input-max">max</a></code>, <code><a href="http://www.whatwg.org/specs/web-apps/current-work/#attr-input-step">step</a></code>, <code><a href="http://www.whatwg.org/specs/web-apps/current-work/#the-pattern-attribute">pattern</a></code>, and <code><a href="http://www.whatwg.org/specs/web-apps/current-work/#attr-input-required">required</a></code> as well as existing attributes <code><a href="http://www.whatwg.org/specs/web-apps/current-work/#attr-fe-maxlength">maxlength</a></code> and <code><a href="http://www.whatwg.org/specs/web-apps/current-work/#attr-input-type">type</a></code>.

<p>As an example take this form with an empty <code>required</code> text input:</p>

<pre class="prettyprint lang-html">
&lt;form&gt;
    &lt;input type="text" required value="" /&gt;
    &lt;input type="submit" value="Submit" /&gt;
&lt;/form&gt;
</pre>

<a href="http://jsfiddle.net/tj_vantoll/HdSqt/">Try It</a>

<p>If you attempt to submit this form as is, <a href="http://caniuse.com/#feat=form-validation">supporting browsers</a> will prevent the submission and display the following:</p>

<ul class="browser-screenshot-list">
	<li>
		Chrome 21
		<img src="/static/images/tutorials/constraintvalidation/Chrome.png" alt="Chrome 21 display" />
	</li>
	<li>
		Firefox 15
		<img src="/static/images/tutorials/constraintvalidation/Firefox.png" alt="Firefox 15 display" />
	</li>
	<li>
		Internet Explorer 10
		<img src="/static/images/tutorials/constraintvalidation/IE10.png" alt="IE10 display" />
	</li>
	<li>
		Opera 12
		<img src="/static/images/tutorials/constraintvalidation/Opera.png" alt="Opera 12 display" />
	</li>
	<li>
		Opera Mobile
		<img src="/static/images/tutorials/constraintvalidation/OperaMobile.png" alt="Opera Mobile display" />
	</li>
	<li>
		Chrome for Android
		<img src="/static/images/tutorials/constraintvalidation/ChromeForAndroid.png" alt="Chrome for Android display" />
	</li>
	<li>
		Firefox for Android
		<img src="/static/images/tutorials/constraintvalidation/FirefoxForAndroid.png" alt="Firefox for Android display" />
	</li>
</ul>

<p>Per the spec how errors are presented to the user is left up to the browser itself.  However, the spec does provide a full DOM API, new HTML attributes, and CSS hooks authors can use to customize the experience.</p>

<h2 id="toc-dom-api">DOM API</h2>

<p>The <a href="http://www.whatwg.org/specs/web-apps/current-work/#constraint-validation-api">constraint validation API</a> adds the following properties / methods to DOM nodes.</p>

<h3 id="toc-willValidate">willValidate</h3>

<p>The <code>willValidate</code> property indicates whether the node is a candidate for constraint validation.  For <a href="http://www.whatwg.org/specs/web-apps/current-work/#category-submit">submittable elements</a> this will be set to <code>true</code> unless for some reason the node is <a href="http://www.whatwg.org/specs/web-apps/current-work/#barred-from-constraint-validation">barred from constraint validation</a>, such as possessing the <code>disabled</code> attribute.</p>

<pre class="prettyprint lang-html">
&lt;div id="one"&gt;&lt;/div&gt;
&lt;input type="text" id="two" /&gt;
&lt;input type="text" id="three" disabled /&gt;
&lt;script&gt;
    document.getElementById('one').willValidate; //undefined
    document.getElementById('two').willValidate; //true
    document.getElementById('three').willValidate; //false
&lt;/script&gt;
</pre>

<h3 id="toc-validity">validity</h3>

<p>The <a href="http://www.whatwg.org/specs/web-apps/current-work/#dom-cva-validity"><code>validity</code></a> property of a DOM node returns a <a href="http://www.whatwg.org/specs/web-apps/current-work/#validitystate"><code>ValidityState</code></a> object containing a number of boolean properties related to the validity of the data in the node.</p>

<ul>
	<li>
		<code>customError</code>: 
		<code>true</code> if a custom validity message has been set per a call to <code>setCustomValidity()</code>.
<pre class="prettyprint lang-html">
&lt;input id="foo" /&gt;
&lt;input id="bar" /&gt;
&lt;script&gt;
    document.getElementById('foo').validity.customError; //false
    document.getElementById('bar').setCustomValidity('Invalid');
    document.getElementById('bar').validity.customError; //true
&lt;/script&gt;
</pre>
	</li>

	<li>
		<code>patternMismatch</code>: 
		<code>true</code> if the node's <code>value</code> does not match its <code>pattern</code> attribute.
<pre class="prettyprint lang-html">
&lt;input id="foo" pattern="[0-9]{4}" value="1234" /&gt;
&lt;input id="bar" pattern="[0-9]{4}" value="ABCD" /&gt;
&lt;script&gt;
    document.getElementById('foo').validity.patternMismatch; //false
    document.getElementById('bar').validity.patternMismatch; //true
&lt;/script&gt;
</pre>
	</li>

	<li>
		<code>rangeOverflow</code>: 
		<code>true</code> if the node's <code>value</code> is greater than its <code>max</code> attribute.
<pre class="prettyprint lang-html">
&lt;input id="foo" type="number" max="2" value="1" /&gt;
&lt;input id="bar" type="number" max="2" value="3" /&gt;
&lt;script&gt;
    document.getElementById('foo').validity.rangeOverflow; //false
    document.getElementById('bar').validity.rangeOverflow; //true
&lt;/script&gt;
</pre>
	</li>

	<li>
		<code>rangeUnderflow</code>:
		<code>true</code> if the node's <code>value</code> is less than its <code>min</code> attribute.
<pre class="prettyprint lang-html">
&lt;input id="foo" type="number" min="2" value="3" /&gt;
&lt;input id="bar" type="number" min="2" value="1" /&gt;
&lt;script&gt;
    document.getElementById('foo').validity.rangeUnderflow; //false
    document.getElementById('bar').validity.rangeUnderflow; //true
&lt;/script&gt;
</pre>
	</li>

	<li>
		<code>stepMismatch</code>: 
		<code>true</code> if the node's <code>value</code> is invalid per its <code>step</code> attribute.
<pre class="prettyprint lang-html">
&lt;input id="foo" type="number" step="2" value="4" /&gt;
&lt;input id="bar" type="number" step="2" value="3" /&gt;
&lt;script&gt;
    document.getElementById('foo').validity.stepMismatch; //false
    document.getElementById('bar').validity.stepMismatch; //true
&lt;/script&gt;
</pre>
	</li>

	<li>
		<code>tooLong</code>: 
		<code>true</code> if the node's <code>value</code> exceeds its <code>maxlength</code> attribute.  All browsers prevent this from realistically occurring by preventing users from inputting values that exceed the maxlength.  Although rare it is possible to have this property be <code>true</code> in some browsers; I've written about how that's possible <a href="http://tjvantoll.com/2012/10/17/maxlength-constraint-validation-oddities/">here</a>.
	</li>

	<li>
		<code>typeMismatch</code>: 
		<code>true</code> if an input node's <code>value</code> is invalid per its <code>type</code> attribute.
<pre class="prettyprint lang-html">
&lt;input id="foo" type="url" value="http://foo.com" /&gt;
&lt;input id="bar" type="url" value="foo" /&gt;

&lt;input id="foo2" type="email" value="foo@foo.com" /&gt;
&lt;input id="bar2" type="email" value="bar" /&gt;

&lt;script&gt;
    document.getElementById('foo').validity.typeMismatch; //false
    document.getElementById('bar').validity.typeMismatch; //true

    document.getElementById('foo2').validity.typeMismatch; //false
    document.getElementById('bar2').validity.typeMismatch; //true
&lt;/script&gt;
</pre>
	</li>

	<li>
		<code>valueMissing</code>:
		<code>true</code> if the node has a <code>required</code> attribute but has no value.

<pre class="prettyprint lang-html">
&lt;input id="foo" type="text" required value="foo" /&gt;
&lt;input id="bar" type="text" required value="" /&gt;
&lt;script&gt;
    document.getElementById('foo').validity.valueMissing; //false
    document.getElementById('bar').validity.valueMissing; //true
&lt;/script&gt;
</pre>
	</li>

	<li>
		<code>valid</code>: 
		<code>true</code> if all of the validity conditions listed above are <code>false</code>.

<pre class="prettyprint lang-html">
&lt;input id="valid-1" type="text" required value="foo" /&gt;
&lt;input id="valid-2" type="text" required value="" /&gt;
&lt;script&gt;
    document.getElementById('valid-1').validity.valid; //true
    document.getElementById('valid-2').validity.valid; //false
&lt;/script&gt;
</pre>
	</li>
</ul>

<h3 id="toc-validationMessage">validationMessage</h3>

<p>The <code>validationMessage</code> property of a DOM node contains the message the browser displays to the user when a node's validity is checked and fails.</p>

<p>The browser provides a default localized message for this property.  If the DOM node is not a candidate for constraint validation or if the node contains valid data <code>validationMessage</code> will be set to an empty string.</p>

<p><i>Note: As of this writing Opera does not fill in this property by default.  It will show the user a correct error message, it just doesn't fill in the property.</i></p>

<pre class="prettyprint lang-html">
&lt;input type="text" id="foo" required /&gt;
&lt;script&gt;
    document.getElementById('foo').validationMessage;
    //Chrome  --> 'Please fill out this field.'
    //Firefox --> 'Please fill out this field.'
    //Safari  --> 'value missing'
    //IE10    --> 'This is a required field.'
    //Opera   --> ''
&lt;/script&gt;
</pre>

<h3 id="toc-checkValidity">checkValidity()</h3>

<p>The <code>checkValidity</code> method on a form element node (e.g. input, select, textarea) returns <code>true</code> if the element contains valid data.</p>

<p>On form nodes it returns <code>true</code> if all of the form's children contain valid data.</p>

<pre class="prettyprint lang-html">
&lt;form id="form-1"&gt;
    &lt;input id="input-1" type="text" required /&gt;
&lt;/form&gt;
&lt;form id="form-2"&gt;
    &lt;input id="input-2" type="text" /&gt;
&lt;/form&gt;
&lt;script&gt;
    document.getElementById('form-1').checkValidity();  //false
    document.getElementById('input-1').checkValidity(); //false

    document.getElementById('form-2').checkValidity();  //true
    document.getElementById('input-2').checkValidity(); //true
&lt;/script&gt;
</pre>

<p>Additionally, every time a form element's validity is checked via <code>checkValidity</code> and fails, an <code>invalid</code> event is fired for that node.  Using the example code above if you wanted to run something whenever the node with id <code>input-1</code> was checked and contained invalid data you could use the following:</p>

<pre class="prettyprint lang-js">
document.getElementById('input-1').addEventListener('invalid', function() {
    //...
}, false);
</pre>

<p>There is no valid event, however, you can use the <code>change</code> event for notifications of when a field's validity changes.</p>

<pre class="prettyprint lang-js">
document.getElementById('input-1').addEventListener('change', function(event) {
    if (event.target.validity.valid) {
        //Field contains valid data.
    } else {
        //Field contains invalid data.
    }
}, false);
</pre>

<h3 id="toc-setCustomValidity">setCustomValidity()</h3>

<p>The <code>setCustomValidity</code> method changes the <code>validationMessage</code> property as well as allows you to add custom validation rules.</p>

<p>Because it is setting the <code>validationMessage</code> passing in an empty string marks the field as valid and passing any other string marks the field as invalid.  Unfortunately there is no way of setting the <code>validationMessage</code> without also changing the validity of a field.</p>

<p>For example, if you had two password fields you wanted to enforce be equal you could use the following:</p>

<pre class="prettyprint lang-js">
if (document.getElementById('password1').value != document.getElementById('password2').value) {
    document.getElementById('password1').setCustomValidity('Passwords must match.');
} else {
    document.getElementById('password1').setCustomValidity('');
}
</pre>

<h2 id="toc-html-attributes">HTML Attributes</h3>

<p>We've already seen that the <code>maxlength</code>, <code>min</code>, <code>max</code>, <code>step</code>, <code>pattern</code>, and <code>type</code> attributes are used by the browser to constrain data.  For constraint validation there are two additional relevant attributes - <code>novalidate</code> and <code>formnovalidate</code>.</p>

<h3>novalidate</h3>

<p>The boolean <code>novalidate</code> attribute can be applied to form nodes.  When present this attribute indicates that the form's data should not be validated when it is submitted.</p>

<pre class="prettyprint lang-html">
&lt;form novalidate&gt;
    &lt;input type="text" required /&gt;
    &lt;input type="submit" value="Submit" /&gt;
&lt;/form&gt;
</pre>

<p>Because the above form has the <code>novalidate</code> attribute it will submit even though it contains an empty required input.</p>

<h3>formnovalidate</h3>

<p>The boolean <code>formnovalidate</code> attribute can be applied to button and input nodes to prevent form validation.  For example:</p>

<pre class="prettyprint lang-html">
&lt;form&gt;
    &lt;input type="text" required /&gt;
    &lt;input type="submit" value="Validate" /&gt;
    &lt;input type="submit" value="Do NOT Validate" formnovalidate /&gt;
&lt;/form&gt;
</pre>

<a href="http://jsfiddle.net/tj_vantoll/5nD83/">Try It</a>

<p>When the "Validate" button is clicked form submission will be prevented because of the empty input.  However, when the "Do NOT Validate" button is clicked the form will submit despite the invalid data because of the <code>formnovalidate</code> attribute.</p>

<h2 id="toc-inline-bubbles">CSS Hooks</h2>

<p>Writing effective form validation is not just about the errors themselves; it's equally important to show the errors to the user in a usable way, and supporting browsers give you CSS hooks to do just that.

<h3>:invalid and :valid</h3>

<p>In supporting browsers the <code>:valid</code> pseudo-classes will match form elements that meet their specified constraints and the <code>:invalid</code> pseudo-classes will match those that do not.</p>

<pre class="prettyprint lang-html">
&lt;form&gt;
    &lt;input type="text" id="foo" required /&gt;
    &lt;input type="text" id="bar" /&gt;
&lt;/form&gt;
&lt;script&gt;
    document.querySelectorAll('input[type="text"]:invalid'); //Matches input#foo
    document.querySelectorAll('input[type="text"]:valid');   //Matches input#bar
&lt;/script&gt;
</pre>

<h3>Resetting Default Styling</h3>

<p>By default Firefox places a red <code>box-shadow</code> and IE10 places a red <code>outline</code> on <code>:invalid</code> fields.</p>

<ul class="browser-screenshot-list">
	<li>
		Firefox 15
		<img src="/static/images/tutorials/constraintvalidation/Firefox.png" alt="Firefox default erred field display" />
	</li>
	<li>
		Internet Explorer 10
		<img src="/static/images/tutorials/constraintvalidation/IE10.png" alt="IE10 default erred field display" />
	</li>
</ul>

<p>WebKit based browsers and Opera do nothing by default.  If you would like a consistent starting point you can use the following to suppress the defaults.</p>

<pre class="prettyprint lang-css">
:invalid {
    box-shadow: none; /* FF */
    outline: 0;       /* IE 10 */
}
</pre>

<p>I have a pending <a href="https://github.com/necolas/normalize.css/pull/124">pull request</a> to discuss whether this normalization belongs in <a href="https://github.com/necolas/normalize.css">normalize.css</a>.</p>

<h2 id="toc-inline-bubbles">Inline Bubbles</h1>

<p>A larger display discrepancy is the look of the inline validation bubbles the browser displays on invalid fields.  However, WebKit is the only rendering engine that gives you any means of customizing the bubble.  In WebKit you can experiment with the following 4 pseduoclasses in order to get a more custom look.</p>

<pre class="prettyprint lang-css">
::-webkit-validation-bubble {}
::-webkit-validation-bubble-message {}
::-webkit-validation-bubble-arrow {}
::-webkit-validation-bubble-arrow-clipper {}
</pre>

<h3>Removing the Default Bubble</h3>

<p>Because you can only customize the look of the bubbles in WebKit, if you want a custom look across all supporting browsers your only option is to suppress the default bubble and implement your own. The following will disable the default inline validation bubbles from all forms on a page.</p>

<pre class="prettyprint lang-js">
var forms = document.getElementsByTagName('form');
for (var i = 0; i < forms.length; i++) {
    forms[i].addEventListener('invalid', function(e) {
        e.preventDefault();
        //Possibly implement your own here.
    }, true);
}
</pre>

<p>If you do suppress the default bubbles make sure that you do something to show errors to users after invalid form submissions.  Currently the bubbles are the only means by which browsers indicate something went wrong.</p>

<h2 id="toc-current-implementation-issues">Current Implementation Issues and Limitations</h2>

<p>While these new APIs bring a lot of power to client side form validation, there are some limitations to what you are able to do.</p>

<h3 id="toc-setCustomValidity">setCustomValidity</h3>

<p>For simply setting the <code>validationMessage</code> of a field <code>setCustomValidity</code> works, but as forms get more complex a number of limitations of the <code>setCustomValidity</code> method become apparent.</p>

<p><b>Problem #1</b>: Handling multiple errors on one field</p>

<p>Calling <code>setCustomValidity</code> on a node simply overrides its <code>validationMessage</code>.  Therefore, if you call <code>setCustomValidity</code> on the same node twice the second call will simply overwrite the first.  There is no mechanism to handle for an array of error messages or a way of displaying multiple error messages to the user.</p>

<p>One way of handling this is to append additional messages to the node's <code>validationMessage</code> as such.</p>

<pre class="prettyprint lang-js">
var foo = document.getElementById('foo');
foo.setCustomValidity(foo.validationMessage + ' An error occurred');
</pre>

<p>You cannot pass in HTML or formatting characters so unfortunately concatenating strings can leave you with something like this:</p>

<img src="/static/images/tutorials/constraintvalidation/Chrome-multiple-error-messages.png" alt="Chrome display of an error message with concatenated strings" />

<p><b>Problem #2</b>: Knowing when to check the validity of a field</p>

<p>To illustrate this issue consider the example of a form with two password input fields that must match:</p>

<pre class="prettyprint lang-html">
&lt;form&gt;
    &lt;fieldset&gt;
        &lt;legend&gt;Change Your Password&lt;/legend&gt;
        &lt;ul&gt;
            &lt;li&gt;
                &lt;label for="password1"&gt;Password 1:&lt;/label&gt;
                &lt;input type="password" required id="password1" /&gt;
            &lt;/li&gt;
            &lt;li&gt;
                &lt;label for="password2"&gt;Password 2:&lt;/label&gt;
                &lt;input type="password" required id="password2" /&gt;
            &lt;/li&gt;
        &lt;/ul&gt;
        &lt;input type="submit" /&gt;
    &lt;/fieldset&gt;
&lt;/form&gt;
</pre>

<p>My suggestion earlier was to use the <code>change</code> event to implement the validation, which looks something like this:</p>

<pre class="prettyprint lang-js">
var password1 = document.getElementById('password1');
var password2 = document.getElementById('password2');

var checkPasswordValidity = function() {
    if (password1.value != password2.value) {
        password1.setCustomValidity('Passwords must match.');
    } else {
        password1.setCustomValidity('');
    }        
};

password1.addEventListener('change', checkPasswordValidity, false);
password2.addEventListener('change', checkPasswordValidity, false);
</pre>

<a href="http://jsfiddle.net/tj_vantoll/8g8Nz/0/">Try It</a>

<p>Now, whenever the value of either password field is changed by the user the validity will be reevaluated.  However, consider a script that automatically fills in the passwords, or even a script that changes a constraint attribute such as <code>pattern</code>, <code>required</code>, <code>min</code>, <code>max</code>, or <code>step</code>.  This could absolutely affect the validity of the password fields, yet, there is no event to know that this has happened.</p>

<p>Bottom Line: We need a means of running code whenever a field's validity <i>might have</i> changed.</p>

<p><b>Problem #3</b>: Knowing when a user attempts to submit a form</p>

<p>Why not use the form's <code>submit</code> event for the problem described above?  The <code>submit</code> event is not fired until after the browser has determined a form contains valid data given all of its specified constraints.  Therefore, there is no way of knowing when a user attempts to submit a form and it is prevented by the browser.</p>

<p>It can be very useful to know when a submission attempt occurs.  You may want to show the user a list of error messages, change focus, or display help text of some sort.  Unfortunately, you'll need a workaround to make this happen.</p>

<p>One way to accomplish this is by adding the <code>novalidate</code> attribute to the form and use its <code>submit</code> event.  Because of the <code>novalidate</code> attribute the form submission will not be prevented regardless of the validity of the data.  Therefore, the client script will have to explicitly check whether the form contains valid data in a <code>submit</code> event and prevent submission accordingly.  Here's an extension of the password match example that enforces that the validation logic will run before the form is submitted.</p>

<pre class="prettyprint lang-html">
&lt;form id="passwordForm" novalidate&gt;
    &lt;fieldset&gt;
        &lt;legend&gt;Change Your Password&lt;/legend&gt;
        &lt;ul&gt;
            &lt;li&gt;
                &lt;label for="password1"&gt;Password 1:&lt;/label&gt;
                &lt;input type="password" required id="password1" /&gt;
            &lt;/li&gt;
            &lt;li&gt;
                &lt;label for="password2"&gt;Password 2:&lt;/label&gt;
                &lt;input type="password" required id="password2" /&gt;
            &lt;/li&gt;
        &lt;/ul&gt;
        &lt;input type="submit" /&gt;
    &lt;/fieldset&gt;
&lt;/form&gt;
&lt;script&gt;
    var password1 = document.getElementById('password1');
    var password2 = document.getElementById('password2');

    var checkPasswordValidity = function() {
        if (password1.value != password2.value) {
            password1.setCustomValidity('Passwords must match.');
        } else {
            password1.setCustomValidity('');
        }        
    };

    password1.addEventListener('change', checkPasswordValidity, false);
    password2.addEventListener('change', checkPasswordValidity, false);

    var form = document.getElementById('passwordForm');
    form.addEventListener('submit', function() {
        checkPasswordValidity();
        if (!this.checkValidity()) {
            event.preventDefault();
            //Implement you own means of displaying error messages to the user here.
            password1.focus();
        }
    }, false);
&lt;/script&gt;
</pre>

<a href="http://jsfiddle.net/tj_vantoll/8g8Nz/">Try It</a>

<p>The major disadvantage of this approach is that adding the <code>novalidate</code> attribute to a form prevents the browser from displaying the inline validation bubble to the user.  Therefore, if you use this technique you must implement your own means of presenting error messages to the user.  <a href="http://jsfiddle.net/tj_vantoll/a533m/">Here is a simple example</a> showing one way of accomplishing this.</p>

<p>Bottom Line: We need a <code>forminvalid</code> event that would be fired whenever a form submission was prevented due to invalid data.</p>

<h3 id="toc-safari">Safari</h3>

<p>Even though Safari supports the constraint validation API, as of this writing (version 6), Safari will not prevent submission of a form with constraint validation issues.  To the user Safari will behave no differently than a browser that doesn't support constraint validation at all.</p>

<p>The easiest way around this is to use the same approach as the workaround described above, give all forms the <code>novalidate</code> attribute and manually prevent form submissions using <code>preventDefault</code>.  The following code adds this behavior to all forms.<p>

<pre class="prettyprint lang-js">
var forms = document.getElementsByTagName('form');
for (var i = 0; i < forms.length; i++) {
    forms[i].noValidate = true;

    forms[i].addEventListener('submit', function(event) {
        //Prevent submission if checkValidity on the form returns false.
        if (!event.target.checkValidity()) {
            event.preventDefault();
            //Implement you own means of displaying error messages to the user here.
        }
    }, false);
}
</pre>

<a href="http://jsfiddle.net/tj_vantoll/rFLxt/">Try It</a>

<p>Note: There are several documented bugs where the <code>checkValidity</code> method returns false positives (see <a href="https://bugs.webkit.org/show_bug.cgi?id=48491">here</a> and <a href="https://github.com/aFarkas/webshim/issues/134">here</a> for examples).  False positives are especially dangerous with the above workaround because the user will be stuck on a form with valid data, so use caution.</p>

<h3 id="toc-declarative-error-messages">Declarative Error Messages</h3>

<p>While you have the ability to change a field's error message by setting its <code>validationMessage</code> through <code>setCustomValidity</code>, it can be a nuisance to continuously setup the JavaScript boilerplate to make this happen, especially on large forms.</p>

<p>To help make this process easier, Firefox introduced a custom <code>x-moz-errormessage</code> attribute that can be used to automatically set a field's <code>validationMessage</code>.

<pre class="prettyprint lang-html">
&lt;form&gt;
    &lt;input type="text" required x-moz-errormessage="Fill this out." /&gt;
    &lt;input type="submit" value="Submit" /&gt;
&lt;/form&gt;
</pre>

<a href="http://jsfiddle.net/tj_vantoll/CCZNp/">Try It</a>

<p>When the above form is submitted in Firefox the user will see the custom message instead of the browser's default.</p>

<img src="/static/images/tutorials/constraintvalidation/Firefox-moz-errormessage.png" alt="Firefox display of the x-moz-errormessage attribute" />

<p>This feature was <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=10923">proposed to the W3C</a> but was rejected.  Therefore, at the moment Firefox is the only browser where you can declaratively specify error messages.</p>

<h4>Title Attribute</h4>

<p>While it doesn't change the <code>validationMessage</code>, in the case of a <code>patternMismatch</code> browsers do display the contents of the <code>title</code> attribute in the inline bubble if it's provided.  (<i>Note: Chrome will actually display the <code>title</code> attribute when provided for any type of error, not just <code>patternMismatch</code>es.</i>)</p>

<p>For example if you try to submit the following form:</p>

<pre class="prettyprint lang-html">
&lt;form&gt;
    &lt;label for="price"&gt;Price: $&lt;/label&gt;
    &lt;input type="text" pattern="[0-9].[0-9][0-9]" 
        title="Please enter the price in x.xx format (e.g. 3.99)"
        id="price" value="3" /&gt;
    &lt;input type="submit" value="Submit" /&gt;
&lt;/form&gt;
</pre>

<a href="http://jsfiddle.net/tj_vantoll/SVWXw/">Try It</a>

<p>Here's a sampling of what browsers will display:</p>

<ul class="browser-screenshot-list wide">
	<li>
		Chrome 21
		<img src="/static/images/tutorials/constraintvalidation/Chrome-title-attribute.png" alt="Chrome display of the title attribute" />
	</li>
	<li>
		Firefox 15
		<img src="/static/images/tutorials/constraintvalidation/Firefox-title-attribute.png" alt="Firefox display of the title attribute" />
	</li>
	<li>
		Opera 12
		<img src="/static/images/tutorials/constraintvalidation/Opera-title-attribute.png" alt="Opera display of the title attribute" />
	</li>
	<li>
		IE 10
		<img src="/static/images/tutorials/constraintvalidation/IE10-title-attribute.png" alt="IE10 display of the title attribute" />
	</li>
</ul>

<h3 id="toc-invalid-valid">:invalid and :valid</h3>

<p>As discussed earlier the <code>:valid</code> pseudo-class will match form elements that meet all specified constraints and the <code>:invalid</code> pseudo-class will match those that do not.  Unfortunately these pseudo-classes will be matched immediately, before the form is submitted and before the form is interacted with.  Consider the following example:

<pre class="prettyprint lang-html">
&lt;style&gt;
    :invalid {
        border: 1px solid red;
    }
    :valid {
        border: 1px solid green;
    }
&lt;/style&gt;
&lt;form&gt;
    &lt;input type="text" required /&gt;
    &lt;input type="text" /&gt;
&lt;/form&gt;
</pre>

<a href="http://jsfiddle.net/tj_vantoll/6sygE/">Try It</a>

<p>The goal here is to simply place a red border around invalid fields and a green border around valid ones, which it does immediately as the form is rendered.  However, <a href="http://www.alistapart.com/articles/inline-validation-in-web-forms/">usability tests of inline form validation</a> have shown that the best time to give user feedback is immediately <b>after</b> they interact with  a field, not before.</p>

<p>One way to accomplish this with the example above is to add a class to the inputs after they have been interacted with and only apply the borders when the class is present.</p>

<pre class="prettyprint lang-html">
&lt;style&gt;
    .interacted:invalid {
        border: 1px solid red;
    }
    .interacted:valid {
        border: 1px solid green;
    }
&lt;/style&gt;
&lt;form&gt;
    &lt;input type="text" required /&gt;
    &lt;input type="text" /&gt;
    &lt;input type="submit" /&gt;
&lt;/form&gt;
&lt;script&gt;
    var inputs = document.querySelectorAll('input[type=text]');
    for (var i = 0; i < inputs.length; i++) {
        inputs[i].addEventListener('blur', function(event) {
            event.target.classList.add('interacted');
        }, false);
    }
&lt;/script&gt;
</pre>

<a href="http://jsfiddle.net/tj_vantoll/WLHDY/">Try It</a>

<p>Firefox has seen these issues and <a href="http://blog.oldworld.fr/index.php?post/2011/05/Improving-HTML5-Forms-user-experience-with-moz-ui-invalid-and-moz-ui-valid-pseudo-classes">implemented two additional pseudo-classes</a> - <code>:-moz-ui-invalid</code> and <code>:-moz-ui-valid</code>.  Unlike <code>:invalid</code> and <code>:valid</code>, <code>:-moz-ui-invalid</code> and <code>:-moz-ui-valid</code> will not match a field until the field is modified or the user tries to submit the form with invalid input.</p>

<p>Based on this work the <a href="http://www.w3.org/TR/selectors4/#user-pseudos">CSS selectors level 4 specification</a> contains a <code>:user-error</code> pseudo-class that functions much like <code>:-moz-ui-invalid</code>.  It has yet to be implemented by any browsers.</p>

<p>One final note.  Be aware that <code>:valid</code> and <code>:invalid</code> should match <code>&lt;form&gt;</code> nodes in addition to form elements.  Currently this has only been implemented in Firefox, but be careful when applying global rules to <code>:valid</code> and <code>:invalid</code>.</p>

<h3 id="toc-unsupported-browsers">Unsupported Browsers</h3>

<p>While browser support for constraint validation is quite good, there are still some major players in which it is not present, most notably IE <= 9, iOS Safari, and the default Android browser.</p>

<h2 toc="toc-dealing-with-unsupported-browsers">Dealing with Unsupported Browsers</h3>

<p>If you intend to use the new constraint validation APIs in a production web form you have to do <i>something</i> about unsupported browsers.  In my experience there are two primary options:</p>

<p><b>Option 1</b> - Rely on Server Side Validation Alone</p>

<p>It's important to remember that even with these new APIs client side validation does not remove the need for server side validation.  Malicious users can easily workaround any client side constraints, and, HTTP requests don't have to originate from a browser.</p>

<p>Therefore client side validation should always be treated as a progressive enhancement to the user experience; all forms should be usable even if client side validation is not present.</p>

<p>Since you have to have server side validation anyways, if you simply have your server side code return reasonable error messages and display them to the end user you have a built in fallback for browsers that don't support any form of client side validation.</p>

<p><b>Option 2</b> - Polyfill</p>

<p>While relying on server side validation is reasonable for some applications, for many throwing away the usability advantages of client side validation for users in non-supporting browsers is simply not an option.</p>

<p>If you want to write code with the new APIs and want it to work anywhere the best way to accomplish this is with a <a href="http://remysharp.com/2010/10/08/what-is-a-polyfill/">polyfill</a>.  In addition to making the APIs work in non-supporting browsers, many polyfills take an extra step and workaround some of the issues in the native implementations.</p>

<h2 id="toc-polyfilling">Polyfilling</h2>

<p>There are a <a href="https://github.com/Modernizr/Modernizr/wiki/HTML5-Cross-Browser-Polyfills">number of polyfills</a> that allow use of the constraint validation API in any browser.  I will discuss two of the more popular options available.</p>

<h3 id="toc-webshims">Webshims</h3>

<p><a href="http://afarkas.github.com/webshim/demos/index.html">Webshims</a> is collection of polyfills including one for HTML5 forms and the constraint validation API.</p>

<p>To show how to use Webshims let's return to our original example of a form with a single <code>required</code> text input.</p>

<pre class="prettyprint lang-html">
&lt;form&gt;
    &lt;input type="text" required value="" /&gt;
    &lt;input type="submit" value="Submit" /&gt;
&lt;/form&gt;
</pre>

<p>To make this work consistently across all browsers you need to include Webshims and its dependencies then call <code>$.webshims.polyfill('forms')</code>.

<pre class="prettyprint lang-html">
&lt;!-- Webshims' dependencies --&gt;
&lt;script src="js/jquery-1.8.2.js"&gt;&lt;/script&gt;
&lt;script src="js/modernizr-yepnope-custom.js"&gt;&lt;/script&gt;

&lt;!-- Webshims base --&gt;
&lt;script src="js-webshim/minified/polyfiller.js"&gt;&lt;/script&gt;

&lt;script&gt;jQuery.webshims.polyfill('forms');&lt;/script&gt;

&lt;form&gt;
    &lt;input type="text" required value="" /&gt;
    &lt;input type="submit" value="Submit" /&gt;
&lt;/form&gt;
</pre>

<a href="http://jsfiddle.net/tj_vantoll/YsBNt/">Try It</a>

<p>In supporting browsers there will be no difference in the result.  However, browsers that don't support constraint validation natively will now prevent invalid form submissions and display an error message in a custom bubble.  For example here's what the user will see in Safari and IE8.

<ul class="browser-screenshot-list">
	<li>
		Safari 6
		<img src="/static/images/tutorials/constraintvalidation/Webshims-Safari.png" alt="Display of an invalid form submission in Safari using Webshims" />
	</li>
	<li>
		Internet Explorer 8
		<img src="/static/images/tutorials/constraintvalidation/Webshims-IE8.png" alt="Display of an invalid form submission in IE8 using Webshims" />
	</li>
</ul>

<p>In addition to polyfilling, Webshims also provides solutions for many of the limitations of constraint validation discussed earlier.</p>

<ul>
	<li>Declaratively specify error messages through a <code>data-errormessage</code> attribute.</li>
	<li>Provides classes <code>form-ui-valid</code> and <code>form-ui-invalid</code> which work similarly to <code>:-moz-ui-valid</code> and <code>:-moz-ui-invalid</code>.</li>
	<li>Provides custom events <code>firstinvalid</code>, <code>lastinvalid</code>, <code>changedvalid</code>, and <code>changedinvalid</code>.</li>
	<li>Includes workarounds for WebKit false positives on form submission.</li>
</ul>

<p>For more information on what Webshims provides refer to its <a href="http://afarkas.github.com/webshim/demos/demos/webforms.html">HTML5 forms docs</a>.</p>

<h3 id="toc-h5f">H5F</h3>

<p>H5F is a lightweight, dependency free polyfill that implements the full constraint validation API as well as a number of the new attributes.</p>

<p>To see how to use H5F let's add it to our basic example of a form with a single <code>required</code> text input.</p>

<pre class="prettyprint lang-html">
&lt;script src="H5F.js"&gt;&lt;/script&gt;

&lt;form&gt;
    &lt;input type="text" required value="" /&gt;
    &lt;input type="submit" value="Submit" /&gt;
&lt;/form&gt;
&lt;script&gt;
    H5F.setup(document.getElementsByTagName('form'));
&lt;/script&gt;
</pre>

<a href="http://jsfiddle.net/tj_vantoll/63YAy/">Try It</a>

<p>H5F will prevent the submission of the form in all browsers, but the user will only see an inline validation bubble in browsers that support it natively.  Since H5F polyfills the full constraint validation API you can use it to implement your own UI to do whatever you'd like.</p>

<p>If you're looking for some examples of how to leverage the API, <a href="http://www.alistapart.com/d/forward-thinking-form-validation/enhanced_2.html">H5F's demo page</a> has an implementation that shows the messages in a bubble on the right hand side of the inputs.  I also have an example that shows how you can <a href="http://tjvantoll.com/2012/08/05/html5-form-validation-showing-all-error-messages/">show all error messages in a list</a> at the top of forms.</p>

<p>In addition to polyfilling the constraint validation API, H5F also provides classes to mimic <code>:-moz-ui-valid</code> and <code>:-moz-ui-invalid</code>.  By default these classes are <code>valid</code> and <code>error</code> although they can be customized by passing in a second parameter to <code>H5F.setup</code>.</p>

<pre class="prettyprint lang-js">
H5F.setup(document.getElementById('foo'), {
    validClass: 'valid',
    invalidClass: 'invalid'
});
</pre>

<p>For more information on H5F <a href="https://github.com/ryanseddon/H5F">check it out on Github</a>.</p>

<h2 id="toc-conclusion">Conclusion</h2>

<p>HTML5's constraint validation APIs make adding client side validation to forms quick while providing a JavaScript API and CSS hooks for customization.</p>

<p>While there are still some issues with the implementations and old browsers to deal with, with a good polyfill or server-side fallback you can utilize these APIs in your forms today.</p>

{% endblock %}
