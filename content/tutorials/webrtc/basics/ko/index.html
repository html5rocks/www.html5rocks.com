{% extends "tutorial.html" %}

{% block pagebreadcrumb %}{{ tut.title }}{% endblock %}

{% block html5badge %}
<img src="/static/images/identity/html5-badge-h-multimedia.png" width="133" height="64" alt="This article is powered by HTML5 Audio/Video" title="This article is powered by HTML5 Audio?/Video" />
{% endblock %}

{% block iscompatible %}
return !! (window.RTCPeerConnection || window.webkitDeprecatedPeerConnection || window.webkitRTCPeerConnection);
{% endblock %}

{% block translator %}
<div class="translator">
    <strong>Translator:</strong> <a href="https://plus.google.com/+nurinamu">Wonjae Lee</a>
</div>
{% endblock %}

{% block head %}
<style>
    .talkinghead:before {
        background-image: url(/static/images/profiles/75/dutton.75.png);
    }
</style>
{% endblock %}

{% block onload %}
// TODO
{% endblock %}

{% block content %}

<h2 id="toc-disruptive">플러그인 없는 실시간 통신</h2>

<blockquote><strong>WebRTC는 오픈 웹을 위한 기나긴 전쟁에 새로운 선두입니다.</strong><br />
&mdash; <a href="http://hacks.mozilla.org/2012/03/video-mobile-and-the-open-web/" title="Brendan Eich blog post: Video, Mobile, and the Open Web">Brendan Eich</a>, 자바스크립트 창시자
</blockquote>

<p>전화기, TV, 컴퓨터가 공통 플랫폼위에서 모두 대화할 수 있는 세상을 상상해보십시요. 여러분의 웹어플리케이션에 비디오채팅 기능과 P2P 데이터 공유 기능을 쉽게 추가했다고 상상해보십시요. 이것이 WebRTC의 비전입니다.</p>

<p>확인해보고 싶으십니까? WebRTC는 현재 구글 Chrome과 Opera, Firefox에서 가능합니다. <a href="http://apprtc.appspot.com" title="Simple WebRTC demo" target="_blank">apprtc.appspot.com</a>은 간단한 비디오 채팅 어플리케이션을 시작해볼수 있는 좋은 곳입니다:</p>

<ol>
	<li><a href="http://apprtc.appspot.com" title="Simple WebRTC demo" target="_blank">apprtc.appspot.com</a> 페이지를 Chrome이나 Opera, Firefox에서 엽니다.</li>
	<li>페이지(웹어플리케이션)에서 Webcam을 사용하도록 허용버튼을 클릭합니다.</li>
	<li>다른 탭 또는 더 좋은 방법으로 다른 컴퓨터에서 페이지 하단에 표시된 URL을 브라우저에서 엽니다.</li>
</ol>

 <p>이 어플리케이션에 대한 설명은 <a href="#toc-simple" title="Code walkthrough of apprtc.appspot.com">본문 아래</a>에서 다룹니다.</p>

<h2 id="toc-tldr">Quick start</h2>

<p>본문을 읽기에 시간이 없거나 바로 코드만 보고 싶으십니까?</p>

<ol>
  <li>
    <p>Google I/O에서 발표되었던 WebRTC에 대한 소개를 시청하시기 바랍니다. (슬라이드 자료는 <a href="http://io13webrtc.appspot.com" title="Google I/O 2013 WebRTC presentation">여기</a>):</p>
    <iframe width="560" height="315" src="https://www.youtube.com/embed/p2HzZkd2A40" frameborder="0" allowfullscreen></iframe>
  </li>
  <li>getUserMedia를 이전에 사용해보지 않았다면, <a href="http://www.html5rocks.com/ko/tutorials/getusermedia/intro/" title="HMTL5 Rocks: Capturing Audio and Video in HTML5" target="_blank">HTML5 Rocks 기사</a>를 읽어 보시기 바랍니다. 그리고 <a href="http://www.simpl.info/getusermedia" title="Simple getUserMedia example">simpl.info/gum</a>에서 간단한 예제 코드를 확인할 수 있습니다.</li>
  <li><a href="#simpleRTCPeerConnectionExample" title="Internal link to simple RTCPeerConnecton example">뒤에 나오는 간단한 예제</a>와 WebRTC를 single page로 구현한 <a href="http://www.simpl.info/pc" title="WebRTC demo without signaling">데모</a>를 통해서 RTCPeerConnection API를 파악하시기 바랍니다.</li>
	<li><a href="http://apprtc.appspot.com" title="Simple WebRTC video chat demo">apprtc.appspot.com</a>에서 코드와 콘솔로그를 통해 WebRTC가 시그널링, 방화벽, NAT traversal을 위해 서버를 어떻게 사용하는지 더 깊이 공부해보시기 바랍니다.</li>
</ol>

<p style="font-weight: bold">아니면 저희의 <a href="https://www.bitbucket.org/webrtc/codelab" title="WebRTC codelab repository on Bitbucket">WebRTC codelab</a>으로 바로 들어오시기 바랍니다: 간단한 시그널링 서버를 포함한 비디오 채팅앱을 만드는 법을 step-by-step으로 설명한 가이드입니다.</p>

<h2 id="toc-history">WebRTC의 아주 짧은 역사</h2>

<p>웹에서 남은 주요 도전 과제 중에 남은 하나는 영상과 음성을 통한 인간의 의사소통 - 실시간 대화(Real Time Communication, RTC) 가능하게 하는 것 입니다. 실시간 대화는 문자 입력란에 문자를 입력하는 것처럼 웹 어플리케이션에서 자연스러워야 하는 것입니다. 그렇지 않다면 사람들과 소통하는 새로운 방식들을 혁신하고 개발하는 능력을 우리는 한정 지어버리게 됩니다.</p>

<p>역사적으로 실시간 대화는 집에서 사용하기에 어려웠고, 비싼 음성/영상 기술들이 필요했습니다. 이미 존재하는 콘텐츠와 데이터 서비스들과 함께 실시간 대화 기술을 융합하는 것은 매우 어렵고 시간이 많이 드는 일이었습니다. 특히 웹에서.</p>

<p>Gmail의 영상채팅은 2008년에 출시되었고, 2011년에는 Google Talk 서비스를 (Gamil에서 처럼)사용한 행아웃이 소개되었습니다. 구글은 코덱, Echo cancellation 등의 실시간 통신에 필요한 많은 기술을 개발한 회사인 GIPS를 삽니다. 구글은 GIPS에서 개발한 기술들을 오픈 소스화하면서 업계의 합의를 얻기위한 IETF와 W3C에서 해당 기술과 관련된 표준들의 중심으 뛰어듭니다. 2011년 5월, Ericsson이 <a href="https://labs.ericsson.com/developer-community/blog/beyond-html5-peer-peer-conversational-video" title="Beyond HTML5: peer to peer conversational video">첫번째 WebRTC 데모</a>를 개발합니다.</p>

<p>WebRTC는 현재 실시간, 플러그인 필요없는 영상과 음성, data 통신에 대한 공개 표준들을 구현했습니다. 현실의 요구들입니다:</p>

  <ul>
    <li>많은 웹서비스들은 이미 실시간 통신을 사용하고 있습니다. 하지만 네이티브 앱이나 플러그인들의 다운로드가 필요합니다. Skype, (Skype를 사용하는)Facebook (Google Talk 플러그인을 사용하는)Google Hangouts등이 그렇습니다.</li>
    <li>다운로딩, 설치 그리고 플러그인들을 업데이트 하는 것들은 복잡할 수 있고 애러를 발생시키며 귀찮은 일입니다.</li>
    <li>플러그인들을 배포하고, 디버깅하고 문제잡고 테스트하고 유지하는 것은 힘든 일입니다. 그리고 아마도 복잡하고 비싼 기술들에 대한 라이센스나 구현이 필요할 수 도 있습니다. 사용자들에게 플러그인 첫 설치를 독려하는 것은 정말 어려운 일입니다!</li>
  </ul>

<p>WebRTC 프로젝트의 API들은 오픈소스이고, 무료이고, 표준화되어야하고 웹브라우저 안에서 만들어져야고, 이전의 기술들보다 효율적이어야한다는 것이 WebRTC 프로젝트의 안내 지침 입니다.</p>

<h2 id="toc-where">현재 어디까지?</h2>

<p>WebRTC에는 세가지 API가 구현되어 있습니다:</p>
<ul>
  <li><a href="#toc-mediastream" title="Internal link to section for MediaStream (aka getUserMedia)"><code>MediaStream</code></a> (aka <code>getUserMedia</code>)</li>
  <li><code><a href="#toc-rtcpeerconnection" title="Internal link to section for RTCPeerConnection">RTCPeerConnection</a></code></li>
  <li><a href="#toc-rtcdatachannel" title="Internal link to section about RTCDataChannel"><code>RTCDataChannel</code></a></li>
</ul>

<p><code><strong>getUserMedia</strong></code>는 Chrome, Opera 그리고 Firefox에서 가능합니다. 크로스 브라우저간의 데모 - <a href="http://www.simpl.info/gum" title="Simple cross-platform getUserMedia demo">simpl.info/gum</a> 와 Web Audio의 입력으로 <code>getUserMedia</code> 사용한 Chris Wilson의 <a href="http://webaudiodemos.appspot.com/" title="">환상적인 예제</a>를 둘러보시기 바랍니다.</p>

<p><code><strong>RTCPeerConnection</strong></code>은 Chrome(데스크탑과 Android), Opera(데스크탑과 최신 안드로이드 beta)와 Firefox에서 구현되어있습니다. 이름으로 쓰이는 임시 단어가 여러번 반복된 이후에 현재 크롬에서는 <code>RTCPeerConnection</code>을 <code>webkitRTCPeerConnection</code>으로 구현되었고,  Firefox에서는 <code>mozRTCPeerConnection</code>로 구현되었습니다. 다른 이름들과 구현들은 더 이상 사용되지 않게 되었습니다. 표준화 과정이 안정화될 때, 머릿말들은 모두 삭제될 것입니다. 여기 아주 간단한 크롬의 RTCPeerConnection 데모 <a href="http://www.simpl.info/peerconnection" title="Simple cross-platform getUserMedia demo">simpl.info/pc</a>와 아주 훌륭한 비디오챗 프로그램 <a href="http://apprtc.appspot.com" title="Video chat demo">apprtc.appspot.com</a>이 있습니다. 브라우저간의 차이와 명세 변경에 대한 것을 추상화하는 <a href="https://apprtc.appspot.com/js/adapter.js" title="adapter.js JavaScript file">adapter.js</a> - 구글에서 관리하는 Javascript 코드를 이 프로그램에서 사용하고 있습니다.</p>

<p><strong><code>RTCDataChannel</code></strong> 은 Chrome 25버전, Opera 18버전, Firefox 22버전 이상에서 지원하고 있습니다.</p>

<p>인터넷 익스플로러에서는 <a href="https://groups.google.com/forum/#!topic/discuss-webrtc/tKoh1wrI8ig" title="How to enable WebRTC functionality in Internet Explorer via Chrome Frame">Chrome Frame을 통해</a> WebRTC기능이 사용 가능하고, (2011년에 Microsoft에 흡수된) Skype에서는 <a href="http://gigaom.com/2012/06/26/skype-webrtc-web-client/" title="GigaOM blog post about Skype and WebRTC">WebRTC를 사용려고 계획 중입니다.</a> WebRTC는 또한 <a href="https://labs.ericsson.com/developer-community/blog/beyond-html5-conversational-voice-and-video-implemented-webkit-gtk" title="Ericsson article about WebKitGTK+">WebKitGTK+</a> 와 <a href="http://www.youtube.com/watch?v=Vm5ebKWKNE8" title="basysKom showcasing WebRTC based video chat in QML application">Qt</a> 네이티브 앱에 통합되었습니다.</p>

<h3>주의할 것</h3>

<p>'WebRTC를 지원하는' 플랫폼의 이야기들은 의심을 해봐야합니다. 대부분의 플랫폼들은 RTC 컴포넌트들은 전혀 지원하지 않고 단지 <code>getUserMedia</code>만 지원한다는 뜻 입니다.</p>

<h2 id="toc-first">My first WebRTC</h2>

<p>WebRTC 어플리케이션에는 반드시 해야하는 몇 가지 것들이 있습니다:</p>

<ul>
  <li>스트리밍 오디오, 비디오 또는 데이터를 가져와야 합니다.</li>
  <li>IP주소, 포트등의 네트워크 정보를 가져와야하고, (<em>peers</em>로 알려진) 다른 WebRTC 클라이언트들과 연결을 위해 이 정보들을 교환해야 합니다. 심지어 <a href="http://en.wikipedia.org/wiki/NAT_traversal" title="Wikipedia article: Network Address Translation traversal">NATs</a>와 방화벽을 통해서도 교환해야 합니다.</li>
  <li>애러들의 보고, 세션들의 초기화와 종료를 위한 신호 통신을 관리해야 합니다.</li>
  <li>해상도와 코덱들 같은 미디어와 클라이언트의 capabilty에 대한 정보를 교환해야 합니다.</li>
	<li>스트리밍 오디오, 비디오 또는 데이터를 주고 받아야합니다.</li>
</ul>

<p>스트리밍 데이터를 얻고 통신하기위애 WebRTC에서는 다음과 같은 API들을 제공합니다:</p>
<ul>
	<li><a href="https://dvcs.w3.org/hg/audio/raw-file/tip/streams/StreamProcessing.html" title="MediaStream API documentation">MediaStream</a>: 사용자의 카메라와 마이크 같은 곳의 데이터 스트림에 접근합니다.</li>
	<li><a href="http://dev.w3.org/2011/webrtc/editor/webrtc.html#rtcpeerconnection-interface" title="W3CRTCPeerConnection Editor's draft">RTCPeerConnection</a>: 암호화 및 대역폭 관리를 하는 기능을 가지고 있고, 오디오 또는 비디오 연결을 합니다.</li>
	<li><a href="http://dev.w3.org/2011/webrtc/editor/webrtc.html#rtcdatachannel" title="W3C WebRTC RTCDataChannel Editor's draft">RTCDataChannel</a>: 일반적인 데이터 P2P통신</li>
</ul>

<p>(<a href="#signaling" title="Internal link to section about signaling">뒤에서</a> WebRTC의 네트워크와 신호에 관해 자세하게 다룹니다.)</p>

<h2 id="toc-mediastream">MediaStream (aka getUserMedia)</h2>

<p><a href="http://dev.w3.org/2011/webrtc/editor/getusermedia.html" title="W3C Editor's Draft: Media Capture and Streams">MediaStream API</a>는 미디어의 동기화된 스트림들을 말합니다. 예를 들어, 카메라와 마이크의 입력에서 받아온 스트림은 오디오와 비디오 트랙들로 동기화 됩니다. (MediaStream의 트랙을 <a href="http://www.html5rocks.com/ko/tutorials/track/basics/" title="HTML5 Rocks: Getting Started With the Track Element">완전히 다른의미의</a> &lt;track&gt; 요소와 헷갈리면 안됩니다.)</p>

<p>아마도 MediaStream을 이해하는 가장 쉬운 방법은 실제로 눈으로 보는 것일 겁니다:</p>

<ol>
  <li>Chrome 또는 Opera로 데모페이지 <a href="http://simpl.info/getusermedia/" title="simpl.info getUserMedia demo">simpl.info/gum</a>를 엽니다.</li>
  <li>콘솔을 엽니다.</li>
  <li>글로벌 스코프에 위치한 <code>스트림</code> 변수를 검사합니다.</li>
</ol>

<p>각 MediaStream은 <code>navigator.getUserMedia()</code>에서 생성된 입력과, &lt;video&gt; 태그 또는 RTCPeerConnection로 넘겨주는 출력을 가지고 있습니다.</p>

<p><code>getUserMedia()</code> 함수는 3개의 매개 변수를 받습니다:</p>

<ul>
  <li><a href="#toc-constraints" title="미디어 제약에 관한 세션으로의 내부 링크">제약 오브젝트</a>.</li>
  <li>성공시, MediaStream을 넘겨 받는 콜백.</li>
  <li>실패시, 애러 오브젝트를 넘겨 받는 콜백.</li>
</ul>

<p> 각 MediaStream은 'Xk7EuLhsuHKbnjLWkW4yYGNJJ8ONsgwHBvLQ'과 같은 <code>라벨</code>을 가집니다. <code>getAudioTracks()</code> 과 <code>getVideoTracks()</code>함수는 MediaStreamTracks의 배열을 반환합니다.</p>

<p><a href="http://simpl.info/getusermedia/" title="simpl.info getUserMedia demo">simpl.info/gum</a> 예제에서, (오디오가 없기때문에) <code>stream.getAudioTracks()</code>은 빈 배열을 반한다. 그리고 웹캠이 연결되어있다고 가정하면, <code>stream.getVideoTracks()</code>은 웹캠 스트림을 나타내는 MediaStreamTrack 하나의 배열을 반환합니다. 각 MediaStreamTrack은 (비디오 또는 오디오) 종류와 ('FaceTime HD Camera (Built-in)'과 같은) 라벨을 가지고, 오디오 또는 비디오의 하나 이상의 채널을 나타냅니다. 이런 경우는, 비디오 트랙 하나가 있고 오디오가 없는 경우이지만, 여러 사용처를 쉽게 상상할 수 있습니다: 예를 들어, 전면/후면 카메라, 마이크와 화면 공유 프로그램으로 부터 스트림들을 얻는 채팅 프로그램.</p>

<p>Chrome 또는 Opera에서는 <code>URL.createObjectURL()</code> 함수가 MediaStream을 video 요소의 src에 설정 가능한 <a href="http://www.html5rocks.com/tutorials/workers/basics/#toc-inlineworkers-bloburis" title="HTML5 Rocks: Blob URLs">Blob URL</a>로 변경합니다. (Firefox와 Opera에서는, video의 <code>src</code>에 스트림 자체를 설정할 수 있습니다. ) 25버전 이후부터, Chrome은 <code>getUserMedia</code>에서 얻은 오디오 데이터를 audio 또는 video 태그에 넘겨줄 수 있습니다.(그러나 이경우에는 기본적으로 미디어 요소는 묵음 상태임을 알아야 합니다.)<p>

<p><code>getUserMedia</code> 또한 <a href="http://updates.html5rocks.com/2012/09/Live-Web-Audio-Input-Enabled" title="HTML5 Rocks update from Chris Wilson: live Web Audio input enabled!">Web Audio API의 입력노드로</a> 사용될 수 있습니다:</p>

<pre class="prettyprint">
function gotStream(stream) {
    window.AudioContext = window.AudioContext || window.webkitAudioContext;
    var audioContext = new AudioContext();

    // Create an AudioNode from the stream
    var mediaStreamSource = audioContext.createMediaStreamSource(stream);

    // Connect it to destination to hear yourself
    // or any other node for processing!
    mediaStreamSource.connect(audioContext.destination);
}

navigator.getUserMedia({audio:true}, gotStream);
</pre>

<p>크로미엄 기반의 앱과 확장 프로그램에도 <code>getUserMedia</code>가 포함되어있습니다. <code>audioCapture</code> 와 <code>videoCapture</code> <a href="https://developer.chrome.com/extensions/manifest.html#permissions" title="Chrome app/extension permissions documentation">권한들</a>을 manifest에 추가하면 설치시 단한번의 요청을 수락하는 것으로 권한을 활성화 시킵니다. 그 이후에는 카메라와 마이크의 접속 권한에 대하여 묻지않습니다.</p>

<p>비슷하게, 페이지에서 HTTPS를 사용하는 경우: (적어도 Chrome에서는) <code>getUserMedia()</code>에 대한 권한을 한번만 혀용하면 됩니다. 처음에는 브라우저의 <a href="http://dev.chromium.org/user-experience/infobars" title="Chromium information about the browser infobar">상태바</a>에 '항상 허용' 버튼이 표시됩니다.</p>

<p>결국 의도는 카메라와 마이크 뿐만 아니라 모든 스트리밍 데이터 소스에 대한 MediaStream을 활성화하는 것입니다. 이것은 디스크로부터 스트리밍을 활성화하거나, 센서들 또는 다름 입력기기와 같은 임의의 데이터 소스들로부터 스트리밍을 활성화하는 것입니다.</p>

<p><code>getUserMedia()</code>는 반드시 로컬 파일 시스템이 아닌 서버에서 사용되어야하며, 이외의 경우에는 <code>PERMISSION_DENIED: 1</code> 에러가 발생한다는 점을 숙지해야합니다.  </p>

<p><code>getUserMedia()</code>은 다른 Javascript API, 라이브러리들과 함께 우리앞에 바짝 다가와 있습니다:</p>

<ul>
   <li><a href="http://webcamtoy.com/app/" title="Webcam Toy site">Webcam Toy</a> 은 WebGL을 사용한 포토부스 앱으로, 특이하고 아름다운 효과들이 적용된 사진을 공유하거나 로컬에 저장할 수 있습니다.</li>
   <li><a href="http://www.shinydemos.com/facekat/" title="FaceKat game">FaceKat</a> 은 <a href="headtrackr library for realtime face and head tracking" title="headtrackr.js ">headtrackr.js</a>를 사용하여 '얼굴 추적'게임을 만들었습니다.</li>
   <li><a href="http://idevelop.ro/ascii-camera/" title="'ASCII camera' demo">ASCII Camera</a> 는 Canvas API 를 사용하여 ASCII 이미지를 생성합니다.</li>
</ul>

<figure>
  <a href="http://idevelop.ro/ascii-camera/" title="ASCII Camera app"><img src="ascii.png" alt="ASCII image generated by idevelop.ro/ascii-camera" /></a>
  <figcaption>gUM ASCII art!</figcaption>
</figure>

<h3 id="toc-constraints">Constraints</h3>

<p><a href="http://tools.ietf.org/html/draft-alvestrand-constraints-resolution-00#page-4" title="IETF Resolution Constraints draft specification">Constraints</a> Chrome 24버전, Opera 18버전 이후 부터 구현이 되어있습니다. 이것은 <code>getUserMedia()</code> 와 RTCPeerConnection <code>addStream()</code> 호출의 video 해상도를 위한 값들을 설정하기 위해 사용할 수 있습니다. 목표는 <a href="http://dev.w3.org/2011/webrtc/editor/getusermedia.html#methods-1" title="applyConstraints() API proposal in W3C getUserMedia Editor's Draft"><code>applyConstraints()</code> 함수</a>와 함께 화면비율, 화면모드(앞 또는 뒤 카메라), 프레임 속도, 높이와 너비와 같은 <a href="http://dev.w3.org/2011/webrtc/editor/getusermedia.html#the-model-sources-sinks-constraints-and-states" title="W3C getUserMedia Editor's Draft - The model: sources, sinks, constraints, and states">다른 constraints를 지원</a>하도록 구현하는 것입니다. </p>

<p><a href="http://simpl.info/getusermedia/constraints/index.html" title="Resolution Constraints example on simpl.info">simpl.info/getusermedia/constraints</a>에 예제가 있습니다.</p>

<p>One gotcha: <code>getUserMedia</code> 의 constraints를 한 탭에서 설정을 하면 이후 열리는 탭들에도 적용이됩니다. 값을 '거부'로 설정하게되면 애러 메세지를 얻게됩니다:</p>

<pre class="prettyprint">navigator.getUserMedia error:
NavigatorUserMediaError {code: 1, PERMISSION_DENIED: 1}</pre>

<h4>Screen and tab capture</h4>

<p>화면 캡쳐 역시 MediaStream처럼 사용할 수 있습니다. 이 기능은 현재 <a href="https://html5-demos.appspot.com/static/getusermedia/screenshare.html" title="Screenshare demo">이 데모</a> 처럼 experimental chromeMediaSource constraint가 설정된 크롬에서만 동작하고 있습니다. 이 기능은 Opera에서는 아직 지원하지 않습니다. 그리고 화면 캡쳐기능은 HTTPS상에서만 동작합니다.</p>

<p>크롬앱에서 또한 experimental <a href="http://developer.chrome.com/dev/extensions/tabCapture.html" title="chrome.tabCapture API documentation">chrome.tabCapture</a> API를 통해서 단일 탭의 화면을 라이브 '비디오'로 공유가 가능합니다. 화면 공유에 관한 코드와 더 많은 정보를 확인하려면 HTML5Rocks의 <a href="http://updates.html5rocks.com/2012/12/Screensharing-with-WebRTC" title="HTML5 Rocks update article: Screensharing with WebRTC">Screensharing with WebRTC</a>을 참고하시기 바랍니다. 이기능은 Opera에서는 아직 지원되지 않습니다.</p>

<h2 id="toc-signaling">Signaling: session control, network and media information</h2>

<p>WebRTC (피어들로 불리우는) 브라우저들 사이에 스트리밍 데이터를 주고 받는 RTCPeerConnection를 사용합니다, 그리고 또한 통신을 조율하고 조장할 메세지를 주고 받기 위해 Signaling으로 알려진 일련의 과정이 필요합니다. Signaling을 위한 방법들과 프로토콜들은 WebRTC에는 명세되어있지 <em>않습니다</em> : Signaling은 RTCPeerConnection API에 포함되지 않습니다.</p>

<p>대신, WebRTC 개발자들은 SIP,XMPP 도는 적절한 쌍방통신 채널 등 자신들에게 편한 방식을 선택할 수 있습니다.  <a href="http://apprtc.appspot.com" title="apprtc WebRTC example">apprtc.appspot.com</a> 예제는 Signaling 방식으로 XHR과 Channel API를 사용하였습니다. <a href="http://www.bitbucket.org/webrtc/codelab" title="WebRTC codelab">codelab</a>은 <a href="http://nodejs.org/" title="Node website">Node server</a>위에 <a href="http://Socket.io" title="Socket.io website">Socket.io</a>를 이용해서 만들여졌습니다.</p>

<p>Signaling은 3가지 종류의 정보를 교환합니다.</p>
<ul>
  <li>Session control messages: 통신의 초기화, 종료 그리고 애러 리포트를 위해.</li>
  <li>Network configuration: 외부 세상으로 내 컴퓨터의 IP 주소와 Port는 어떻게되지 ?</li>
  <li>Media capabilities: 내 브라우저와 상대브라우저가 사용 가능한 코덱들과 해상도들은 어떻게 되지?</li>
</ul>

<p>Signaling을 통한 정보 교환은 p2p streaming이 시작되기 전에 반드시 성공적으로 완료되어야 합니다. </p>

<p>예를들어 Alice가 Bob과 통신하기를 원한다고 상상해봅시다. Signaling 과정을 보여주는 <a href="http://www.w3.org/TR/webrtc/#simple-example" title="WebRTC 1.0: Real-time Communication Between Browsers"> WebRTC W3C Working Draft</a>에 따라 예제 코드는 아래와 같습니다. 이 코드는 이미 특정 Signaling 방식이 존재한다고 가정하에 <code>createSignalingChannel()</code> 함수를 만들었습니다. 또한 Chrome과 Opera에서는 RTCPeerConnection가 prefix를 가지고 있다는 점을 유의해야합니다.</p>

<a id="simpleRTCPeerConnectionExample"></a>

<pre class="prettyprint">var signalingChannel = createSignalingChannel();
var pc;
var configuration = ...;

// run start(true) to initiate a call
function start(isCaller) {
    pc = new RTCPeerConnection(configuration);

    // send any ice candidates to the other peer
    pc.onicecandidate = function (evt) {
        signalingChannel.send(JSON.stringify({ "candidate": evt.candidate }));
    };

    // once remote stream arrives, show it in the remote video element
    pc.onaddstream = function (evt) {
        remoteView.src = URL.createObjectURL(evt.stream);
    };

    // get the local stream, show it in the local video element and send it
    navigator.getUserMedia({ "audio": true, "video": true }, function (stream) {
        selfView.src = URL.createObjectURL(stream);
        pc.addStream(stream);

        if (isCaller)
            pc.createOffer(gotDescription);
        else
            pc.createAnswer(pc.remoteDescription, gotDescription);

        function gotDescription(desc) {
            pc.setLocalDescription(desc);
            signalingChannel.send(JSON.stringify({ "sdp": desc }));
        }
    });
}

signalingChannel.onmessage = function (evt) {
    if (!pc)
        start(false);

    var signal = JSON.parse(evt.data);
    if (signal.sdp)
        pc.setRemoteDescription(new RTCSessionDescription(signal.sdp));
    else
        pc.addIceCandidate(new RTCIceCandidate(signal.candidate));
};
</pre>

<p>우선 Alice와 Bob은 네트워크 정보를 교환합니다. ('finding candidates'란 표현은 <a href="#ice" title="Internal link to more information about the ICE framework">ICE framework</a>을 사용해 네트워크 인터페이스와 포트를 찾는 과정을 뜻합니다.)</p>

<ol>
  <li>Alice가 <code>onicecandidate</code> 핸들러를 가진 RTCPeerConnection object 를 생성합니다.</li>
  <li>핸들러는 네트워크 candidates가 가능해지면 실행됩니다.</li>
  <li>Alice는 serialized된 candidate data를 WebSocket 또는 어떤 특정 방식등 그 들만의 Signaling 채널을 통해 Bob에게 전송합니다.</li>
  <li>Bob이 Alice로부터 candidate 메세지를 받으면 Bob은 상대방 peer description을 위한 candidate를 추가하기위해 <code>addIceCandidate</code>를 호출합니다.</li>
</ol>

<p>(Alice와 Bob 같은 <strong>피어들</strong>로 불리우는) WebRTC 클라이언트들은 해상도와 코덱 기능 같은 미디어 정보들을 서로 교환하고 확인해야합니다. 미디어 정보의 교환을 위한 Signaling은 Session Description Protocol (SDP)를 사용하는 <em>offer</em>와 <em>answer</em>를 통해서 진행됩니다:</p>

<ol>
  <li>Alice가 RTCPeerConnection의 <code>createOffer()</code> 함수를 호출합니다. 이 함수의 argument로 입력된 callback을 통해 Alice의 Session description 정보를 나타내는 RTCSessionDescription을 얻습니다.</li>
  <li>callback 안에서 Alice는 자신의 description을 <code>setLocalDescription()</code> 함수로 설정하고 이 session description을 signaling 채널을 통해 Bob에게 전달합니다. <code>setLocalDescription()</code>가 호출되기 전까지는 candidates 수집이 시작되지 않는 다는 점을 주의해야 합니다: 이것은 <a href="http://tools.ietf.org/html/draft-ietf-rtcweb-jsep-03#section-4.2.4" title="Javascript Session Establishment Protocol draft-ietf-rtcweb-jsep-03">JSEP IETF draft</a>에 문서화 되어있습니다.</li>
  <li>Bob은 Alice가 보낸 session description 정보를 <code>setRemoteDescription()</code> 함수를 통해 설정합니다.</li>
  <li>Bob은 RTCPeerConnection의 <code>createAnswer()</code> 함수에 Alice로 부터 받은 remote description을 전달하고 실행합니다. 그러면 그녀의 정보를 기반으로 Local Session이 생성됩니다. <code>createAnswer()</code>의 callback은 RTCSessionDescription을 전달해줍니다: Bob은 이것을 local description으로 설정하고 Alice에게 전달합니다.</li>
  <li>Alice가 Bob의 Session description을 받으면 <code>setRemoteDescription</code>을 이용해 remote descirption으로 설정합니다.</li>
  <li>Ping!</li>
</ol>

<p>RTCSessionDescription 객채들은 <a href="http://en.wikipedia.org/wiki/Session_Description_Protocol" title="Wikipedia article about the Session Description Protocol">Session Description Protocol</a>, SDP를 따르는 blob입니다. 직렬화된 SDP 객체는 다음과 같이 보입니다:</p>

<pre class="prettyprint">
v=0
o=- 3883943731 1 IN IP4 127.0.0.1
s=
t=0 0
a=group:BUNDLE audio video
m=audio 1 RTP/SAVPF 103 104 0 8 106 105 13 126

// ...

a=ssrc:2223794119 label:H4fjnMzxy3dPIgQ7HxuCTLb4wLLLeRHnFxh810
</pre>

<p>네트워크와 미디어 정보의 교환과 획득은 동시에 완료됩니다, 그러나 이 두가지 과정들은 피어간의 오디오/비디오 스트리밍 시작전에 반드시 완료 되어야합니다.</p>

<p>위에서 설명된 offer/answer 아키텍쳐는 <a href="http://tools.ietf.org/html/draft-ietf-rtcweb-jsep-00" title="IETF JSEP draft proposal">JSEP</a>, JavaScript Session Establishment Protocol 이라고 불리웁니다. (<a href="https://labs.ericsson.com/developer-community/blog/beyond-html5-peer-peer-conversational-video" title="Ericsson conversational video demo">Ericsson's demo video</a>은 Ericsson에서 첫번째 WebRTC 구현할 당시 signaling과 streaming 과정을 아주 훌륭하게 설명한 애니메이션 입니다.) </p>

<figure>
  <img src="jsep.png" alt="JSEP architecture diagram" />
  <figcaption>JSEP architecture</figcaption>
</figure>

<p>일단 signaling 과정이 성공적으로 마치면 data는 peer와 peer 끼리 또는 송신자와 수신자가 직접 주고 받게됩니다.&mdash;만약 이것이 실패하게되면, 중계서버를 통하게 됩니다.(뒤에 자세하게 다루겠습니다.) 스트리밍이 RTCPeerConnection의 역할입니다.</p>

<h2 id="toc-rtcpeerconnection">RTCPeerConnection</h2>

<p>RTCPeerConnection은 Peer들 간의 데이터를 안정적이고 효율적으로 통신하게 처리하는 WebRTC 컴포넌트입니다.</p>

<p>아래는 RTCPeerConnection의 역할을 보여주는 WebRTC 아키텍쳐 다이어그램입니다. 보시는 것처럼 녹색 부분들은 복잡합니다! </p>

<figure>
<a href="http://www.webrtc.org/reference/architecture" title="webrtc.org: architecture diagram"><img src="webrtcArchitecture.png" alt="WebRTC architecture diagram" style="width: 740px; height: 482px;" /></a>
<figcaption>WebRTC architecture (from <a href="http://www.webrtc.org/reference/architecture" title="webrtc.org: architecture diagram">webrtc.org</a>)</figcaption>
</figure>

<p>JavaScript 측면에서 보면, 이 다이어그램을 통해 알 수 있는 중요한 점은 RTCPeerConnection이 뒤에 숨겨진 매우 복잡한 것들을 웹개발자로부터 지켜주고 있다는 것 입니다. WebRTC에서 사용되는 코덱들과 프로토콜들은 불안정한 네트워크 위에서도 실시간 통신이 가능하게 하기위해 엄청난 양의 일들을 하고 있습니다: </p>

<ul>
	<li>packet loss concealment</li>
	<li>echo cancellation</li>
	<li>bandwidth adaptivity</li>
	<li>dynamic jitter buffering</li>
	<li>automatic gain control</li>
	<li>noise reduction and suppression</li>
	<li>image 'cleaning'.</li>
</ul>

<p><a href="#simpleRTCPeerConnectionExample" title="Internal link to W3C RTCPeerConnection example">위에 나온 W3C 코드</a>는 Signaling 측면에서 WebRTC의 간소화된 예를 보여줍니다. 다음은 현재 동작하고 있는 두가지 WebRTC 어플리케이션 입니다: 첫 번째는 단순한 RTCPeerConnection의 데모 예제이고, 두번째는 온전히 동작하는 화상채팅 클라이언트 입니다.</p>

<h3 id="toc-sans">RTCPeerConnection without servers</h3>

<p>다음의 코드는 '단일페이지' WebRTC 데모 - <a href="https://webrtc-demos.appspot.com/html/pc1.html" title="WebRTC demo without signaling">webrtc-demos.appspot.com</a>에서 발췌한 것입니다, 이것은 로컬<em>과</em> 원격지의 RTCPeerConnection (그리고 로컬과 원격지의 비디오)가 같은 웹페이지 위에 있습니다. 이 예제안에는 유용한 것들은 없습니다, 하지만 RTCPeerConnection 간의 중간 signaling 과정을 사용하지 않고 직접 페이지에서 데이터와 메세지를 주고 받기 때문에 RTCPeerConnection API의 동작을 좀 더 단순하게 보여줍니다.</p>

<p>One gotcha: <code>RTCPeerConnection()</code>의 생성자에서 두번째 파라메터로 사용되는 constraints는 <code>getUserMedia()</code>에서 사용되는 것과는 차이가 있습니다: <a href=" http://www.w3.org/TR/webrtc/#constraints" title="W3C Working Draft Constraints section">w3.org/TR/webrtc/#constraints</a>에서 더 많은 정보를 확인바랍니다.</p>

<p>이 예제에서, <code>pc1</code>은 local 피어(Caller)를 나타내고, <code>pc2</code>는 원격지 peer(Callee)를 나타냅니다.</p>

<h3>Caller</h3>

<ol>

<li>
<p>RTCPeerConnection을 새로 생성하고 <code>getUserMedia()</code>로 부터 스트림을 얻습니다:</p>
<pre class="prettyprint">
// servers is an optional config file (see TURN and STUN discussion below)
pc1 = new webkitRTCPeerConnection(servers);
// ...
pc1.addStream(localstream); </pre>
</li>

<li>
<p>offer를 생성하고 <code>pc1</code>의 description을 설정합니다. 그리고 <code>pc2</code>의 것을 remote description을 설정합니다. 여기서는 Caller와 Callee가 같은 페이지에 있기 때문에 signaling없이 직접 코드로 연결할 수 있습니다:</p>
<pre class="prettyprint">
pc1.createOffer(gotDescription1);
//...
function gotDescription1(desc){
  pc1.setLocalDescription(desc);
  trace("Offer from pc1 \n" + desc.sdp);
  pc2.setRemoteDescription(desc);
  pc2.createAnswer(gotDescription2);
}
</pre>
</li>


</ol>

<h3>Callee</h3>

<ol>

<li>
<p><code>pc2</code>를 생성하고, <code>pc1</code>에 스트림이 추가되면 그것을 video 요소에 표시합니다: </p>
<pre class="prettyprint">
pc2 = new webkitRTCPeerConnection(servers);
pc2.onaddstream = gotRemoteStream;
//...
function gotRemoteStream(e){
  vid2.src = URL.createObjectURL(e.stream);
}
</pre>
</li>

</ol>

<h3 id="toc-real">RTCPeerConnection plus servers</h3>

<p>현실 세계에서는 WebRTC는 서버가 필요하지만 단순합니다. 그래서 다음과 같은 것이 가능합니다:</p>

<ul>
	<li>사용자들은 상대방을 발견하고 이름과 같은 '현실 세계'의 상세를 교환합니다.</li>
  <li>WebRTC 클라이언트 어플리케이션들(피어들)은 네트워크 정보를 교환합니다.</li>
  <li>피어들은 비디오 포맷과 해상도 같은 미디어에 관한 데이터를 교환합니다.</li>
	<li>WebRTC 클라이언트 어플리케이션들은 <a href="http://en.wikipedia.org/wiki/NAT_traversal" title="Wikipedia article: Network Address Translation traversal">NAT gateways</a>와 방화벽을 넘나듭니다.</li>
</ul>

<p>다른 말로, WebRTC는 4가지 종류의 서버측 기능들이 필요합니다:</p>
<ul>
	<li>사용자 탐색과 통신.</li>
  <li>Signaling.</li>
	<li>NAT/firewall 탐색.</li>
  <li>P2P 실패시의 중계서버들.</li>
</ul>

<a id="stun"></a>
<a id="ice"></a>


<p>NAT 탐색, peer-to-peer 네트워크, 사용자 탐색과 Signaling의 서버앱을 만들기 위한 요구사항들은 본문에서는 다루지 않습니다. <a href="http://en.wikipedia.org/wiki/STUN" title="Wikipedia STUN article">STUN</a> 프로토콜과 그 확장인 <a href="http://en.wikipedia.org/wiki/Traversal_Using_Relay_NAT" title="Wikipedia article about TURN">TURN</a>은 NAT 탐색과 다른 네트워크 문제들을 처리하기위해 RTCPeerConnection을 사용 가능하게 하는 <a href="http://en.wikipedia.org/wiki/Interactive_Connectivity_Establishment" title="Wikipedia article about ICE">ICE</a> framework를 사용한다는 설명으로 충분합니다.</p>

<p>ICE 비디오 채팅 클라이언트 같은 피어들을 연결하기위한 프레임워크입니다. 우선, ICE는 가장 대기시간이 적은 UDP를 통해 피어들 끼리 <em>directly</em> 연결 가능한지 시도합니다. 여기에서 STUN 서버들은 한가지일을 합니다: NAT 뒤에 있는 피어들이 연결 가능하도록 자신들의 공용(public)주소와 포트를 찾아줍니다. (Google은 몇개의 STUN 서버를 가지고 있고,the apprtc.appspot.com 예제에서 그 중 하나를 사용중입니다.)</p>

<figure>
  <img src="stun.png" alt="Finding connection candidates" />
  <figcaption>Finding connection candidates</figcaption>
</figure>

<p>만약 UDP가 실패하면, ICE는 HTTP상의 TCP로 시도를 하고 그 다음엔 HTTPS상에서 시도합니다. 만약 직접 연결이 실패하면 &mdash;간혹 NAT와 방화벽으로 인해&mdash;ICE는 중계를 위해 TURN 서버를 사용합니다. 다시말해, ICE는 ICE는 처음에는 피어들간에 직접연결을 위해 UDP를 이용한 STUN서버를 사용하다가 실패하면 TURN 중계 서버를 통합니다. 'finding candidates'란 표현은 네트워크 장치와 포트들을 찾는 과정을 의미합니다.</p>

<figure style="margin-bottom: 2em">
  <img src="dataPathways.png" alt="WebRTC data pathways" />
  <figcaption>WebRTC data pathways</figcaption>
</figure>

<p>WebRTC 개발자 Justin Uberti는 <a href="http://www.youtube.com/watch?v=p2HzZkd2A40&t=21m12s" title="Google I/O WebRTC presentation: discussion of ICE, STUN and TURN">2013 Google I/O WebRTC presentation</a>에서 ICE, STUN 그리고 TURN에 관한 더 많은 정보를 알려주었습니다. (<a href="http://io13webrtc.appspot.com/#52" title="Google I/O WebRTC presentation slide: Deploying STUN and TURN">발표 슬라이드</a> TURN과 STUN 서버 구현 예제들을 보여줍니다.)</p>

<h4 id="toc-simple">A simple video chat client</h4>

<p style="font-weight: bold">뒤에 나오는 signaling 매커니즘은 <a href="http://apprtc.appspot.com" title="apprtc.appspot.com video chat application">apprtc.appspot.com</a>에서 사용된 것 입니다.</p>
<p style="font-weight: bold">만약 여기서 이해할 수 없는 부분이 있다면, <a href="https://www.bitbucket.org/webrtc/codelab" title="WebRTC codelab repository on Bitbucket">WebRTC codelab</a>을 참고하는 것이 더 좋을 것입니다. 이 단계별 가이드는 어떻게 화상 채팅 어플리케이션을 만드는지 설명합니다, 그리고 <a href="http://Socket.io" title="Socket.io website">Socket.io</a>를 사용해서 <a href="http://nodejs.org/" title="Node website">Node server</a>에서 구현한 Signaling 서버도 포함되어 있습니다.</p>

<p>WebRTC를 체험해보기 좋은 곳은 signaling도 구현되었고 STUN을 사용해 NAT/방화멱 탐색까지 구현된 <a href="http://apprtc.appspot.com" title="Simple WebRTC demo" target="_blank">apprtc.appspot.com</a>입니다. 이 어플리케이션에서는 RTCPeerConnection과 <code>getUserMedia()</code>의 브라우저별 구현 차이를 처리하기 위해 <a href="https://apprtc.appspot.com/js/adapter.js" title="adapter.js JavaScript file">adapter.js</a>를 사용 했습니다.</p>

<p>코드에서는 의도적으로 장황하게 로그를 남겼습니다: 이벤트들의 순서를 이해하기위해서는 콘솔을 확인하시기 바랍니다. 뒤에 자세한 코드 예제들을 보여드리겠습니다.</p>

<h3>What's going on?</h3>

<p>데모는 <code>initalize()</code> 함수를 시작으로 실행됩니다:</p>

<pre class="prettyprint">
function initialize() {
    console.log("Initializing; room=99688636.");
    card = document.getElementById("card");
    localVideo = document.getElementById("localVideo");
    miniVideo = document.getElementById("miniVideo");
    remoteVideo = document.getElementById("remoteVideo");
    resetStatus();
    openChannel('AHRlWrqvgCpvbd9B-Gl5vZ2F1BlpwFv0xBUwRgLF/* ...*/');
    doGetUserMedia();
  }
</pre>

<p><code>openChannel()</code>에서 사용되는 <code>room</code> 값과 token은 구글 앱엔진에서 제공되는 것들 입니다: 어떤 값들이 추가되었는지를 확인하기 위해서는 레포지토리 안에 있는 <a href="https://code.google.com/p/webrtc/source/browse/trunk/samples/js/apprtc/index.html" title="index.html template code in the apprtc repository">index.html template</a>를 확인하시기 바랍니다.</p>

<p>이 코드는 로컬 카메라의 (<code>localVideo</code>)와 원격지 카메라의 (<code>remoteVideo</code>)가 표시될 HTML video 요소들을 변수들을 초기화합니다. <code>resetStatus()</code>는 단순하게 상태 메세지를 설정합니다.</p>

<p><code>openChannel()</code> 함수는 WebRTC 클라이언트 간의 메세지 환경을 구축합니다:</p>

<pre class="prettyprint">
function openChannel(channelToken) {
  console.log("Opening channel.");
  var channel = new goog.appengine.Channel(channelToken);
  var handler = {
    'onopen': onChannelOpened,
    'onmessage': onChannelMessage,
    'onerror': onChannelError,
    'onclose': onChannelClosed
  };
  socket = channel.open(handler);
}
</pre>

<p>이 데모에서는 signaling을 위해 polling 없이 JavaScript 클라이언트 간에 메세징이 가능한 Google App Engine의 <a href="http://code.google.com/appengine/docs/python/channel/overview.html" title="Channel API Overview (Python)" target="_blank">Channel API</a>를 사용합니다. (WebRTC Signaling에 대한 자세한 내용은 이미 <a href="#toc-signaling" title="WebRTC signaling">위에서</a> 설명하였습니다).</p>

<figure>
  <img src="apprtcArchitecture.png" alt="Architecture of the apprtc video chat application" />
  <figcaption>Architecture of the apprtc video chat application</figcaption>
</figure>

<p>Channel API를 통해 채널을 생성하는 방식은 다음과 같습니다:</p>

<ol>
	<li>클라이언트 A가 하나의 유니크 ID를 생성합니다.</li>
	<li>클라이언트 A는 자신의 ID를 App Engine 앱에 넘겨주면서 채널 토큰을 요청합니다.</li>
	<li>App Engine 앱은 Channel API로 부터 채널과 클라이언트 ID에 해당하는 토큰을 요청합니다.</li>
	<li>앱은 토큰을 클라이언트 A에게 전달합니다.</li>
	<li>클라이언트 A는 소켓을 열고 서버에 설정된 채널로부터 메세지를 기다립니다.</li>
</ol>

<figure>
  <img src="channelEstablishing.png" alt="The Google Channel API: establishing a channel" />
  <figcaption>The Google Channel API: establishing a channel</figcaption>
</figure>

<p>메세지 전송하는 방법은 다음과 같습니다:</p>

<ol>
	<li>클라이언트 B는 변경사항과 함께 App Engine 앱으로 POST 요청을 보냅니다.</li>
	<li>App Engine 앱은 요청을 channel로 전달합니다.</li>
	<li>채널은 메세지를 클라이언트 A에게 전달합니다.</li>
	<li>클라이언트 A의 onmessage 콜백함수가 호출됩니다.</li>
</ol>

<figure>
  <img src="channelSending.png" alt="The Google Channel API: sending a message" />
  <figcaption>The Google Channel API: sending a message</figcaption>
</figure>

<p>다시 말하지만: Signaling 메세지는 개발자가 선택한 매커니즘을 통해서 통신하게됩니다. Signaling 메커니즘은 WebRTC 명세에 포함되어 있지 않습니다. Channel API를 데모에서 사용된 방식이고, (웹소켓과 같은) 다른 방식을 사용할 수 도 있습니다.</p>

<p><code>openChannel()</code> 함수가 호출된 이후에, <code>initialize()</code>에서 호출되는 <code>getUserMedia()</code> 함수는 브라우저에서 <code>getUserMedia</code> API가 지원되는지 확인합니다. (getUserMedia에 대한 자세한 내용은 <a href="http://www.html5rocks.com/ko/tutorials/getusermedia/intro/" title="HMTL5 Rocks: Capturing Audio & Video in HTML5" target="_blank">HTML5 Rocks</a>에서 확인 바랍니다.) 지원이 된다면, onUserMediaSuccess 콜백이 호출됩니다:

<pre class="prettyprint">
function onUserMediaSuccess(stream) {
  console.log("User has granted access to local media.");
  // Call the polyfill wrapper to attach the media stream to this element.
  attachMediaStream(localVideo, stream);
  localVideo.style.opacity = 1;
  localStream = stream;
  // Caller creates PeerConnection.
  if (initiator) maybeStart();
}
</pre>

<p>이를 통해 로컬 카메라로 부터 받은 비디오를 <code>localVideo</code>에 표시하게 됩니다, 이때 카메라의 데이터 스트림으로 부터 <a href="http://www.html5rocks.com/tutorials/workers/basics/#toc-inlineworkers-bloburis" title="HTML5 Rocks: information about Blob URLs">object (Blob) URL</a>가 만들어지고 요소의 <code>src</code>에 URL을 설정합니다. (<code>createObjectURL</code>이 이때 사용되어져 '메모리상'에 있는 바이너리 리소스,즉, 비디오를 위한 LocalDataStream의 URI를 얻게됩니다.) 데이터 스트림은 또한 <code>localStream</code> 변수에 설정되어 이후 원격지 사용자를 위해 사용할 수 있게 됩니다.</p>

<p>이 시점에, <code>initiator</code>의 값에 1이 설정됩니다. (그리고 이 값은 Caller의 세션이 종료될 때까지 유지됩니다.) 그래서 <code>maybeStart()</code>가 호출됩니다:</p>

<pre class="prettyprint">
function maybeStart() {
  if (!started && localStream && channelReady) {
    // ...
    createPeerConnection();
    // ...
    pc.addStream(localStream);
    started = true;
    // Caller initiates offer to peer.
    if (initiator)
      doCall();
  }
}
</pre>

<p>이 함수는 비동기 다중 콜백들을 처리할때 편리합니다: <code>maybeStart()</code>은 여러 함수들 중 하나로 부터 호출될 것이지만, 코드는 <code>localStream</code>이 <em>정의되고</em> <code>channelReady</code>의 값이 true가 <em>되고</em> 통신이 아직 시작되지 않은 경우에만 실행됩니다. 그래서&mdash;만약 연결이 이미 되었고, 로컬 스트림이 사용가능하고, Signaling을 위한 채널이 준비가 되었다면, 연결이 생성되고 로컬 비디오 스트림이 전달됩니다. 이것이 한번 진행되면, <code>started</code>는 true가 되어, 연결은 더이상 시작되지 않습니다.</p>

<h4 id="toc-RTCPeerConnection-caller">RTCPeerConnection: making a call</h4>

<p><code>maybeStart()</code>에서 호출된<code>createPeerConnection()</code>이 진짜 액션의 시작입니다:</p>

<pre class="prettyprint">
function createPeerConnection() {
  var pc_config = {"iceServers": [{"url": "stun:stun.l.google.com:19302"}]};
  try {
    // Create an RTCPeerConnection via the polyfill (adapter.js).
    pc = new RTCPeerConnection(pc_config);
    pc.onicecandidate = onIceCandidate;
    console.log("Created RTCPeerConnnection with config:\n" + "  \"" +
      JSON.stringify(pc_config) + "\".");
  } catch (e) {
    console.log("Failed to create PeerConnection, exception: " + e.message);
    alert("Cannot create RTCPeerConnection object; WebRTC is not supported by this browser.");
      return;
  }

  pc.onconnecting = onSessionConnecting;
  pc.onopen = onSessionOpened;
  pc.onaddstream = onRemoteStreamAdded;
  pc.onremovestream = onRemoteStreamRemoved;
}
</pre>

<p>다음은 <code>onIceCandidate()</code> 콜백을 통해 STUN 서버를 사용한 연결을 설정하기 위한 것입니다.(<a href="#stun" title="Explanation of what STUN servers do">위에서</a> 설명한 ICE, STUN ,'candidate'을 참고하시기 바랍니다). 핸들러들은 RTCPeerConnection에서 발생하는 이벤트들을 위해 설정됩니다: 세션이 연결되고 열렸을때, 그리고 원격지 스트림이 추가되고 삭제되었을때. 사실 이 예제에서의 핸들러들은 단순히 로그 메세지만 출력하고 있습니다.&mdash;<code>remoteVideo</code>의 소스를 설정하는 <code>onRemoteStreamAdded()</code>만 제외하고:</p>

<pre class="prettyprint">
function onRemoteStreamAdded(event) {
  // ...
  miniVideo.src = localVideo.src;
  attachMediaStream(remoteVideo, event.stream);
  remoteStream = event.stream;
  waitForRemoteVideo();
}
</pre>

<p><code>maybeStart()</code>에서 <code>createPeerConnection()</code>이 한번 호출이 되면, 연결이 생성되어 callee에게 전달이 됩니다:</p>

<pre class="prettyprint">
function doCall() {
  console.log("Sending offer to peer.");
  pc.createOffer(setLocalAndSendMessage, null, mediaConstraints);
}
</pre>

<p>offer가 생성되는 과정은 <a href="#toc-sans" title="RTCPeerConnection sans signaling">위에서</a>나온 no-signaling 예제와 비슷하지만 추가적으로 offer를 위해 serialized된 SessionDescription을 원격지 피어에게 메세지로 전달 합니다. 이 과정은 <code>setLocalAndSendMessage()</code>를 통해 진행됩니다:</p>

<pre class="prettyprint">
function setLocalAndSendMessage(sessionDescription) {
  // Set Opus as the preferred codec in SDP if Opus is present.
  sessionDescription.sdp = preferOpus(sessionDescription.sdp);
  pc.setLocalDescription(sessionDescription);
  sendMessage(sessionDescription);
}
</pre>

<h4 id="toc-signaling-with-channel">Signaling with the Channel API</h4>

<p><code>onIceCandidate()</code> <code>createPeerConnection()</code>에서 성공적으로 RTCPeerConnection이 생성되었을 떄 호출되는 <code>onIceCandidate()</code> 콜백은 candidates에 관해 '획득한' 정보를 전달합니다:</p>

<pre class="prettyprint">
function onIceCandidate(event) {
    if (event.candidate) {
      sendMessage({type: 'candidate',
        label: event.candidate.sdpMLineIndex,
        id: event.candidate.sdpMid,
        candidate: event.candidate.candidate});
    } else {
      console.log("End of candidates.");
    }
  }
</pre>

<p>클라이언트에서 서버로 송출되는 메세지는 XHR을 이용한 <code>sendMessage()</code>가 처리합니다:</p>

<pre class="prettyprint">
function sendMessage(message) {
  var msgString = JSON.stringify(message);
  console.log('C->S: ' + msgString);
  path = '/message?r=99688636' + '&u=92246248';
  var xhr = new XMLHttpRequest();
  xhr.open('POST', path, true);
  xhr.send(msgString);
}
</pre>

<p>XHR은 클라이언트에서 서버로 signaling 메세지들을 잘 전달합니다, 하지만 일부 메커니즘은 서버에서 클라이언트로의 메세지처리가 필요합니다: 이 어플리케이션에서는 Google App Engine Channel API를 사용합니다. API(즉, App Engine Server)로 부터 받은 메세지는 <code>processSignalingMessage()</code>에서 처리됩니다:</p>

<pre class="prettyprint">
function processSignalingMessage(message) {
  var msg = JSON.parse(message);

  if (msg.type === 'offer') {
    // Callee creates PeerConnection
    if (!initiator && !started)
      maybeStart();

    pc.setRemoteDescription(new RTCSessionDescription(msg));
    doAnswer();
  } else if (msg.type === 'answer' && started) {
    pc.setRemoteDescription(new RTCSessionDescription(msg));
  } else if (msg.type === 'candidate' && started) {
    var candidate = new RTCIceCandidate({sdpMLineIndex:msg.label,
                                         candidate:msg.candidate});
    pc.addIceCandidate(candidate);
  } else if (msg.type === 'bye' && started) {
    onRemoteHangup();
  }
}
</pre>

<p>만약 피어로부터 (offer에 대한 응답으로) 온 메세지가 answer 라면, RTCPeerConnection은 원격지 SessionDescription을 설정하고 통신을 시작합니다. 만약 메세지가 (즉 callee로 부터온) offer라면, RTCPeerConnection는 원격지 SessionDescription을 설정하고 the callee에게 answer를 보냅니다. 그리고 RTCPeerConnection <code>startIce()</code>함수를 호출하여 연결을 시작합니다:</p>

<pre class="prettyprint">
function doAnswer() {
  console.log("Sending answer to peer.");
  pc.createAnswer(setLocalAndSendMessage, null, mediaConstraints);
}
</pre>

<p>이게 끝입니다! caller와 callee는 서로를 발견하고 자신들의 기능에 대한 정보를 교환하고, 통화 세션을 초기화합니다. 그러면 실시간 데이터 통신이 시작될 수 있습니다.</p>

<h3>Network topologies</h3>

<p>WebRTC는 재 일대일 통신에 대한 구현만 되어있습니다, 하지만 좀 더 복잡한 네트워크 시나리오 상에서 사용될 수 있습니다: 예를 들어 여러개의 피어들이 각각 P2P로 직접 통신할 수 있고 , 또는 대량의 참가자들을 처리할 수 있는 <a href="http://en.wikipedia.org/wiki/Multipoint_control_unit" title="MCU article on Wikipedia">Multipoint Control Unit</a> (MCU) 서버를 사용하여 선택적인 스트림을 전달하고, 오디오와 비디오를 믹싱 또는 녹화할 수도 있습니다:</p>

<figure style="margin-bottom: 2em">
  <img src="mcu.png" alt="Multipoint Control Unit topology diagram" />
  <figcaption>Multipoint Control Unit topology example</figcaption>
</figure>



<p>존재하는 많은 WebRTC앱들은 단지 웹 브라우저간의 통신만 보여주고 있습니다, 하지만 게이트웨이 서버들도 브라우저 상에 WebRTC 앱을 실행시켜 <a href="http://en.wikipedia.org/wiki/Public_switched_telephone_network" title="Wikipedia article about the Public Switched Telephone Network">전화기</a> (<a href="https://en.wikipedia.org/wiki/Public_switched_telephone_network" title="Wikipedia: Public Switched Telephone Network">PSTN</a>으로 불리우는) 장비들 또는 <a href="http://en.wikipedia.org/wiki/Voice_over_IP" title="Wikipedia article about Voice Over IP">VOIP</a> 시스템들과 동작할 수 있습니다. 2012년 5월에는, <a href="http://sipml5.org/" title="sipml5 site">sipml5 SIP client</a>를 오픈 소스화한 Doubango Telecom에서 WebRTC와 (다른 용도로도 사용가능한) WebSocket을 이용해 iOS와 Android에서 실행되는 앱과 브라우저들간에 화상통화가 가능하게 했습니다. Google I/O에서, Tethr와 Tropo는 WebRTC를 통해 피쳐폰과 컴퓨터가 통신할 수 있게 해주는 <a href="http://en.wikipedia.org/wiki/OpenBTS" title="Wikipedia article about OpenBTS">OpenBTS cell</a>를 사용해 '간단하게' <a href="http://tethr.tumblr.com/post/25513708436/tethr-and-tropo-in-the-google-i-o-sandbox" title="Tumblr post about Tethr/Tropo demo">a framework for disaster communications</a>를 전시하였습니다. 캐리어 없는 전화 통신!</p>

<figure>
  <img src="tethr.jpg" alt="Tethr/Tropo demo at Google I/O 2012" />
  <figcaption>Tethr/Tropo: disaster communications in a briefcase</figcaption>
</figure>

<h2 id="toc-rtcdatachannel">RTCDataChannel</h2>

<p>오디오와 비디오처럼, WebRTC는 실시간으로 다른 형태의 데이터 통신도 지원합니다.</p>

<p>RTCDataChannel API는 피어와 피어간 임의의 데이터 교환을 빠른 반응속도와 높은 처리량으로 가능하게 합니다. 여기 단순한 '단일 페이지' 데모 <a href="http://simpl.info/dc" title="Simple RTCDataChannel example">simpl.info/dc</a>가 있습니다.</p>

<p>이 API에 대한 많은 잠재적 사용 예가 있습니다:</p>
<ul>
	<li>게임</li>
	<li>원격 데스크탑 어플리케이션</li>
	<li>실시간 문자 채팅</li>
	<li>파일 전송</li>
	<li>분산 네트워크</li>
</ul>

<p>이 API는 RTCPeerConnection의 대부분의 기능들을 활용하여 강력하고 유연한 P2P통신을 가능하게 하는 몇가지 기능을 가지고 있습니다:</p>
<ul>
	<li>RTCPeerConnection 세션 설정의 레버리징.</li>
	<li>우선순위가 있는 여러개의 동시 채널</li>
	<li>신뢰/비신뢰 전달 시멘틱.</li>
	<li>빌트인 보안(DTLS) 과 혼잡 제어.</li>
	<li>오디오 또는 비디오 유/무 사용.</li>
</ul>

<p>문법은 <code>send()</code> 함수와 <code>message</code> 이벤트를 사용하는 것이 WebSocket과 거의 유사합니다:</p>

<pre class="prettyprint">
var pc = new webkitRTCPeerConnection(servers,
  {optional: [{RtpDataChannels: true}]});

pc.ondatachannel = function(event) {
  receiveChannel = event.channel;
  receiveChannel.onmessage = function(event){
    document.querySelector("div#receive").innerHTML = event.data;
  };
};

sendChannel = pc.createDataChannel("sendDataChannel", {reliable: false});

document.querySelector("button#send").onclick = function (){
  var data = document.querySelector("textarea#send").value;
  sendChannel.send(data);
};
</pre>

<p>통신은 브라우저간 직접 연결됩니다 , 그래서 RTCDataChannel은 WebSocket보다 매우 빠릅니다. 심지어 방화벽과 NAT의 방해로 '구멍내기'가 실패하여 중계(TURN) 서버와 연결이 되더라도 빠릅니다.</p>

<p>RTCDataChannel은 Chrome과 Opera, Firefox에서 가능합니다. 멋진 <a href="http://www.cubeslam.com" title="Cube Slam game">Cube Slam</a> 게임에서는 게임 상태 통신을 위해 이 API를 사용하였습니다: 친구 또는 곰과 플레이 해봅시다! <a href="http://www.sharefest.me" title="Sharefest file sharing app">Sharefest</a> enables file sharing via RTCDataChannel, and <a href="https://peercdn.com/" title="peerCDN site">peerCDN</a> offers a glimpse of how WebRTC could enable peer-to-peer content distribution.</p>

<p>RTCDataChannel에 관한 더 자세한 내용은 IETF의 <a href="http://tools.ietf.org/html/draft-jesup-rtcweb-data-protocol-00" title="IETF Data Channel draft specification">draft protocol spec</a>문서를 참고하기 바랍니다.</p>

<h2 id="toc-security">Security</h2>

<p>실시간 통신 어플리케이션이나 플러그인에서 보안 문제가 발생하는 경우가 몇가지가 있습니다. 예를 들면:</p>
<ul>
  <li>암호화 되지 않은 미디어나 데이터는 브라우저간 사이에서 또는 브라우저와 서버 사이에서 도둑질 당할수 있습니다.</li>
  <li>어떤 어플리케이션은 상대방이 모르는 사이에 비디오 또는 오디오가 녹화되거나 공유될 수 있습니다.</li>
  <li>말웨어나 바이러스가 플러그인 또는 어플리케이션안에 숨어 설치될 수 있습니다.</li>
</ul>

<p>WebRTC는 이 문제들을 피할 수 있는 몇가지 기능들을 가지고 있습니다:</p>

<ul>
  <li>WebRTC는 <a href="http://en.wikipedia.org/wiki/Datagram_Transport_Layer_Security" title="Wikipedia article about Datagram Transport Layer Security">DTLS</a>와 <a href="http://en.wikipedia.org/wiki/Secure_Real-time_Transport_Protocol" title="Wikipedia article about Secure Real-time Transport Protocol">SRTP</a>등의 보안 프로토콜을 사용하여 구현되었습니다.</li>
  <li>암호화는 Signlaing 메커니즘을 포함한 모든 WebRTC Components의 필수 조건입니다.</li>
  <li>WebRTC는 플러그인이 아닙니다: 컴포넌트들은 브라우저의 샌드박스위에서 실행되고 별도의 프로세스로 나눠지지 않습니다. 컴포넌트들은 별도의 설치가 필요하지 않고 브라우저 없데이트시에 업데이트 됩니다.</li>
  <li>카메라와 마이크에 접근은 반드시 허가를 통합니다. 그리고 카메라와 마이크가 사용 중인 경우에는, UI를 통해 명확하게 알려줍니다.</li>
</ul>

<p>보안에 관한 전체적인 논의는 본문의 범위에 포함되지 않습니다. 더 자세한 정보를 위해서는 IETF에서 제공한 <a href="http://www.ietf.org/proceedings/82/slides/rtcweb-13.pdf" title="Slides for IETF Proposed WebRTC Security Architecture">WebRTC Security Architecture</a>를 참고 하시기 바랍니다.</p>


<h2 id="toc-conclusion">결론</h2>

<p>WebRTC의 API들과 표준들은 대중화될 것이고 컨텐츠 생산과 통신을위한 도구를 분산시킬 수 있습니다.&mdash;전화, 게임, 영상 제작, 음악 작곡, 뉴스 수집 과 많은 다른 어플리케이션들을 위해서.</p>

<p>기술은 이 이상 <a href="http://en.wikipedia.org/wiki/Disruptive_innovation" title="Wikipedia article about 'disruptive innovation'">분열</a>되지 않을 것 입니다.</p>

<p>우리는 JavaScript 개발자들이 WebRTC를 사용하여 많은 것들을 구현할 것으로 바라보고 있습니다. 블로거 Phil Edholm가 <a href="http://www.nojitter.com/post/232901042/webrtc-is-it-a-game-changer" title="nojitter blog post: WebRTC: Is it a Game Changer?">쓴 것 처럼</a>, '잠재적으로, WebRTC와 HTML5은 브라우저가 정보 분야에 줬던 변화만큼 실시간 통신 분야에 변화를 가능하게 할 것이다.'</p>

<h2 id="toc-tools">개발자 도구들</h2>

<ul>
  <li style="margin-bottom: 1.5em;">크롬에서 <strong>chrome://webrtc-internals</strong> 페이지 (또는 오페라에서 <strong>opera://webrtc-internals</strong> 페이지)는 WebRTC session이 진행중일때 자세한 상태와 차트를 제공합니다:
    <figure>
      <img src="internals.png" alt="chrome://webrtc-internals page" />
      <figcaption>chrome://webrtc-internals screenshot</figcaption>
    </figure>
  </li>
  <li>크로스 브라우저간의 <a href="http://www.webrtc.org/interop" title="webrtc.org Firefox/Chrome interop information">상호동작에 대한 내용</a></li>
  <li><a href="https://apprtc.appspot.com/js/adapter.js" title="adapter.js JavaScript file">adapter.js</a>는 Google에서 관리하는 WebRTC를 위한 JavaScript 코드 입니다. 이것은 벤더들의 prefix와 브라우저간의 차이들, 명세 구현의 차이들을 추상화합니다.</li>
  <li>WebRTC Signlaing 과정을 자세하게 확인하려면, <a href="http://apprtc.appspot.com" title="apprtc.appspot.com video chat demo">apprtc.appspot.com</a>의 콘솔로그를 확인하시기 바랍니다.</li>
  <li>만약 이 모든게 너무 많다고 느껴진다면, <a href="http://io13webrtc.appspot.com/#69" title="WebRTC frameworks">WebRTC framework</a> 또는 완성된 <a href="http://io13webrtc.appspot.com/#72" title="WebRTC service providers">WebRTC&nbsp;service</a>를 사용하는 것이 좋습니다.</li>
  <li>버그 리포트와 기능 요청은 언제나 환영합니다: Chrome 버그들은 <a href="http://www.crbug.com/new" title="Report Chrome bugs and feature requests">crbug.com/new</a> 로, Opera 버그들은 <a href="https://bugs.opera.com/wizard/" title="Report Opera bugs and feature requests">bugs.opera.com/wizard/</a>로, Firefox 버그들은 <a href="https://bugzilla.mozilla.org/" title="File a Firefox bug">bugzilla.mozilla.org</a>로 </li>
</ul>

<h2 id="toc-more">더 볼 것들</h2>

<ul>
  <li><a href="https://www.youtube.com/watch?v=p2HzZkd2A40" title="Video of Google I/O WebRTC session, 2013">WebRTC presentation at Google I/O 2013</a> (슬라이들 들은 <a href="http://io13webrtc.appspot.com" title="Google I/O 2013 WebRTC presentation">io13webrtc.appspot.com</a>)</li>
  <li><a href="https://www.youtube.com/watch?v=E8C8ouiXHHk" title="Video of Justin Uberti WebRTC session at Google I/O, 27 June 2012">Justin Uberti's WebRTC session at Google I/O 2012</a></li>
  <li>Alan B. Johnston 과 Daniel C. Burnett은 WebRTC 책을 썼습니다, 현재 2차 간행이 되었고 eBook은 여기에서 : <a href="http://www.webrtcbook.com" title="WebRTC book information and download">webrtcbook.com</a></li>
  <li><a href="http://www.webrtc.org/" title="webrtc.org">webrtc.org</a>은 WebRTC에 관한 모든 것이 있는 홈입니다: demos, documentation and discussion</li>
  <li><a href="http://www.webrtc.org/demo" title="webrtc.org demos">webrtc.org demo page</a>: links to demos</li>
  <li><a href="https://groups.google.com/forum/?fromgroups#!forum/discuss-webrtc" title="discuss-webrt Google Group">discuss-webrtc</a>: Google Group for technical WebRTC discussion</li>
  <li><a href="https://plus.sandbox.google.com/113817074606039822053/posts" title="WebRTC on Google+">+webrtc</a></li>
  <li><a href="https://twitter.com/webrtc" title="WebRTC on Twitter">@webrtc</a></li>
  <li>Google Developers <a href="https://developers.google.com/talk/libjingle/important_concepts#connections" title="Google Developers: Google Talk for Developers">Google Talk documentation</a>, NAT traversal, STUN, 중계서버 candidate gathering에 관한 자세한 내용이 있습니다.</li>
  <li><a href="http://stackoverflow.com/questions/tagged/webrtc" title="Stack Overflow questions tagged 'webrtc'">Stack Overflow</a>는 WebRTC관련된 질문들과 답변들을 볼 수 있는 좋은 곳 입니다.</li>
</ul>

<h2 id="toc-standards">Standards and protocols</h2>

<ul>
  <li><a href="http://dev.w3.org/2011/webrtc/editor/webrtc.html" title="W3C Editor's Draft document">The WebRTC W3C Editor's Draft</a></li>
  <li><a href="http://dev.w3.org/2011/webrtc/editor/getusermedia.html" title="W3C Editor's Draft: Media Capture and Streams">W3C Editor's Draft: Media Capture and Streams</a> (aka getUserMedia)</li>
  <li><a href="http://tools.ietf.org/wg/rtcweb/charters" title="IETF Working Group Charter">IETF Working Group Charter</a></li>
  <li><a href="http://tools.ietf.org/html/draft-jesup-rtcweb-data-protocol-01" title="IETF RTCDataChannel documentation">IETF WebRTC Data Channel Protocol Draft</a></li>
  <li><a href="http://tools.ietf.org/html/draft-uberti-rtcweb-jsep-02" title="IETF JSEP documentation">IETF JSEP Draft</a></li>
  <li><a href="http://tools.ietf.org/html/rfc5245" title="IETF proposed standard for ICE">IETF proposed standard for ICE</a></li>
  <li>IETF RTCWEB Working Group Internet-Draft: <a href="http://tools.ietf.org/html/draft-ietf-rtcweb-use-cases-and-requirements-10" title="">Web Real-Time Communication Use-cases and Requirements</a></li>
</ul>

<h2 id="toc-support">WebRTC 지원 상황 요약</h2>

<h3>MediaStream and getUserMedia</h3>
<ul>
	<li>Chrome desktop 18.0.1008+; Chrome for Android 29+</li>
    <li>Opera 18+; Opera for Android 20+</li>
    <li>Opera 12, Opera Mobile 12 (based on the Presto engine)</li>
	<li>Firefox 17+</li>
</ul>

<h3>RTCPeerConnection</h3>
<ul>
	<li>Chrome desktop 20+ (현재 'flagless', 다시말해 about:flags에 들어갈 필요없음); Chrome for Android 29+ (flagless)</li>
    <li>Opera 18+ (기본으로 포함됨); Opera for Android 20+ (기본으로 포함됨)</li>
	<li>Firefox 22+ (기본으로 포함됨)</li>
</ul>

<h3>RTCDataChannel</h3>
<ul>
	<li>Chrome 25에서 실험버전, Chrome 26+에서 더 안정적이며 (Firefox와 연동됨); Chrome for Android 29+</li>
    <li>안정화 버전 (and with Firefox interoperability) in Opera 18+; Opera for Android 20+</li>
  <li>Firefox 22+ (기본으로 포함됨)</li>
</ul>

<p>WebRTC는 Internet Explorer에서 Chrome Frame을 통해 사용가능 합니다: <a href="http://www.youtube.com/watch?v=rICLVXcc02A" title="YouTube video, with links to documentation">demo screencast and links to documentation</a>.</p>

<p>RTCPeerConnection를 위한 Native API들도 있습니다: <a href="http://www.webrtc.org/reference/native-apis" title="webrtc.org native API documentation">documentation on webrtc.org</a>.</p>

<p>getUserMedia같은 API들의 크로스 플랫폼 지원 관련 정보는, <a href="http://caniuse.com/stream" title="caniuse.com: getUserMedia/Stream support">caniuse.com</a>에서 참고 바랍니다.</p>

{% endblock %}
