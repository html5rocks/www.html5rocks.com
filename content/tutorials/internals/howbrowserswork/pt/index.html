{% extends "tutorial.html" %}

{% block headauthor %}Tali Garsiel <tgarsiel@gmail.com>{% endblock %}

{% block headtitle %}Como os navegadores funcionam: nos bastidores dos navegadores web modernos{% endblock %}
{% block pagetitle %}<b>Como os navegadores funcionam: </b> nos bastidores dos navegadores web modernos{% endblock %}
{% block head %}

{% endblock %}
{% block pagebreadcrumb %}Como os navegadores funcionam: nos bastidores dos navegadores da web modernos{% endblock %}
{% block date %}16 de agosto de 2011{% endblock %}
{% block updated %}{% endblock %}
{% block onload %}{% endblock %}

{% block browsersupport %}
<span class="browser opera supported"><span class="browser_name">Opera</span><span class="support">compatível</span></span> <span class="browser ie supported"><span class="browser_name">Internet Explorer</span><span class="support">compatível</span></span> <span class="browser safari supported"><span class="browser_name">Safari</span><span class="support">compatível</span></span> <span class="browser ff supported"><span class="browser_name">Firefox</span><span class="support">compatível</span></span> <span class="browser chrome supported"><span class="browser_name">Google Chrome</span><span class="support">compatível</span></span>
{% endblock %}

{% block iscompatible %}

{% endblock %}


{% block content %}


<style>
  h1 b { display:block; font-size: 58px;}
  .browser_support, #html5badge, #html5badge + nav { display:none; }
  a[name] { color: currentColor; }
  blockquote { opacity: 0.9; border-left: 8px solid #ccc; padding-left: 20px; }
  body { line-height: 1.3; }
  li { margin: 3px 0;}
  h3 { font-size: 19px; }
  h4 { font-size: 15.5px; }
  h5 { font-size: 14px; }
  #stack { margin: 5px auto;}
  #stack td, #stack th { border-bottom: 1px dotted #999; }
  samp { background-color: #f2f2f2; border-radius: 2px; padding: 0 2px; }
  samp:empty { display:none; }
  ol.toc { padding-left: 20px; line-height: 1.1; }
  .autonum *:target { background: hsl(60, 73%, 93%);}
  cite { display:block; text-align: right; font-size: 80%; }
  figcaption span:after { content: attr(data-count) ; }

  .tocchap, .tocnum { cursor: default; }
  .tocchap { color: hsl(0, 0%, 60%); margin-bottom: 0; margin-top: 30px; }
  .tocchap + * { margin-top: 5px; }
  h2, h3, h4, h5 { position: relative; }
  .tocnum { position: absolute; left: -56px; width: 50px; text-align: right; font-size: 70%; top: 3px;
    color: hsl(0, 0%, 80%);
    -webkit-transition: all 0.3s ease-out;
       -moz-transition: all 0.3s ease-out;
        -ms-transition: all 0.3s ease-out;
         -o-transition: all 0.3s ease-out;
            transition: all 0.3s ease-out;
  }
  h2:hover .tocnum, h3:hover .tocnum, h4:hover .tocnum, h5:hover .tocnum { color: hsl(0, 0%, 20%); }
  .preface + hr + .tocchap { visibility: hidden;  }
  aside.bio  { border: 3px double hsl(0, 0%, 80%); padding: 10px; }
  aside.bio img { width: 70px; margin: 0 10px 0 0; border: 1px solid hsl(0, 0%, 50%); }
  aside.bio p { margin: 0; }
</style>
<script >
  [].forEach.call( document.querySelectorAll('header .date a'), function(elem, i) {
    elem.textContent += ' (' + ['author','editor'][i] + ')';
  });
</script>

<div class="preface">
<h2>Prefácio</h2>
<p>
  Esta cartilha abrangente sobre as operações internas do WebKit e do Gecko é resultado de muita pesquisa feita pela desenvolvedora israelita Tali Garsiel. Ao longo de alguns anos, ela analisou todos os dados publicados sobre o funcionamento interno de navegadores <small>(consulte <a href="#Resources">Recursos</a>)</small> e dedicou muito tempo à leitura do código-fonte de navegadores da web. Ela escreveu:

  <blockquote>
    Nos anos em que o IE tinha domínio de 90%, não havia muito a fazer além de considerar o navegador como uma "caixa preta", mas agora, com navegadores em código aberto que têm <a href="http://techcrunch.com/2011/08/01/open-web-browsers/">mais da metade da parcela de usuários</a> (link em inglês), é um bom momento para dar uma olhada nas engrenagens e descobrir o que existe por dentro de um navegador da web. Na verdade, o que existe por dentro de milhões de linhas de código C++...
  </blockquote>
  Tali publicou sua pesquisa em <a href="http://taligarsiel.com/"> seu site</a>, mas sabia que ela merecia ser vista por um público maior, então fizemos uma limpeza e a publicamos novamente aqui.

<p>
  Como desenvolvedor da web, <strong>aprender sobre o funcionamento interno das operações de um navegador pode ajudar você a tomar melhores decisões e saber as explicações por trás das melhores práticas de desenvolvimento</strong>. Mesmo que este seja um documento bastante longo, recomendamos que você dedique algum tempo a seu estudo. Garantimos que vale a pena.

  <cite>Paul Irish, Chrome Developer Relations</cite>


</div>

<hr>

<h2 id="Introduction">Introdução</h2>
<p>
Navegadores da web são provavelmente os softwares mais amplamente utilizados. Nesta cartilha, explicarei como eles funcionam nos bastidores. Veremos o que acontece desde quando você digita <code>google.com</code> na barra de endereço até quando a página do Google é exibida na tela de seu navegador.
</p>

<h3>Sumário</h3>

<ol class="toc">
<li><a href="#Introduction">Introdução</a>
<ol>
  <li><a href="#The_browsers_we_will_talk_about">Os navegadores sobre os quais falaremos</a></li>
  <li><a href="#The_browser_main_functionality">A principal funcionalidade do navegador</a></li>
  <li><a href="#The_browser_high_level_structure">A estrutura de nível superior do navegador</a></li>
</ol>
</li>
<li><a href="#The_rendering_engine">O mecanismo de renderização</a>
<ol>
  <li><a href="#Rendering_engines">Mecanismos de renderização</a></li>
  <li><a href="#The_main_flow">O fluxo principal</a></li>
  <li><a href="#Main_flow_examples">Exemplos de fluxo principal</a></li>
</ol>
</li>
<li><a href="#Parsing_general">Análise e construção da árvore DOM</a>
<ol>
  <li><a href="#Parsing_general">Análise - geral</a>
  <ol>
      <li><a href="#Grammars">Gramáticas</a></li>
      <li><a href="#Parser_Lexer_combination">Combinação Analisador - Analisador léxico</a></li>
      <li><a href="#Translation">Tradução</a></li>
      <li><a href="#Parsing_example">Exemplo de análise</a></li>
      <li><a href="#Formal_definitions_for_vocabulary_and_syntax">Definições formais para vocabulário e sintaxe</a></li>
      <li><a href="#Types_of_parsers">Tipos de analisador</a></li>
    <li><a href="#Generating_parsers_automatically">Geração automática de analisadores</a></li>
  </ol>
  </li>
  <li><a href="#HTML_Parser">Analisador HTML</a>
  <ol>
      <li><a href="#The_HTML_grammar_definition">Definição da gramática HTML</a></li>
      <li><a href="#Not_a_context_free_grammar">Não é uma gramática livre de contexto</a></li>
      <li><a href="#HTML_DTD">HTML DTD</a></li>
    <li><a href="#DOM">DOM</a></li>
      <li><a href="#The_parsing_algorithm">O algoritmo de análise</a></li>
      <li><a href="#The_tokenization_algorithm">O algoritmo de geração de tokens</a></li>
    <li><a href="#Tree_construction_algorithm">O algoritmo de construção de árvore</a></li>
      <li><a href="#Actions_when_the_parsing_is_finished">Ações quando a análise é encerrada</a></li>
      <li><a href="#Browsers_error_tolerance">Tolerância a erros do navegador</a></li>
  </ol>
  </li>
  <li><a href="#CSS_parsing">Análise CSS</a>
  <ol>
    <li><a href="#Webkit_CSS_parser">Analisador Webkit CSS</a></li>
  </ol>
  </li>
  <li><a href="#The_order_of_processing_scripts_and_style_sheets">Ordem de processamento de scripts e folhas de estilo</a>
  <ol>
      <li><a href="#Scripts">Scripts</a></li>
      <li><a href="#Speculative_parsing">Análise especulativa</a></li>
      <li><a href="#Style_sheets">Folhas de estilo</a></li>
  </ol>
  </li>
</ol>
</li>
<li><a href="#Render_tree_construction">Construção da árvore de renderização</a>
<ol>
  <li><a href="#The_render_tree_relation_to_the_DOM_tree">Relação entre árvore de renderização e a árvore DOM</a></li>
  <li><a href="#The_flow_of_constructing_the_tree">O fluxo de construção da árvore</a></li>
  <li><a href="#Style_Computation">Computação de estilo</a>
<ol>
    <li><a href="#Sharing_style_data">Compartilhamento de dados de estilo</a></li>
    <li><a href="#Firefox_rule_tree">Árvore de regras do Firefox</a>
<ol>
      <li><a href="#Division_into_structs">Divisão em estruturas</a></li>
      <li><a href="#Computing_the_style_contexts_using_the_rule_tree">Computação de contextos de estilo por meio da árvore de regras</a></li>
    </ol>
</li>
    <li><a href="#Manipulating_the_rules_for_an_easy_match">Manipulação de regras para obter uma fácil correspondência</a></li>
<li><a href="#Applying_the_rules_in_the_correct_cascade_order">Aplicação de regras na ordem em cascata correta</a>
<ol>
    <li><a href="#Style_sheet_cascade_order">Ordem em cascata da folha de estilo</a></li>
<li><a href="#Specificity">Especificidade</a></li>
<li><a href="#Sorting_the_rules">Classificação das regras</a></li>
</ol>
</li>
</ol>
</li>
<li><a href="#Gradual_process">Processo gradual</a></li>
</ol>
</li>
<li><a href="#Layout">Layout</a>
  <ol>
    <li><a href="#Dirty_bit_system">Sistema de bits incorretos</a></li>
    <li><a href="#Global_and_incremental_layout">Layout global e incremental</a></li>
    <li><a href="#Asynchronous_and_Synchronous_layout">Layout assíncrono e síncrono</a></li>
    <li><a href="#Optimizations">Otimizações</a></li>
<li><a href="#The_layout_process">O processo de layout</a></li>
    <li><a href="#Width_calculation">Cálculo da largura</a></li>
    <li><a href="#Line_Breaking">Quebra de linhas</a></li>
  </ol>
 </li>
<li><a href="#Painting">Pintura</a>
  <ol>
    <li><a href="#Global_and_Incremental">Global e incremental</a></li>
    <li><a href="#The_painting_order">Ordem de pintura</a></li>
    <li><a href="#Firefox_display_list">Lista de exibição do Firefox</a></li>
    <li><a href="#Webkit_rectangle_storage">Armazenamento em retângulo do Webkit</a></li>
  </ol>
 </li>
<li><a href="#Dynamic_changes">Mudanças dinâmicas</a></li>
<li><a href="#The_rendering_engines_threads">Sequências do mecanismo de renderização</a>
<ol>
    <li><a href="#Event_loop">Loop de eventos</a></li>
  </ol>
</li>
<li><a href="#css">Modelo visual CSS2</a>
  <ol>
    <li><a href="#The_canvas">O canvas</a></li>
    <li><a href="#CSS_Box_model">Modelo de box CSS</a></li>
    <li><a href="#Positioning_scheme">Esquema de posicionamento</a></li>
    <li><a href="#Box_types">Tipos de box</a></li>
<li><a href="#Positioning">Posicionamento</a>
<ol>
      <li><a href="#Relative">Relativo</a></li>
      <li><a href="#Floats">Floats</a></li>
  <li><a href="#Absolute_and_fixed">Absoluto e fixo</a></li>
</ol>
</li>
<li><a href="#Layered_representation">Representação em camadas</a></li>
  </ol>
 </li>
<li><a href="#Resources">Recursos</a></li>
</ol>



<div>

<h3 id="The_browsers_we_will_talk_about">Os navegadores sobre os quais falaremos</h3>
<p>
Atualmente, existem quatro principais navegadores em uso: Internet Explorer, Firefox, Safari, Google Chrome e Opera. Os exemplos dados serão relacionados aos navegadores em código aberto – Firefox, Google Chrome e Safari (que é parcialmente em código aberto). Conforme as <a href="http://gs.statcounter.com/">estatísticas de navegadores StatCounter</a> (link em inglês), atualmente (em agosto de 2011), a parcela de uso do Firefox, do Safari e do Google Chrome em conjunto é de quase 60%. Isso significa que hoje em dia os navegadores em código aberto são parte substancial do negócio de navegação.
</p>

<h3 id="The_browser_main_functionality">A funcionalidade principal do navegador</h3>
<p>
A funcionalidade principal de um navegador é apresentar o recurso da web escolhido por você por meio de uma solicitação ao servidor e exibição na janela do navegador. O recurso geralmente é um documento HTML, mas também pode ser um PDF, uma imagem ou outro tipo de arquivo. O local desses recursos é especificado pelo usuário por meio de um URI (Identificador Uniforme de Recursos).
</p>
<p>
A forma como o navegador interpreta e exibe arquivos HTML é apresentadas nas especificações de HTML e CSS. Essas especificações são mantidas pelo <a id="w3c">W3C</a> (Consórcio World Wide Web), a organização que controla os padrões para a web.
<br>
<!-- The current version of HTML is 4 (<a href="http://www.w3.org/TR/html401/">http://www.w3.org/TR/html401/</a>). Version 5 is in progress.
The current CSS version is 2 (<a href="http://www.w3.org/TR/CSS2/">http://www.w3.org/TR/CSS2/</a>) and version 3 is in progress.
<br> -->
Por muitos anos, os navegadores mantiveram-se parcialmente de acordo com as especificações e desenvolveram as próprias extensões. Isso causou sérios problemas de compatibilidade para autores da web. Hoje a maioria dos navegadores está relativamente de acordo com as especificações.
</p>
<p>
As interfaces do usuário dos navegadores têm muito em comum. Entre os elementos comuns às interfaces do usuário estão:
<ul>
<li>Barra de endereço para inserção do URI</li>
<li>Botões voltar e avançar</li>
<li>Opções para adicionar favoritos</li>
<li>Botões atualizar e parar para atualizar e parar o carregamento dos documentos atuais</li>
<li>Botão Início que o leva à página inicial</li>
</ul>

<p>
Estranhamente, a interface do usuário do navegador não está em nenhuma especificação formal. Ela é resultado de boas práticas moldadas ao longo de anos de experiência e da influência de um navegador sobre outro. A especificação HTML5 não define os elementos de interface do usuário que um navegador deve possuir, mas lista alguns elementos comuns. Entre eles estão a barra de endereço, a barra de status e a barra de ferramentas. Existem, é claro, recursos exclusivos de cada navegador, como o gerenciador de downloads do Firefox.
</p>
<h3 id="The_browser_high_level_structure">A estrutura de nível superior do navegador
</h3>
<p>
Os principais componentes do navegador são (<a href="#1_1">1.1</a>):
</p>

<ol>

  <li><strong>A interface do usuário </strong>, que inclui a barra de endereço, o botão voltar/avançar, o menu de favoritos, etc. Todas as áreas do display do navegador, exceto a janela principal em que você visualiza a página solicitada.</li>
  <li><strong>O mecanismo de navegação </strong>, que faz a triagem das ações entre a interface do usuário e o mecanismo de renderização.</li>
  <li><strong>O mecanismo de renderização</strong>, responsável pela exibição do conteúdo solicitado. Por exemplo, se o conteúdo solicitado estiver em HTML, ele é responsável pela análise do HTML e do CSS e pela exibição do conteúdo analisado na tela.</li>
  <li><strong>Networking</strong>, utilizado para chamadas de rede, como solicitações HTTP. Possui interface independente de plataforma e sub-implementações para cada plataforma.</li>
  <li><strong>Back-end da interface do usuário</strong>, utilizada para desenhar widgets básicos como caixas de combinação e janelas. Exibe uma interface genérica que não é específica à plataforma. Sob a interface, utiliza os métodos da interface do usuário do sistema operacional.</li>
  <li><strong>Intérprete JavaScript</strong> Utilizado para analisar e executar o código JavaScript.</li>
  <li><strong>Armazenamento de dados</strong>. Esta é uma camada persistente. O navegador precisa salvar dados de diversos tipos no disco rígido, como cookies. A nova especificação HTML (HTML5) define "banco de dados da web", que é um banco de dados completo (embora leve) no navegador.</li>

</ol>


<figure>
  <img src="layers.png" width="500" height="339" alt="" title="" />
  <figcaption><span>Ilustração </span>: principais componentes do navegador. </figcaption>
</figure>


<p>
O Google Chrome, diferente da maioria dos navegadores, mantém múltiplas instâncias do mecanismo de renderização, uma para cada guia. Cada guia é um processo independente.
</p>

<h2 id="The_rendering_engine">O mecanismo de renderização</h2>
<p>
A responsabilidade do mecanismo de renderização é, claro, renderizar, ou seja, exibir os conteúdos solicitados na tela do navegador.
</p>
<p>
Por padrão, o mecanismo de renderização pode exibir documentos e imagens HTML e XML. Ele pode exibir outros formatos por meio de plug-ins (ou extensões do navegador). Por exemplo, é possível exibir um PDF por meio de um plug-in do navegador para visualização de PDFs. No entanto, neste capítulo, nosso foco estará no uso principal: a exibição de HTML e de imagens formatadas com CSS.</p>

<h3 id="Rendering_engines">Mecanismos de renderização</h3>
<p>
Nossos navegadores de referência – Firefox, Google Chrome e Safari – foram construídos com base em dois mecanismos de renderização. O Firefox utiliza o Gecko, um mecanismo de renderização criado pelo próprio Mozilla. O Safari e o Google Chrome usam o Webkit.
</p>
<p>
O Webkit é um mecanismo de renderização em código aberto que começou como um mecanismo para a plataforma Linux e foi modificado pela Apple para ser compatível com os sistemas Mac e Windows. Consulte <a href="http://webkit.org/">webkit.org</a> (link em inglês) para obter mais detalhes.
</p>

<h3 id="The_main_flow">O fluxo principal
</h3>
<p>
O mecanismo de renderização inicia pela obtenção do conteúdo do documento solicitado a partir da camada de rede.
Isso geralmente é feito em parcelas de 8 KB.
</p>
<p>
Em seguida, o fluxo básico do mecanismo de renderização:

</p>

<figure>
  <img src="flow.png" width="600" height="66" alt="" title=""   />
  <figcaption><span>Ilustração </span>: fluxo básico do mecanismo de renderização.</figcaption>
</figure>


<p>
O mecanismo de renderização inicia a análise do documento HTML e transformará as tags em nós <a href="#DOM">DOM</a> de uma árvore chamada "árvore de conteúdo". Ele analisa os dados de estilo nos arquivos externos CSS e nos elementos de estilo. As informações de estilo, aliadas às instruções visuais no HTML são utilizadas para criar outra árvore, a <a href="#Render_tree_construction">árvore de renderização</a>.
</p>
<p>
A árvore de renderização contém retângulos com atributos visuais como cor e dimensões. Os retângulos estão na ordem correta para serem exibidos na tela.
</p>
<p>
Após a construção da árvore de renderização, ela passa por um processo de "<a href="#layout">layout</a>". Isso significa dar a cada nó as coordenadas exatas de onde ele deve ser exibido na tela. A próxima etapa é a <a href="#Painting">pintura</a>. A árvore de renderização será atravessada e cada nó será pintado usando a camada de back-end da interface do usuário.
</p>
<p>
É importante entender que este é um processo gradual. Para uma melhor experiência do usuário, o mecanismo de renderização tenta exibir conteúdos na tela assim que possível. Ele não espera que todo o HTML seja analisado para começar a construir e fazer o layout da árvore de renderização. Partes de conteúdo são analisadas e exibidas, enquanto o processo continua para o restante do conteúdo recebido da rede.
</p>

<h4 id="Main_flow_examples">Principais exemplos de fluxo</h4>

  <figure>
    <img src="webkitflow.png" width="624" height="289" alt=""  />
    <figcaption><span>Ilustração </span>: fluxo principal do Webkit</figcaption>
  </figure>


  <figure>
    <img src="image008.jpg" width="624" height="290" alt="" />
    <figcaption><span>Ilustração </span>: fluxo principal do mecanismo de renderização Gecko do Mozilla(<a href="#3_6">3.6</a>)</figcaption>
  </figure>


<p>
As ilustrações 3 e 4 mostram que, embora o Webkit e o Gecko usem terminologias diferentes, o fluxo é basicamente o mesmo.
<p>
O Gecko nomeia a árvore de elementos formatados visualmente "Árvore de molduras". Cada elemento é uma moldura. O Webkit usa o termo "Árvore de renderização", que é formada por "Objetos de renderização". O Webkit utiliza o termo "layout" para a disposição dos elementos, enquanto o Gecko utiliza "Redimensionamento". "Attachment" é o termo do Webkit para conectar nós DOM e informações visuais para criar a árvore de renderização. Uma pequena diferença não-semântica é que o Gecko tem uma camada adicional entre o HTML e a árvore DOM. Essa camada se chama "coletor de conteúdo" e é uma fábrica para a criação de elementos DOM. Falaremos sobre cada parte do fluxo:
<p>
<h3 id="Parsing_general">Análise - geral</h3>
<p>
Como a análise é um processo significativo no mecanismo de renderização, falaremos sobre ela com um pouco mais de profundidade. Começaremos com uma breve introdução sobre a análise.
</p>
<p>
A análise de um documento significa sua tradução para uma estrutura que faça sentido, algo que o código possa entender e usar. O resultado da análise geralmente é uma árvore de nós que representa a estrutura do documento.
É chamada árvore de análise ou árvore de sintaxe.
</p>

<p>
Exemplo: a análise da expressão <samp>2 + 3 - 1</samp> pode ter como resultado esta árvore:

</p>



<figure>
  <img src="image009.png" width="400" height="155" />
  <figcaption> <span>Ilustração </span>: nó da árvore da expressão matemática</figcaption>
</figure>

<h4 id="Grammars">Gramática</h4>
<p>
A análise é baseada nas regras de sintaxe obedecidas pelo documento - a linguagem ou formato em que foi escrito. Todo formato que pode ser analisado deve possuir gramática determinista composta por regras de vocabulário e sintaxe. Ela é chamada <a href="#context_free_grammar">gramática livre de contexto</a>. As linguagens humanas são diferentes desta linguagem e, portanto, não podem ser analisadas por meio de técnicas de análise convencionais.
</p>
<h4 id="Parser_Lexer_combination">Combinação Analisador - Analisador léxico</h4>
<p>
A análise pode ser separada em dois processos - análise léxica e análise sintática.
</p>
<p>
A análise léxica é o processo de divisão das entradas em tokens. Os tokens são o vocabulário de uma linguagem, uma coleção de elementos estruturais válidos. Nas linguagens humanas, isso seria equivalente a todas as palavras que constam no dicionário de determinado idioma.
</p>
<p>
A análise sintática é a aplicação das regras de sintaxe da linguagem.
</p>
<p>
Analisadores costumam dividir o trabalho em dois componentes: o<b>analisador léxico</b> (às vezes chamado tokenizador), responsável pela divisão da entrada em tokens válidos e o <b>analisador</b>, responsável pela construção da árvore de análise ao analisar a estrutura do documento conforme as regras de sintaxe da linguagem. O analisador léxico é capaz de eliminar caracteres irrelevantes como espaços em branco e quebras de linha.
</p>

<figure>
  <img src="image011.png" width="101" height="300" />
  <figcaption>  <span>Ilustração </span>: do documento-fonte às árvores de análise</figcaption>
</figure>

<p>
O processo de análise é iterativo. O analisador solicita ao analisador léxico um novo token e tenta encontrar alguma correspondência entre o token e uma das regras de sintaxe. Quando uma regra correspondente é encontrada, um nó correspondente ao token é adicionado à árvore de análise e o analisador solicita outro token.
<p>
Se nenhuma regra corresponde, o analisador armazena o token internamente e continua solicitando tokens até que uma regra correspondente a todos os tokens internamente armazenados seja encontrada. Se nenhuma regra é encontrada, o analisador gera uma exceção. Isso significa que o documento não é válido e contém erros de sintaxe.
</p>
<h4 id="Translation">Tradução</h4>
<p>
Muitas vezes a árvore de análise não é o produto final. A análise é utilizada com frequência em traduções, transformando o documento de entrada em outro formato. Um exemplo é a compilação. O compilador que compila um código-fonte em código de máquina começa por analisá-lo em uma árvore de análise e então traduz a árvore em um documento de código de máquina.
</p>


<figure>
  <img src="image013.png" width="104" height="400" />
  <figcaption><span>Ilustração </span>: fluxo de compilação</figcaption>
</figure>


<h4 id="Parsing_example">Exemplo de análise</h4>
<p>
Na ilustração 5, construímos uma árvore de análise a partir de uma expressão matemática. Vamos tentar definir uma linguagem matemática simples e ver como funciona o processo de análise.
<p>
<p>
Vocabulário: nossa linguagem pode incluir números inteiros e sinais de adição e subtração.
</p>
<p>
Sintaxe:
<ol>
<li> Os elementos estruturais da sintaxe de uma linguagem são expressões, termos e operações.

<li> Nossa linguagem pode incluir um número infinito de expressões.</li>
<li> Uma expressão é definida como "termo" seguido por uma "operação", seguida por outro termo</li>
<li> Uma operação é constituída por um token de adição ou subtração</li>
<li> Um termo é um token representado por um número inteiro ou uma expressão</li>
</ol>
</p>
<p>
  Vamos analisar a entrada <samp>2 + 3 - 1</samp>.
  <br>
  A primeira substring que corresponde a uma regra é <samp>2</samp>. Conforme a regra nº. 5 é um termo. A segunda correspondência é <samp>2 + 3</samp>, que corresponde à terceira regra: um termo seguido por uma operação seguida por outro termo. A correspondência seguinte será atingida somente ao fim da entrada. <samp>2 + 3 - 1</samp> é uma expressão porque já sabemos que <samp>2+3</samp> é um termo, de modo que temos um termo seguido por uma operação, seguida por outro termo. <samp>2 + + </samp>não corresponde a nenhuma regra e, portanto, é uma entrada inválida.
</p>
<h4 id="Formal_definitions_for_vocabulary_and_syntax">Definições formais para vocabulário e sintaxe</h4>
<p>
O vocabulário costuma ser formado por <a href="http://www.regular-expressions.info/">expressões regulares</a> (link em inglês).
</p>
<p>
Nossa linguagem, por exemplo, pode ser definida como:
<pre class="prettyprint">
INTEGER :0|[1-9][0-9]*
PLUS : +
MINUS: -
</pre>
Como pode ser visto, números inteiros são definidos por uma expressão regular.
</p>
<p>
A sintaxe costuma ser definida em um formato chamado <a href="http://en.wikipedia.org/wiki/Backus%E2%80%93Naur_Form">BNF</a>. Nossa linguagem é definida como:
<pre class="prettyprint">
expression :=  term  operation  term
operation :=  PLUS | MINUS
term := INTEGER | expression
</pre>
</p>
<p>
Dissemos que a linguagem pode ser analisada por analisadores regulares se sua gramática for uma <a id="context_free_grammar">gramática livre de contexto</a>. Uma definição intuitiva de gramática livre de contexto é uma gramática que pode ser inteiramente expressa em BNF. Para uma definição formal, consulte <a href="http://pt.wikipedia.org/wiki/Gram%C3%A1tica_livre_de_contexto">o artigo da Wikipédia sobre Gramática livre de contexto</a>
<h4 id="Types_of_parsers">Tipos de analisadores</h4>
<p>
Existem dois tipos básicos de analisadores: descendente e ascendente. Uma explicação intuitiva é a de que analisadores descendentes visualizam a estrutura de nível superior da sintaxe e tentam corresponder a uma delas. Analisadores ascendentes iniciam pela entrada e a transformam gradualmente nas regras de sintaxe, iniciando pelas regras de nível inferior até que as regras de nível superior encontrem correspondência.
</p>
<p>
Vejamos como os dois tipos de analisador analisam nosso exemplo:
</p>
<p>
Um analisador descendente inicia pelas regras de nível superior. Ele identifica <samp>2 + 3</samp> como uma expressão. Em seguida, identifica <samp>2 + 3 - 1</samp> como uma expressão (o processo de identificação da expressão evolui com a correspondência a outras regras, mas o ponto de partida é a regra de nível mais alto).
</p>
<p>
O analisador ascendente faz a leitura da entrada até que uma regra corresponda e, em seguida, substitui a entrada correspondente pela regra. Este processo continua até o término da entrada. A expressão com correspondência parcial é armazenada na pilha do analisador.
<table id="stack">
  <tr><th>Pilha</th>                <th>Entrada</th></tr>
  <tr><td>&nbsp;</td>               <td><samp>2 + 3 - 1 </samp></td></tr>
  <tr><td>termo</td>                 <td><samp> + 3 - 1 </samp></td></tr>
  <tr><td>operação do termo</td>       <td><samp> 3 - 1 </samp></td></tr>
  <tr><td>expressão</td>           <td><samp>- 1 </samp></td></tr>
  <tr><td>operação da expressão</td> <td><samp>1 </samp></td></tr>
  <tr><td>expressão</td>           <td><samp>&nbsp; </samp></td></tr>
</table>
Esse tipo de analisador ascendente é chamado analisador shift-reduce, porque a entrada é deslocada (shift) para a direita (imagine um ponteiro direcionado primeiro para o início da entrada e movendo-se para a direita) e é gradualmente reduzida (reduced) às regras de sintaxe.
</p>
<h4 id="Generating_parsers_automatically">Geração automática de analisadores</h4>
<p>
Existem ferramentas capazes de gerar um analisador para você. Elas são chamadas geradores de analisador. Você deve alimentá-las com a gramática de sua linguagem &mdash; suas regras de vocabulário e sintaxe &mdash; e elas produzirão um analisador em funcionamento. A criação de um analisador exige conhecimento profundo sobre o processo de análise e não é fácil criar um analisador otimizado à mão. Por isso, geradores de analisador podem ser muito úteis.
</p>
<p>
O <a id="parser_generators">Webkit</a> utiliza dois geradores de analisador conhecidos: <a href="http://en.wikipedia.org/wiki/Flex_lexical_analyser">Flex</a> (link em inglês) para a criação do analisador léxico e <a href="http://www.gnu.org/software/bison/">Bison</a> (link em inglês) para a criação do analisador (você pode encontrá-los pelos nomes Lex e Yacc). A entrada do Flex é um arquivo com definições de expressões regulares dos tokens. A entrada do Bison são as regras de sintaxe da linguagem no formato BNF.
</p>
<h3 id="HTML_Parser">Analisador HTML</h3>
<p>
O trabalho do analisador HTML é analisar a marcação HTML em uma árvore de análise.
</p>
<h4 id="The_HTML_grammar_definition">Definição de gramática HTML</h4>
<p>
O vocabulário e a sintaxe HTML são definidos nas <a href="#w3c">especificações</a> (link em inglês) criadas pela organização W3C. A versão atual é HTML4 e o trabalho para HTML5 já foi iniciado.
</p>
<h4 id="Not_a_context_free_grammar">Não é uma gramática livre de contexto</h4>
<p>
Como vimos na introdução sobre a análise, a sintaxe de gramática pode ser definida formalmente com o uso de formatos como BNF.
</p><p>
Infelizmente, todos os tópicos convencionais sobre analisadores não são aplicáveis ao HTML. Não os mencionei apenas por diversão, eles serão utilizados na análise de CSS e JavaScript. O HTML não pode ser facilmente definido pela gramática livre de contexto exigida pelos analisadores.
</p><p>
Existe um formato formal de definição de HTML &mdash; DTD (Definição de Tipo de Documento) &mdash;, mas não é uma gramática livre de contexto.
</p><p>
Isso pode parecer estranho à primeira vista, mas o HTML é muito semelhante ao XML. Existem diversos analisadores XML. Existe uma variação XML do HTML, chamada XHTML, então qual a diferença?
</p><p>
A diferença é que a perspectiva HTML é mais adaptável, pois possibilita a você omitir certas tags adicionadas implicitamente, às vezes omitindo o início ou fim de uma tag, etc. Em geral, é uma sintaxe mais "leve" em oposição à sintaxe rígida e exigente do XML.
</p><p>
Aparentemente, essas diferenças que parecem mínimas fazem grande diferença. Por um lado, esta é a razão principal para a popularidade do HTML: ele perdoa seus erros e facilita a vida de autores da web. Por outro lado, dificulta a construção de uma gramática formal. Em suma, o HTML não pode ser analisado facilmente, ao menos por analisadores convencionais, já que sua gramática não é livre de contexto, nem por analisadores XML.
</p>
<h4 id="HTML_DTD">DTD HTML</h4>
<p>
A definição de HTML está em um formato DTD. Esse formato é utilizado para definir as linguagens da família <a href="http://pt.wikipedia.org/wiki/SGML">SGML</a>. O formato contém definições para todos os elementos permitidos, seus atributos e hierarquia. Como vimos anteriormente, o DTD HTML não forma uma gramática livre de contexto.
</p>
<p>
Existem algumas variações do DTD. O modo restrito é adequado somente às especificações, mas outros modos oferecem suporte para marcações utilizadas por navegadores no passado. O motivo disso é oferecer compatibilidade reversa com conteúdos mais antigos. O DTD restrito atual pode ser encontrado aqui: <a href="http://www.w3.org/TR/html4/strict.dtd">www.w3.org/TR/html4/strict.dtd</a> (link em inglês)
</p>
<h4 id="DOM">DOM</h4>
<p>
A árvore de saída: a "árvore de análise" é uma árvore de elementos DOM e nós de atributo. DOM é a sigla para Modelo de Objeto de Documentos. Ele é a representação em objeto do documento HTML e da interface de elementos HTML para o mundo externo, como o JavaScript.
<br>
A raiz da árvore é o objeto "<a  href="http://www.w3.org/TR/1998/REC-DOM-Level-1-19981001/level-one-core.html#i-Document">Document</a>" (link em inglês).
</p>
<p>
O DOM tem uma relação praticamente direta com a marcação. Por exemplo, esta marcação:
<pre class="prettyprint">
&lt;html&gt;
  &lt;body&gt;
    &lt;p&gt;
      Hello World
    &lt;/p&gt;
    &lt;div&gt; &lt;img src="example.png"/&gt;&lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>
Seria traduzida para a seguinte árvore DOM:

</p>

<figure>
  <img src="image015.png" width="400" height="219"  />
  <figcaption>  <span>Ilustração </span>: árvore DOM da marcação de exemplo</figcaption>
</figure>

<p>
Como HTML, o DOM é especificado pela organização W3C. Consulte <a href="http://www.w3.org/DOM/DOMTR">www.w3.org/DOM/DOMTR</a> (link em inglês). É uma especificação genérica para a manipulação de documentos. Um módulo específico descreve elementos específicos do HTML. As definições de HTML podem ser encontradas aqui: <a href="http://www.w3.org/TR/2003/REC-DOM-Level-2-HTML-20030109/idl-definitions.html">www.w3.org/TR/2003/REC-DOM-Level-2-HTML-20030109/idl-definitions.html</a> (link em inglês).
</p>
<p>
Afirmar que a árvore contém nós DOM significa que ela é construída a partir de elementos que implementam uma das interfaces DOM. Navegadores utilizam implementações concretas que possuem outros atributos usados internamente pelo navegador.
</p>
<h4 id="The_parsing_algorithm">O algoritmo de análise</h4>
<p>
Como vimos nas seções anteriores, o HTML não pode ser analisado utilizando os analisadores descendente e ascendente padrão.
</p>
<p>
Os motivos para isso são:
<ol>
<li>A natureza adaptável da linguagem.</li>
<li>O fato de navegadores tradicionalmente terem tolerância a erros para suportar casos conhecidos de HTML inválido.</li>
<li>O processo de análise na reentrância. A fonte geralmente não é modificada durante a análise, mas, em HTML, tags de script que contêm<code>document.write</code> podem incluir tokens adicionais. Assim, o processo de análise acaba por modificar a entrada.</li>
</ol>
<p>
Como não são capazes de usar as técnicas de análise regulares, os navegadores criam analisadores personalizados para a análise do HTML.
</p>
<p>
O <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/parsing.html">algoritmo de análise é descrito em detalhes na especificação do HTML5</a>. O algoritmo é formado por duas etapas: tokenização e construção da árvore.

<p>
A tokenização é a análise léxica, ou seja, a análise da entrada em tokens. Entre os tokens HTML estão as tags de início (start), fim (end), nomes de atributo e valores de atributos.
</p>
<p>
O tokenizador reconhece o token, o direciona para o construtor da árvore e consome o caractere seguinte para reconhecer o token seguinte e prossegue até o final da entrada.
</p>

<figure>
  <img src="image017.png" width="308" height="400" />
  <figcaption><span>Ilustração </span>: fluxo de análise HTML (tirado das especificações do HTML5)</figcaption>
</figure>

<h4 id="The_tokenization_algorithm">O algoritmo de tokenização</h4>
<p>
A saída do algoritmo é um token HTML. O algoritmo é expresso como uma máquina de estados. Cada estado consome um ou mais caracteres do fluxo de entrada e atualiza o estado seguinte de acordo com esses caracteres. A decisão é influenciada pelo estado atual da tokenização e pelo estado de construção da árvore. Isso significa que o mesmo caractere consumido produz diferentes resultados para o estado correto seguinte, dependendo do estado atual. Como o algoritmo é complexo demais para ser descrito integralmente, vejamos um exemplo que pode ajudar a compreender o princípio.

</p><p>

Exemplo básico: como tokenizar o seguinte HTML:

</p>

<pre class="prettyprint">
&lt;html&gt;
  &lt;body&gt;
    Hello world
  &lt;/body&gt;
&lt;/html&gt;
</pre>

<p>

O estado inicial é "Estado de dados". Quando o caractere <code>&lt;</code> é encontrado, o estado é modificado para <b>"Estado de tag aberta"</b>. O consumo de um caractere <code>a-z</code> causa a criação de um "Token de tag de início" e o estado é modificado para <b>"Estado de nome de tag"</b>. Esse estado permanece até que o caractere <code>&gt;</code> seja consumido. Cada caractere é anexado ao nome do novo token. Em nosso caso, o token criado é um token <code>html</code>.

</p><p>

Quando a tag <code>&gt;</code> é alcançada, o token atual é emitido e o estado retorna ao <b>"Estado de dados"</b>. A tag <code>&lt;body&gt;</code> é tratada seguindo as mesmas etapas. Até agora, as tags <code>html</code> e <code>body</code> foram geradas. Voltamos ao <b>"Estado de dados"</b>. O consumo do caractere <code>H</code> em "<code>Hello world</code>" causa a criação e emissão de um token de caractere e o processo continua até que <code>&lt;</code> em <code>&lt;/body&gt;</code> seja alcançado. Emitimos um token de caractere para cada caractere em "<code>Hello world</code>".

</p><p>

Agora voltamos ao <b>"Estado de tag aberta"</b>. Consumir a entrada seguinte <code>/</code> provoca a criação de um <code>token de tag de fim</code> e uma transferência ao <b>"Estado de nome de tag"</b>. Novamente, permanecemos nesse estado até atingirmos <code>&gt;</code>. Em seguida, o token da nova tag é emitido e retornamos ao <b>"Estado de dados"</b>. A entrada <code>&lt;/html&gt;</code> será tratada como o caso anterior.

</p>

<figure>
  <img src="image019.png" width="627" height="387" >
  <figcaption><span>Ilustração </span>: como tokenizar o exemplo de entrada</figcaption>
</figure>

<h4 id="Tree_construction_algorithm">Algoritmo de construção de árvore</h4>
<p>
Quando o analisador é criado, o objeto Document é criado. Durante a fase de construção da árvore, a árvore DOM com o Documento em sua raiz é modificada e elementos são adicionados a ela. Cada nó emitido pelo tokenizador é processado pelo construtor da árvore. Para cada token, a especificação define qual elemento DOM é relevante e deve ser criado para o token. Além da adição do elemento à arvore DOM, ele também é adicionado a uma pilha de elementos abertos. Essa pilha é utilizada para corrigir incompatibilidade em aninhamentos e tag que não foram fechadas. O algoritmo é expresso como uma máquina de estados. Os estados são chamados "modos de inserção".
</p>

<p>
Este é o processo de construção da árvore para a entrada de exemplo:
</p>


<pre class="prettyprint">
&lt;html&gt;
  &lt;body&gt;
    Hello world
  &lt;/body&gt;
&lt;/html&gt;
</pre>

<p>
A entrada para a etapa de construção da árvore é uma sequência de tokens da etapa de tokenização. O primeiro modo é o <b>"modo inicial"</b>. O recebimento de um token html causa uma transferência ao modo<b>"pré-html"</b> e um reprocessamento do token nesse modo. Isso causa a criação do elemento HTMLHtmlElement, que será anexado ao objeto Document raiz.

</p><p>

O estado é modificado para <b>"pré-head"</b>. Recebemos o token "body". Um elemento HTMLHeadElement é criado implicitamente, embora não tenhamos um token "head", e é adicionado à arvore.

</p><p>

Agora passamos para o modo <b>"em head"</b> e, em seguida<b>"pós-head"</b>. O token "body" é reprocessado, um elemento HTMLBodyElement é criado e inserido e o modo é transferido para <b>"em body"</b>.

</p><p>

Os tokens de caractere do trecho "Hello World" agora são recebidos. O primeiro causa a criação e inserção de um nó "Text" e os outros caracteres são anexados a esse nó.

</p><p>

O recebimento do token de fim do body causa a transferência para o modo <b>"pós-body"</b>. Agora recebemos a tag de término do html, que nos leva para o modo <b>"posterior ao pós-body"</b>. O recebimento do fim do token de arquivo termina a análise.
</p>

<figure>
  <img src="image022.gif" width="532" height="769" />
  <figcaption><span>Ilustração </span>: construção da árvore do html de exemplo</figcaption>
</figure>


<h4 id="Actions_when_the_parsing_is_finished">Ações quando a análise é terminada</h4>
<p>
Nesta etapa, o navegador marca o documento como interativo e inicia a análise de scripts em modo "adiado", aqueles que devem ser executados após o término da análise do documento. O estado do documento é configurado como "completo" e um evento "carregar" é acionado.
</p>

<p>
Você pode ver <a href="http://www.w3.org/TR/html5/syntax.html#html-parser">os algoritmos completos de tokenização e construção de árvore na especificação do HTML5</a>
</p>

<h4 id="Browsers_error_tolerance">Tolerância a erros dos navegadores</h4>
<p>
Você nunca recebe um erro "Sintaxe inválida" em uma página HTML. Os navegadores consertam qualquer conteúdo inválido e prosseguem suas funções.

</p><p>
Tome este HTML como exemplo:

</p>

<pre class="prettyprint">
&lt;html&gt;
  &lt;mytag&gt;
  &lt;/mytag&gt;
  &lt;div&gt;
  &lt;p&gt;
  &lt;/div&gt;
    Really lousy HTML
  &lt;/p&gt;
&lt;/html&gt;
</pre>

<p>

Devo ter violado um milhão de regras ("mytag" não é uma tag padrão, aninhamento incorreto dos elementos "p" e "div" e mais), mas o navegador ainda exibe o conteúdo corretamente. Portanto, grande parte do código do analisador é feito para consertar erros de autores HTML.

</p><p>

O erro de manipulação é consistente em navegadores, mas incrivelmente não é parte das especificações atuais de HTML. Como os botões adicionar aos favoritos e voltar/avançar, é algo que foi desenvolvido nos navegadores com o passar dos anos. Existem construções inválidas em HTML que são conhecidas e repetidas em muitos sites e que os navegadores tentar consertar de maneiras que estejam de acordo com outros navegadores.

</p><p>

A especificação HTML5 define alguns desses requisitos. O Webkit tem um bom resumo no comentário no início da classe analisador de HTML

</p>

<blockquote>
<p>O analisador analisa entradas tokenizadas no documento, construindo a árvore do documento. Se o documento tiver uma boa formação, a análise é simples.</p>

<p>Infelizmente, temos que lidar com muitos documentos HTML que não têm boa formação, então o analisador deve ser tolerante com os erros.</p>

<p>Temos que tratar, no mínimo, das seguintes condições de erro:</p>

<ol>
  <li>O elemento adicionado é expressamente proibido caso esteja dentro de uma tag externa. Neste caso, devemos fechar todas as tag até aquela que proíbe o elemento e adicioná-lo em seguida.
  <li>Não é permitido adicionar o elemento diretamente. É possível que o autor do documento tenha esquecido de alguma tag no meio (ou que a tag no meio seja opcional). Este pode ser o caso das tags a seguir: HTML HEAD BODY TBODY TR TD LI (esqueci alguma?).
  <li>Queremos adicionar um elemento de bloco no interior de um elemento in-line. Feche todos os elementos in-line até o segundo maior elemento de bloco.
  <li>Se isso não funcionar, feche os elementos até que possamos adicionar o elemento ou ignorar a tag.
</ol>

</blockquote>

<p>
Vejamos alguns exemplos de tolerância a erros no Webkit:
</p>
<h5>&lt;/br&gt; em vez de &lt;br&gt;</h5>
<p>
Alguns itens utilizam &lt;/br&gt; em vez de &lt;br&gt;. Para ser compatível com IE e Firefox, o Webkit trata este marcador como &lt;br&gt;.
<br>
O código:
<pre class="prettyprint">
if (t->isCloseTag(brTag) && m_document->inCompatMode()) {
     reportError(MalformedBRError);
     t->beginTag = true;
}
</pre>
Observação: a manipulação de erros é interna e não será exibida para o usuário.
</p>
<h5>Uma stray table </h5>
<p>
Uma stray table é uma tabela dentro do conteúdo de outra tabela, mas não dentro de uma célula da tabela.
<br>
Como este exemplo:
<pre class="prettyprint">
&lt;table&gt;
    &lt;table&gt;
        &lt;tr&gt;&lt;td&gt;inner table&lt;/td&gt;&lt;/tr&gt;
    &lt;/table&gt;
    &lt;tr&gt;&lt;td&gt;outer table&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
</pre>
O Webkit muda a hierarquia para duas tabelas derivadas:
<pre class="prettyprint">
&lt;table&gt;
    &lt;tr&gt;&lt;td&gt;outer table&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
&lt;table&gt;
    &lt;tr&gt;&lt;td&gt;inner table&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
</pre>
O código:
<pre class="prettyprint">
if (m_inStrayTableContent && localName == tableTag)
        popBlock(tableTag);
</pre>
O Webkit utiliza uma pilha para o conteúdo atual do elemento – ele faz com que a tabela interna saia da pilha da tabela externa. Assim, as tabelas se tornam derivadas.
</p>
<h5>Elementos de formulário aninhados</h5>
<p>
Caso o usuário inclua um formulário dentro de outro, o segundo será ignorado.
<br>
O código:
<pre class="prettyprint">
if (!m_currentFormElement) {
        m_currentFormElement = new HTMLFormElement(formTag,    m_document);
}
</pre>
</p>
<h5>Uma hierarquia de tags muito profunda</h5>
<p>
O comentário é auto-explicativo.
<br>
<div class="comment">
<blockquote>
www.liceo.edu.mx é um exemplo de site que atinge um nível de aninhamento de cerca de 1.500 tags, todas de um conjunto de &lt;b&gt;s. Nós permitimos no máximo 20 tags aninhadas do mesmo tipo antes de ignorá-las por completo.
</blockquote>
</div>
<pre class="prettyprint">
bool HTMLParser::allowNestedRedundantTag(const AtomicString& tagName)
{

unsigned i = 0;
for (HTMLStackElem* curr = m_blockStack;
         i &lt; cMaxRedundantTagDepth && curr && curr->tagName == tagName;
     curr = curr->next, i++) { }
return i != cMaxRedundantTagDepth;
}
</pre>
</p>
<h5>Tags html ou body end mal posicionadas</h5>
<p>
Novamente, o comentário é auto-explicativo.

<blockquote>
Suporte para html realmente corrompido. Nunca fechamos a tag body, já que algumas páginas estúpidas da web a fecham antes do final efetivo do documento. Vamos confiar na chamada end() para o fechamento.
</blockquote>

<pre class="prettyprint">
if (t->tagName == htmlTag || t->tagName == bodyTag )
        return;

</pre>
Portanto, autores da web, fiquem atentos: a menos que queiram aparecer como exemplo de tolerância a erros no snippet de código do Webkit, criem HTML bem formado.
</p>
<p>

<h3 id="CSS_parsing">Análise CSS </h3>
<p>
Você lembra dos conceitos de análise mencionados na introdução? Bem, ao contrário do HTML, o CSS é uma gramática livre de contexto e pode ser analisada utilizando os tipos de analisador descritos na introdução. Na verdade, <a href="http://www.w3.org/TR/CSS2/grammar.html">a especificação do CSS define a gramática léxica e sintática do CSS</a> (link em inglês).
</p>
<p>
Vejamos alguns exemplos:
<br>
A gramática léxica (vocabulário) é definida por expressões regulares para cada token:
<pre>
comment   \/\*[^*]*\*+([^/*][^*]*\*+)*\/
num   [0-9]+|[0-9]*"."[0-9]+
nonascii  [\200-\377]
nmstart   [_a-z]|{nonascii}|{escape}
nmchar    [_a-z0-9-]|{nonascii}|{escape}
name    {nmchar}+
ident   {nmstart}{nmchar}*
</pre>
<p>
"ident" é a abreviação de identificador, como um nome da classe. "name" é um ID de elemento (referido por "#")
</p>
<p>
A gramática de sintaxe é descrita em BNF.

<pre class="prettyprint lang-css">
ruleset
  : selector [ ',' S* selector ]*
    '{' S* declaration [ ';' S* declaration ]* '}' S*
  ;
selector
  : simple_selector [ combinator selector | S+ [ combinator? selector ]? ]?
  ;
simple_selector
  : element_name [ HASH | class | attrib | pseudo ]*
  | [ HASH | class | attrib | pseudo ]+
  ;
class
  : '.' IDENT
  ;
element_name
  : IDENT | '*'
  ;
attrib
  : '[' S* IDENT S* [ [ '=' | INCLUDES | DASHMATCH ] S*
    [ IDENT | STRING ] S* ] ']'
  ;
pseudo
  : ':' [ IDENT | FUNCTION S* [IDENT S*] ')' ]
  ;
</pre>
Explicação: um conjunto de regras tem esta estrutura:
<pre class="prettyprint lang-css">
div.error , a.error {
  color:red;
  font-weight:bold;
}
</pre>
div.error e a.error são seletores. A parte interna às chaves contém as regras aplicadas por este conjunto de regras. Esta estrutura é formalmente definida nesta definição:
<pre class="prettyprint lang-css">
ruleset
  : selector [ ',' S* selector ]*
    '{' S* declaration [ ';' S* declaration ]* '}' S*
  ;
</pre>
Isso significa que um conjunto de regras é um seletor ou um conjunto de seletores separados por uma vírgula e espaços (o "S" representa espaço em branco). Um conjunto de regras contém chaves e, dentro destas, uma declaração ou, opcionalmente, várias declarações separadas por ponto e vírgula. Os termos "declaração" e "seletor" serão definidos nas definições BNF a seguir.
</p>
<h4 id="Webkit_CSS_parser">Analisador de CSS do Webkit</h4>
<p>
O Webkit utiliza os geradores de analisador <a href="#parser_generators">Flex e Bison</a> para criar analisadores automaticamente a partir de arquivos de gramática CSS. Como você deve lembrar da introdução sobre analisadores, o Bison cria um analisador shift-reduce ascendente. O Firefox utiliza um analisador descendente criado manualmente. Nos dois casos, cada arquivo CSS é analisado em um objeto StyleSheet e cada objeto contém regras CSS. Os objetos de regra CSS contêm objetos seletores e de declaração e outros objetos correspondentes à gramática CSS.
</p>

<figure>
  <img src="image023.png" width="500" height="393" alt="" title="" border="0" align=""  />
  <figcaption><span>Ilustração </span>: análise de CSS</figcaption>
</figure>


<h3 id="The_order_of_processing_scripts_and_style_sheets">A ordem de processamento dos scripts e folhas de estilo</h3>
<h4 id="Scripts">Scripts</h4>
<p>
O modelo da web é síncrono. Autores esperam que scripts sejam analisados e executados imediatamente quando o analisador atinge uma tag &lt;script&gt;. A análise do documento é interrompida até que o script seja executado. Se o script for externo, o recurso deve ser buscado na rede – o que também é feito de maneira síncrona – e a análise é interrompida até que o recurso seja encontrado. Este foi o modelo durante muitos anos e também está nas especificações de HTML4 e HTML5. Autores podem marcar o script como "adiar" para que ele não interrompa a análise do documento e seja executado depois da análise. O HTML5 adiciona a opção de marcar o script como assíncrono para que ele possa ser analisado e executado por uma sequência diferente.
</p>
<h4 id="Speculative_parsing">Análise especulativa</h4>
<p>
O Webkit e o Firefox fazem esta otimização. Ao executar scripts, outra sequência analisa o restante do documento e descobre que outros recursos devem ser carregados da rede e faz seu carregamento. Assim os recursos podem ser carregados em conexões paralelas e a velocidade total é melhorada. Observação: o analisador especulativo não modifica a árvore DOM, deixando a tarefa para o analisador principal. Ele apenas analisa as referências a recursos externos como scripts externos, folhas de estilo e imagens.
</p>
<h4 id="Style_sheets">Folhas de estilo</h4>
<p>
As folhas de estilo, por outro lado, têm um modelo diferente. Conceitualmente parece que desde que folhas de estilo não modifiquem a árvore DOM, não há motivo para esperar por elas e parar a análise do documento. Existe uma questão, no entanto, de scripts que solicitam informações de estilo durante a etapa de análise do documento. Se o estilo ainda não tiver sido carregado e analisado, o script receberá respostas erradas e isso pode causar diversos problemas. Parece ser uma exceção, mas na verdade é bastante comum. O Firefox bloqueia todos os scripts quando o carregamento e a análise da folha de estilo ainda não foram concluídos. O Webkit bloqueia scripts somente quando eles tentam acessar determinadas propriedades de estilo que podem ser afetadas por folhas de estilo não carregadas.
</p>
<h3 id="Render_tree_construction">Construção da árvore de renderização</h3>
<p>
Enquanto a árvore DOM é construída, o navegador constrói outra árvore, a árvore de renderização. Essa árvore contém elementos visuais na ordem em que devem ser exibidos. É a representação visual do documento. A finalidade da árvore é possibilitar a pintura do conteúdo na ordem correta.
</p>
<p>
O Firefox nomeia os elementos na árvore de renderização como "molduras". O Webkit utiliza o termo renderizador ou objeto de renderização.
<br>
Um renderizador sabe como pintar e organizar no layout a si mesmo e a seus filhos.
<br>
A classe RenderObject do Webkit, a classe básica dos renderizadores, tem a seguinte definição:
<pre class="prettyprint">
class RenderObject{
  virtual void layout();
  virtual void paint(PaintInfo);
  virtual void rect repaintRect();
  Node* node;  //the DOM node
  RenderStyle* style;  // the computed style
  RenderLayer* containgLayer; //the containing z-index layer
}
</pre>
</p>
<p>
Cada renderizador representa uma área retangular que geralmente corresponde ao box CSS do nó, como descrito nas especificações do CSS2. Ele contém informações geométricas como largura, altura e posição.
<br>
O tipo de box é afetado pelo atributo de estilo "display" relevante para o nó (consulte a seção <a href="#style_computation">computação de estilo</a>). Aqui está o código do Webkit para decidir que tipo de renderizador deve ser criado para um nó DOM, de acordo com o atributo display.
<pre class="prettyprint">
RenderObject* RenderObject::createObject(Node* node, RenderStyle* style)
{
    Document* doc = node->document();
    RenderArena* arena = doc->renderArena();
    ...
    RenderObject* o = 0;

    switch (style->display()) {
        case NONE:
            break;
        case INLINE:
            o = new (arena) RenderInline(node);
            break;
        case BLOCK:
            o = new (arena) RenderBlock(node);
            break;
        case INLINE_BLOCK:
            o = new (arena) RenderBlock(node);
            break;
        case LIST_ITEM:
            o = new (arena) RenderListItem(node);
            break;
       ...
    }

    return o;
}
</pre>
O tipo de elemento também é considerado. Controles de quadros e tabelas, por exemplo, possuem molduras especiais.
<br>
No Webkit, se um elemento quiser criar um renderizador especial, ele irá ignorar o método <code>createRenderer</code>. Os renderizadores apontam para objetos de estilo que contêm informação não geométrica.
</p>
<h5 id="The_render_tree_relation_to_the_DOM_tree">A relação da árvore de renderização com a árvore DOM</h5>
Os renderizadores correspondem aos elementos DOM, mas a relação não é direta. Elementos DOM não visuais não serão inseridos na árvore de renderização. Um exemplo é o elemento "head". Os elementos cujo atributo display foi definido como "none" também não aparecerão na árvore (elementos com atributo de visibilidade "hidden" aparecerão na árvore).
</p>
<p>
Existem elementos DOM que correspondem a vários objetos visuais. Estes costumam ser elementos com estrutura complexa que não podem ser representados por um único retângulo. Por exemplo, o elemento "select" possui 3 renderizadores: um para a área de exibição, outro para o menu suspenso e outro para o botão. Além disso, quando o texto é dividido em várias linhas porque a largura não é suficiente para uma linha, as novas linhas são adicionadas como renderizadores adicionais.
<br>
Outro exemplo que possui diversos renderizadores é HTML corrompido. De acordo com as especificações CSS, um elemento in-line deve conter apenas elementos de bloco ou outros elementos in-line. Em casos de conteúdo misto, renderizadores de bloco anônimos são criados para efetuar quebras de linha nos elementos in-line.
</p>
<p>
Alguns objetos de renderização correspondem a um nó DOM, mas não no mesmo lugar da árvore. Floats e elementos posicionados de forma absoluta estão fora do fluxo, posicionados em um local diferente na árvore e mapeados para a moldura real. Uma moldura de espaço reservado é onde eles deveriam ser posicionados.
</p>

<a id="rendertree"></a>

  <figure>
      <img src="image025.png" width="731" height="396" >
    <figcaption><span>Ilustração </span>: a árvore de renderização e a árvore DOM correspondente (<a href="#3_1">3.1</a>). A "Janela de visualização" é o bloco que inicialmente contém as informações. No Webkit, ela será o objeto "RenderView". </figcaption>
  </figure>



<h5 id="The_flow_of_constructing_the_tree">O fluxo de construção da árvore</h5>
<p>
No Firefox, a apresentação é registrada como uma escuta para atualizações do DOM. A apresentação delega a criação de molduras ao <code>FrameConstructor</code> e o construtor resolve o estilo (consulte <a href="#style">computação de estilo</a>) e cria uma moldura.
</p>
<p>
No Webkit o processo de resolver o estilo e criar um renderizador é chamado "attachment". Cada nó do DOM tem um método "attach". O attachment é síncrono e a inserção de nós na árvore DOM solicita o novo método de "attach" (anexação) de nós.
<p>
O processamento de tags html e body resulta na construção da raiz da árvore de renderização. O objeto de renderização raiz corresponde ao que a especificação do CSS chama de bloco contentor, o bloco superior que contém todos os outros blocos. Suas dimensões são a janela de visualização - as dimensões da área da janela de exibição do navegador. O Firefox a chama de <code>ViewPortFrame</code> e o Webkit de <code>RenderView</code>. Este é o objeto de renderização para o qual o documento aponta. O restante da árvore é construído como uma inserção de nós DOM.
</p>
<p>
Consulte <a href="http://www.w3.org/TR/CSS21/intro.html#processing-model">as especificações do CSS2 sobre o modelo de processamento</a> (link em inglês).
</p>


<h4 id="Style_Computation">Computação de estilo</h4>
<p>
A construção da árvore de renderização exige o cálculo das propriedades visuais de cada objeto de renderização. Isso é feito por meio do cálculo das propriedades de estilo de cada elemento.
</p>
<p>
O estilo inclui folhas de estilo de diversas origens, elementos de estilo in-line e propriedades visuais no HTML (como a propriedade "bgcolor"). Esta é traduzida para as propriedades de estilo CSS correspondentes.
</p>
<p>
As origens das folhas de estilo são as folhas de estilo padrão do navegador, as folhas de estilo fornecidas pelo autor da página e as folhas de estilo do usuário, que são folhas de estilo fornecidas pelo usuário do navegador, uma vez que os navegadores permitem que você defina seu estilo preferido. No Firefox, por exemplo, isso é feito pelo posicionamento de uma folha de estilo na pasta "Perfil Firefox").
</p>
<p>
A computação de estilo produz novas dificuldades:
<ol>
<li>Dados de <a id="issue1">estilo</a> são uma construção extensa que armazena diversas propriedades de estilo e isso pode causar problemas de memória.</li>
<li>
<p><a id="issue2">Encontrar</a> as regras correspondentes a cada elemento pode causar problemas de desempenho se o processo não estiver otimizado. Transferir a lista de regras integralmente para cada elemento para encontrar correspondências é um trabalho pesado. Seletores podem possuir estruturas complexas que fazem com que o processo de correspondência inicie por um caminho que parece promissor, mas que acaba por ser fútil, tornando necessário tentar outro caminho.
</p>
<p>Por exemplo, este seletor composto:</p>

<pre class="prettyprint">
div div div div{
  ...
}
</pre>
Significa que as regras são aplicáveis a <code>&lt;div&gt;</code>, que é descendente de 3 divs. Imagine que você queira verificar se a regra é aplicável a um elemento  <code>&lt;div&gt;</code>. Você escolhe determinado caminho pela árvore para verificar. Você pode precisar atravessar toda a árvore de nós para descobrir que existem apenas duas divs e que a regra não é aplicável. Você precisaria então tentar outros caminhos na árvore.
</li>
<li>A <a id="issue3">aplicação</a> das regras envolve regras complexas em cascata que definem a hierarquia das regras.</li>
</ol>
Vejamos como os navegadores lidam com estas questões:

<h5 id="Sharing_style_data">Compartilhando dados de estilo</h5>
<p>
Os nós do Webkit fazem referência a objetos de estilo (RenderStyle) que podem ser compartilhados por nós em algumas condições. Os nós são associados ou derivados e:
<ol>
<li>Os elementos devem estar no mesmo estado do mouse (por exemplo, um não pode estar em :hover enquanto o outro não está)</li>
<li> Nenhum elemento pode possuir um id</li>
<li> Os nomes de tags devem ser correspondentes</li>
<li> Os atributos de classe devem ser correspondentes</li>
<li> O conjunto de atributos mapeados deve ser idêntico</li>
<li> Os estados de link devem ser correspondentes</li>
<li> Os estados de foco devem ser correspondentes</li>
<li> Nenhum elemento pode ser afetado por seletores de atributo, em que "ser afetado" significa ter qualquer correspondência de seletores que utilize um seletor de atributo em qualquer posição dentro do seletor</li>
<li> Não deve haver atributo de estilo in-line nos elementos</li>
<li>Não deve haver seletores derivados em uso. O WebCore simplesmente efetua uma mudança global quando qualquer seletor derivado é encontrado e desativa o compartilhamento de estilo para todo o documento quando os seletores estão presentes. Isso inclui o seletor + e seletores como :first-child e :last-child.</li>
</ol>

<h5 id="Firefox_rule_tree">Árvore de regras do Firefox</h5>
<p>
O Firefox possui duas árvores adicionais para facilitar a computação de estilo: a árvore de regras e a árvore de contexto de estilo. O Webkit também possui objetos de estilo, mas eles não são armazenados em uma árvore como a árvore de contexto de estilo; apenas o nó DOM aponta para o estilo relevante.

</p>

<figure>
  <img src="image035.png" width="640" height="407" />
  <figcaption><span>Ilustração </span>: árvore de contexto de estilo Firefox (<a href="#2_2">2.2</a>)</figcaption>
</figure>


<p>
Os contextos de estilo contêm valores finais. Os valores são computados pela aplicação de todas as regras correspondentes na ordem correta e pela execução de manipulações que os transformam de valores lógicos em valores concretos. Por exemplo, se o valor lógico for a porcentagem da tela, ele será calculado e transformado em unidades absolutas. A ideia da árvore de regras é uma criação muito inteligente. Ela possibilita o compartilhamento desses valores entre nós para evitar que eles precisem ser computados novamente. Isso também diminui o consumo de espaço.
</p>

<p>
Todas as regras correspondentes são armazenadas em uma árvore. Os nós inferiores em um caminho têm prioridade mais alta. A árvore contém todos os caminhos para correspondência de regras encontradas. O armazenamento dessas regras é feito com economia de recursos. A árvore não é calculada no início para cada nó, mas cada vez que um estilo de nó precisa ser computado, os caminhos computados são adicionados à árvore.
</p>
<p>
A ideia é visualizar os caminhos da árvore como palavras em um léxico. Digamos que esta árvore de regras já tenha sido computada:

<figure>
  <img src="tree.png" width="400" height="261" alt="" title="" border="0" align=""  />
</figure>

Imagine que precisamos fazer a correspondência de regras para um novo elemento na árvore de conteúdo e descobrir que regras compatíveis (na ordem correta) são B - E - I. Nós já possuímos esse caminho na árvore porque já computamos o caminho A - B - E - I - L. Teremos menos trabalho a fazer.
</p>
<p>
Vejamos como a árvore diminui nosso trabalho.
</p>
<h5 id="Division_into_structs">Divisão em estruturas</h5>
<p>
Os contextos de estilo são divididos em estruturas. Essas estruturas contêm informação de estilo para determinada categoria como borda ou cor. As propriedades em uma estrutura podem ser herdadas ou não herdadas. Propriedades herdadas são propriedades que, a menos que definidas pelo elemento, são herdadas do pai. Propriedades não herdadas (chamadas propriedades "redefinidas") utilizam valores padrão, se não são definidas.
</p>
<p>
A árvore nos ajuda a fazer o armazenamento em cache de estruturas inteiras (com valores finais computados) na árvore. A ideia é que, se o nó inferior não oferecer uma definição para a estrutura, uma estrutura em cache em um nó superior possa ser utilizada.
</p>
<h5 id="Computing_the_style_contexts_using_the_rule_tree">Computação de contextos de estilo por meio da árvore de regras</h5>
<p>
Ao computar o contexto de estilo para determinado elemento, primeiro computamos um caminho na árvore de regras ou usamos um já existente. Em seguida, começamos a aplicar as regras no caminho para preencher a estrutura em nosso novo contexto de estilo. Começamos pelo nó inferior do caminho - aquele com a prioridade mais alta (normalmente o seletor mais específico) e atravessamos a árvore até que nossa estrutura esteja completa. Se não houver especificação para a estrutura neste nó de regra, podemos fazer uma boa otimização: subimos na árvore até encontrarmos um nó que a especifique completamente e simplesmente aponte para ela. Esta é a melhor otimização: a estrutura inteira é compartilhada. Isso economiza em computação de valores finais e memória.
<br>
Se encontramos definições parciais, ascendemos na árvore até que a estrutura esteja completa.
</p>
<p>
Se não encontramos nenhuma definição para nossa estrutura, caso a estrutura seja do tipo "herdado", apontamos para a estrutura do elemento original na <b>árvore de contexto</b>. Neste caso, também tivemos êxito em compartilhar estruturas. Se esta for uma estrutura redefinida, os valores padrão serão utilizados.
</p>
<p>
Se o nó mais específico adicionar valores, teremos que fazer alguns cálculos adicionais para transformá-los em valores reais. Armazenamos o resultado em cache então no nó da árvore para que ele possa ser utilizado pelos filhos.
</p>
<p>
Se um elemento possuir um irmão correspondente que aponte para o mesmo nó na árvore, <b>todo o contexto de estilo</b> pode ser compartilhado entre eles.
</p>
<p>
Vejamos um exemplo: imagine que tenhamos este HTML


<pre class="prettyprint">
&lt;html&gt;
  &lt;body&gt;
    &lt;div class="err" id="div1"&gt;
      &lt;p&gt;
        this is a &lt;span class="big"&gt; big error &lt;/span&gt;
        this is also a
        &lt;span class="big"&gt; very  big  error&lt;/span&gt; error
      &lt;/p&gt;
    &lt;/div&gt;
    &lt;div class="err" id="div2"&gt;another error&lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>

E as seguintes regras:
<pre class="prettyprint lang-css linenums">
div {margin:5px;color:black}
.err {color:red}
.big {margin-top:3px}
div span {margin-bottom:4px}
#div1 {color:blue}
#div2 {color:green}
</pre>
<p>
Para simplificar as coisas, digamos que precisemos preencher apenas duas estruturas: a estrutura de cor e a de margem. A estrutura de cor contém apenas um membro: a cor. A estrutura de margem contém as quatro extremidades.
<br>
A árvore de regras resultante terá esta aparência (os nós estão marcados com o nome do nó: o número da regra para a qual apontam):



<figure>
  <img src="image027.png" width="500" height="294" />
  <figcaption><span>Ilustração </span>: a árvore de regras</figcaption>
</figure>


<br>
A árvore de contexto terá esta aparência (nome do nó : o nó da regra para a qual apontam):


<figure>
  <img src="image029.png" width="400" height="305" >
  <figcaption> <span>Ilustração </span>: a árvore de contexto</figcaption>
</figure>



<p>
Suponha que analisemos o HTML e cheguemos à segunda tag &lt;div&gt;. Teremos que criar um contexto de estilo para este nó e preencher suas estruturas de estilo.
<br>
Corresponderemos as regras e descobriremos que as regras correspondentes para &lt;div&gt; são 1, 2 e 6. Isso significa que já existe um caminho na árvore que nosso elemento pode utilizar e só precisamos adicionar outro nó a ele para a regra 6 (o nó F na árvore de regras).
<br>
Criaremos um contexto de estilo e o colocaremos na árvore de contexto. O novo contexto de estilo apontará para o nó F na árvore de regras.
</p>
<p>
Agora devemos preencher as estruturas de estilo. Começaremos preenchendo a estrutura de margem. Já que o último nó de regra (F) não adiciona à estrutura de margem, podemos ascender na árvore até encontrar uma estrutura em cache computada em uma inserção de nó anterior e a utilizá-la. Nós a encontraremos no nó B, que é o nó superior entre os que especificam regras de margem.
</p>
<p>
Não temos uma definição para a estrutura de cor, então não podemos usar uma estrutura armazenada em cache. Já que a cor tem apenas um atributo, não precisamos ascender na árvore para preencher outros atributos. Computaremos o valor final (converter a string para RGB etc.) e armazenaremos a estrutura em cache neste nó.
</p>
<p>
O trabalho no segundo elemento &lt;span&gt; é ainda mais simples.
 Corresponderemos as regras e chegaremos à conclusão que ele aponta para a regra G, como o período anterior. Já que temos filhos que apontam para o mesmo nó, podemos compartilhar todo o contexto de estilo e apenas apontar para o contexto do período anterior.
</p>
<p>
Para estruturas com regras herdadas do original, o armazenamento em cache é feito na árvore de contexto (a propriedade de cor na verdade é herdada, mas o Firefox a considera redefinida e a armazena em cache na árvore de regras).
<br>
Por exemplo, se tivéssemos adicionado regras para fontes em um parágrafo:
<pre class="prettyprint">
p {font-family:Verdana;font size:10px;font-weight:bold}
</pre>
Então o elemento de parágrafo, que é filho da div na árvore de contexto, poderia ter compartilhado a estrutura de fonte de seu pai. Isso caso nenhuma regra de fonte tenha sido especificada para o parágrafo.
</p>
<p>
No Webkit, que não possui uma árvore de regras, as declarações com correspondência são transferidas 4 vezes. Em primeiro lugar, as propriedades não importantes de alta prioridade (propriedades que devem ser aplicadas em primeiro lugar porque outras dependem delas, como display) são aplicadas, em seguida as importantes de alta prioridade, depois aquelas não importantes de prioridade normal e por último as regras importantes de prioridade normal. Isso significa que as propriedades que aparecem várias vezes são resolvidas de acordo com a ordem em cascata correta. Os últimos serão os primeiros.
<br>
</p>
<p>
Em resumo, compartilhar os objetos de estilo (inteiramente ou algumas das estruturas internas e eles) resolve os problemas <a href="#issue1">1</a> e <a href="#issue3">3</a>. A árvore de regras do Firefox também ajuda na aplicação de propriedades na ordem correta.
</p>
<h5 id="Manipulating_the_rules_for_an_easy_match">Manipulação de regras para obter uma fácil correspondência</h5>
<p>
Existem diversas fontes para regras de estilo:
<ul>
<li>As regras CSS, em folhas de estilo externas ou em elementos de estilo.
<pre class="prettyprint">
p {color:blue}
</pre>
</li>
<li>Atributos de estilo in-line como
<pre class="prettyprint">
&lt;p style="color:blue" /&gt;
</pre>
</li>
<li>atributos visuais HTML (mapeados para regras de estilo relevantes)
<pre class="prettyprint">
&lt;p bgcolor="blue" /&gt;
</pre>
</li>
</ul>
<p>
As duas últimas são facilmente correspondidas ao elemento, já que ele possui os atributos de estilo e os atributos HTML podem ser mapeados utilizando o elemento como chave.
</p>
<p>
Como observado anteriormente no <a href="#issue2">problema 2</a>, a correspondência de regras CSS pode ser mais complicada. Para resolver a dificuldade, as regras são manipuladas para facilitar o acesso.
</p><p>
Após a análise da folha de estilo, um de diversos mapas hash é adicionado às regras, de acordo com o seletor. Existem mapas por id, nome de classe, nome de tag e um mapa geral para tudo que se encontre nessas categorias. Se um seletor for uma id, a regra será adicionada ao mapa de id; se for uma classe, será adicionado ao mapa de classe, etc.
<br>
Essa manipulação facilita muito a correspondência de regras. Não há necessidade de verificar cada declaração, já que podemos extrair as regras relevantes para cada elemento a partir dos mapas. Essa otimização elimina 95% ou mais das regras, para que elas não precisem ser consideradas durante o processo de correspondência (<a href="#4_1">4.1</a>).
</p>
<p>
Vejamos, por exemplo, as seguintes regras de estilo:
<pre class="prettyprint">
p.error {color:red}
#messageDiv {height:50px}
div {margin:5px}
</pre>
A primeira regra será inserida no mapa de classe. A segunda no mapa de id e a terceira no mapa de tag.
<br>
Para o seguinte fragmento HTML;
<pre class="prettyprint">
&lt;p class="error">an error occurred &lt;/p>
&lt;div id=" messageDiv">this is a message&lt;/div&gt;
</pre>
</p>
<p>
Tentaremos, em primeiro lugar, encontrar regras para o elemento p. O mapa de classe conterá uma chave "erro" sob a qual a regra para "p.error" será encontrada. O elemento div terá regras relevantes no mapa de id (a chave é o id) e o mapa de tag. Assim, resta descobrir qual regra extraída pelas chaves realmente é correspondente.
<br>
Por exemplo, caso a regra para a div seja
<pre class="prettyprint">
table div {margin:5px}
</pre>
ela ainda será extraída do mapa de tag, pois a chave é o seletor à extrema direita, mas ela não corresponderia a nosso elemento div que não possui um ancestral de tabela.
</P>
<P>
O Webkit e o Firefox fazem essa manipulação.
</p>
<h5 id="Applying_the_rules_in_the_correct_cascade_order">Aplicação de regras na ordem em cascata correta</h5>
<p>
O objeto de estilo tem propriedades que correspondem a todos os atributos visuais (todos os atributos css, mas de forma mais genérica). Se a propriedade não for definida por nenhuma das regras correspondidas, algumas propriedades podem ser herdadas pelo objeto de estilo do elemento pai. Outras propriedades têm valores padrão.
</p>
<p>
O problema começa quando existe mais de uma definição. E eis que chega a ordem em cascata para resolver a questão.
<h5 id="Style_sheet_cascade_order">Ordem em cascata da folha de estilo</h5>
Uma declaração para uma propriedade de estilo pode aparecer em diversas folhas de estilo e várias vezes em uma folha de estilo. Isso significa que a ordem de aplicação das regras é muito importante. Isso se chama ordem "em cascata". De acordo com a especificação do CSS2, a ordem em cascata é (do inferior ao superior):
<ol>
  <li>Declarações do navegador</li>
  <li>Declarações normais do usuário</li>
  <li>Declarações normais do autor</li>
  <li>Declarações importantes do autor</li>
  <li>Declarações importantes do usuário </li>
</ol>
</p>
<p>
As declarações do navegador são menos importantes e o usuário prevalece sobre o autor somente se a declaração for marcada como importante. Declarações com a mesma ordem são classificadas por <a href="#Specificity">especificidade</a> e em seguida pela ordem em que foram especificadas. Os atributos visuais do HTML são traduzidos em declarações correspondentes em CSS. Elas são tratadas como regras de autor com prioridade baixa.
</p>
<h5 id="Specificity">Especificidade</h5>
<p>
A especificidade do seletor é definida pela <a href="http://www.w3.org/TR/CSS2/cascade.html#specificity">especificação do CSS2</a> (link em inglês) da seguinte maneira:
<ul>
    <li>conte 1 se declaração for originada de um atributo de "estilo" e não de uma regra com seletor; caso contrário, o valor deve ser 0 (= a)</li>
    <li>conte o número de atributos de ID no seletor (= b) </li>
    <li>conte o número de outros atributos e pseudoclasses no seletor (= c) </li>
    <li>conte o número de nomes de elementos e pseudoelementos no seletor (= d) </li>
</ul>
Ao concatenar os quatro números a-b-c-d (em um sistema de números com base ampla), o resultado é a especificidade.
</p>
<p>
A base numérica que você deve utilizar é definida pela contagem mais alta encontrada em uma das categorias.
<br>
Por exemplo, se a=14 você pode usar a base hexadecimal. No caso improvável de a=17, você precisará de uma base numérica de 17 dígitos. Isso pode acontecer com um seletor como este: html body div div p... (17 tags em seu seletor... pouco provável)
</p>
<p>
Alguns exemplos:
<pre class="prettyprint">
 *             {}  /* a=0 b=0 c=0 d=0 -> specificity = 0,0,0,0 */
 li            {}  /* a=0 b=0 c=0 d=1 -> specificity = 0,0,0,1 */
 li:first-line {}  /* a=0 b=0 c=0 d=2 -> specificity = 0,0,0,2 */
 ul li         {}  /* a=0 b=0 c=0 d=2 -> specificity = 0,0,0,2 */
 ul ol+li      {}  /* a=0 b=0 c=0 d=3 -> specificity = 0,0,0,3 */
 h1 + *[rel=up]{}  /* a=0 b=0 c=1 d=1 -> specificity = 0,0,1,1 */
 ul ol li.red  {}  /* a=0 b=0 c=1 d=3 -> specificity = 0,0,1,3 */
 li.red.level  {}  /* a=0 b=0 c=2 d=1 -> specificity = 0,0,2,1 */
 #x34y         {}  /* a=0 b=1 c=0 d=0 -> specificity = 0,1,0,0 */
 style=""          /* a=1 b=0 c=0 d=0 -> specificity = 1,0,0,0 */
</pre>
</p>
<h5 id="Sorting_the_rules">Classificação das regras</h5>
<p>
Após a correspondência das regras, elas são classificadas de acordo com as regras em cascata. O Webkit usa a classificação em balão para pequenas listas e a classificação em mescla para as grandes. O Webkit implementa a classificação ao sobrepor o operador "&gt;" para as regras:
<pre class="prettyprint">
static bool operator >(CSSRuleData& r1, CSSRuleData& r2)
{
    int spec1 = r1.selector()->specificity();
    int spec2 = r2.selector()->specificity();
    return (spec1 == spec2) : r1.position() > r2.position() : spec1 > spec2;
}
</pre>
</p>
<h4 id="Gradual_process">Processo gradual</h4>
<p>
O Webkit utiliza um sinalizador que marca se todas as folhas de estilo superiores (incluindo @imports) foram carregadas. Caso um estilo não tenha sido inteiramente carregado durante a anexação, placeholders são utilizados e ele é marcado no documento. Eles serão recalculados quando as folhas de estilo forem inteiramente carregadas.
</p>


<h3 id="Layout">Layout</h3>
<p>
Quando o renderizador é criado e adicionado à arvore, ele não possui posição e tamanho. O cálculo desses valores é chamado layout ou redimensionamento.
</p>
<p>
O HTML utiliza um fluxo baseado no modelo layout, o que significa que quase sempre é possível computar a geometria em um único envio. Elementos que entrem posteriormente "no fluxo" não costumam afetar a geometria dos elementos que estavam anteriormente "no fluxo", então o layout pode ser processado da esquerda para a direita e de cima para baixo no documento. Há exceções, como tabelas HTML, que podem requerer mais de um envio (<a href="#3_5">3.5</a>).
</p>
<p>
O sistema de coordenadas é relativo à moldura raiz. As coordenadas superior e da esquerda são utilizadas.
</p>
<p>
O layout é um processo recursivo. Ele inicia no renderizador raiz, que corresponde ao elemento <code>&lt;html></code> do documento HTML. O layout prossegue recursivamente por toda a hierarquia de molduras ou por parte dela, fazendo a computação de informações geométricas para cada renderizador que a solicite.
</p>
A posição do renderizador raiz é 0,0 e suas dimensões são a janela de visualização, que é a parte visível da janela do navegador.
<p>
Todos os processadores possuem um método de "layout" ou "redimensionamento". Cada processador invoca o método de layout dos filhos que precisam de layout.
</p>
<h4 id="Dirty_bit_system">Sistema de bits incorretos</h4>
<p>
Para não haver a necessidade de produzir um layout completo para cada pequena mudança, o navegador utiliza o sistema de "bits incorretos". Um renderizador modificado ou adicionado marca a si mesmo e a seus filhos como "incorretos", precisando de layout.
</p>
<p>
Existem dois sinalizadores: "incorreto" e "filhos incorretos". "Filhos incorretos" significa que, embora não haja problemas com o renderizador, ele possui no mínimo um filho que precisa de layout.
</p>
<h4 id="Global_and_incremental_layout">Layout global e incremental</h4>
<p>
O layout pode ser ativado em toda a árvore de renderização; este é o layout "global". Isso pode acontecer como efeito de:
<ol>
<li>Uma mudança de estilo global que afeta todos os processadores, como uma mudança de tamanho de fonte.</li>
<li>Como resultado do redimensionamento da tela</li>
</ol>
</p>
<p>
O layout pode ser incremental: apenas os processadores incorretos recebem layout. Isso pode danos que exigem layouts adicionais.
<br>
O layout incremental é acionado (de forma assíncrona) quando renderizadores são marcados como incorretos. Por exemplo, quando novos renderizadores são adicionados à árvore de renderização depois que conteúdo adicional é enviado da rede para a árvore DOM.
</p>


<figure>
  <img src="reflow.png" width="326" height="341" />
  <figcaption> <span>Ilustração </span>: Layout incremental - apenas renderizadores incorretos e seus derivados passam por layout (<a href="#3_6">3.6</a>).</figcaption>
</figure>

<h4 id="Asynchronous_and_Synchronous_layout">Layout assíncrono e síncrono</h4>
O layout incremental é feito de forma assíncrona. O Firefox organiza os "comandos de redimensionamento" em fila para executar o layout incremental e um programador aciona a execução em lote desses comandos. O Webkit também possui um timer que executa o layout de forma incremental: a árvore é atravessada e os processadores "incorretos" ficam de fora do layout.
<br>
Scripts que solicitam informações de estilo, como "offsetHeight", podem acionar o layout incremental de forma síncrona.
<br>
O layout global é normalmente acionado de forma síncrona.
<br>
Às vezes o layout é acionado como retorno de chamada após um layout inicial porque alguns atributos, como a posição de rolagem, foram modificados.
<h4 id="Optimizations">Otimizações</h4>
Quando um layout é acionado por um "redimensionamento" ou mudança na posição do renderizador (mas não em seu tamanho), os tamanhos dos processadores são solicitados ao cache e não recalculados.
<br>
Em alguns casos, apenas uma árvore inferior na hierarquia é modificada e o layout não é iniciado a partir da raiz. Isso pode acontecer nos casos em que a mudança é local e não afeta seus arredores - como texto inserido em campos de texto. Caso contrário, cada caractere digitado poderia acionar o processo de layout a partir da raiz.
</p>
<h4 id="The_layout_process">O processo de layout</h4>
<p>
O layout costuma ter o seguinte padrão:
<ol>
<li>O renderizador pai determina sua própria largura.
<li>O pai vai até seu filho e:
  <ol>
    <li>Posiciona o renderizador filho (define seu x e y).</li>
    <li>Se necessário, chama o layout filho (caso sejam incorretos ou estejamos em um layout global ou por algum outro motivo), o que gera o cálculo da altura do filho.</li>
  </ol>
</li>
<li>Pais utilizam as alturas cumulativas de seus filhos e as alturas de margens e preenchimentos para determinar a própria altura, que será utilizada pelo pai do renderizador pai.</li>
<li>Define seu bit incorreto como falso.</li>
</ol>
</p>
<p>
O Firefox usa o objeto "estado"(nsHTMLReflowState) como parâmetro para o layout (chamado de "reposicionamento"). Entre outras informações, o estado inclui a largura do pai.
<br>
O resultado do layout do Firefox é um objeto "metrics" (nsHTMLReflowMetrics). Ele contém a altura computada do renderizador.
</p>
<h4 id="Width_calculation">Cálculo da largura </h4>
<p>
A largura do renderizador é calculada usando a largura do bloco recipiente, a propriedade "width" de estilo do renderizador, as margens e bordas.
<br>
Por exemplo, a largura da seguinte div:
<pre class="prettyprint">
&lt;div style="width:30%"/&gt;
</pre>
Seria calculada pelo Webkit da seguinte forma (classe RenderBox método calcWidth):
<ul>
<li>A largura do recipiente é o valor máximo da availableWidth dos recipientes e 0. A availableWidth neste caso é contentWidth, calculada como:
<pre class="prettyprint">
clientWidth() - paddingLeft() - paddingRight()
</pre>
clientWidth e clientHeight representam o interior de um objeto, com exceção da borda e da barra de rolagem.
</li>
<li>A largura dos elementos é o atributo de estilo "width". Ela será calculada como um valor absoluto pela computação da porcentagem da largura do recipiente.
</li>
<li>As bordas horizontais e preenchimentos são adicionados agora.</li>
</ul>
Até então, este era o cálculo da "largura preferencial". Agora as larguras mínima e máxima serão calculadas.
<br>
Se a largura preferencial for maior que a largura máxima, a largura máxima será utilizada. Se for menor que a largura mínima (a menos unidade indivisível) a largura mínima será utilizada.
</p>
<p>
Os valores são armazenados em cache, caso seja necessário um layout, mas a largura não é modificada.
</p>
<p>
<h4 id="Line_Breaking">Quebra de linha </h4>
<p>
Quando um renderizador no meio de um layout decide que uma quebra é necessária. Ele para e propaga a seu pai a necessidade da quebra. O pai cria renderizadores adicionais e inicia o processo de layout para eles.
</p>
<h3 id="Painting">Pintura</h3>
<p>
Na fase de pintura, a árvore de renderização é atravessada e o método de "pintura" dos renderizadores é solicitado para exibir seu conteúdo na tela. A pintura utiliza o componente de infraestrutura da interface do usuário.
<h4 id="Global_and_Incremental">Global e incremental</h4>
Como o layout, a pintura também pode ser global, quando a árvore inteira é pintada, ou incremental. Na pintura incremental, alguns renderizadores são modificados de forma que não afete a árvore integralmente. O renderizador modificado invalida seu retângulo na tela. Isso faz com que o sistema operacional reconheça uma "região incorreta" e gere um evento "pintura". O sistema operacional o faz de forma inteligente e integra diversas regiões em uma. No Google Chrome, o processo é mais complicado porque o renderizador está em um processo diferente do principal. O Google Chrome simula o comportamento do sistema operacional até certo ponto. A apresentação escuta esses eventos e delega a mensagem à raiz do processador. A árvore é atravessada até que o renderizador relevante seja encontrado. Ele pintará a si mesmo (e geralmente também a seus filhos).
<h4 id="The_painting_order">A ordem de pintura </h4>
<a href="http://www.w3.org/TR/CSS21/zindex.html">O CSS2 define a ordem do processo de pintura</a> (link em inglês). Esta é, na verdade, a ordem na qual os elementos são empilhados em <a href="#stackingcontext">pilhas de contexto</a>. Essa ordem afeta a pintura, uma vez que as tarefas são pintadas de trás para a frente. A ordem de empilhamento de um renderizador em bloco é:
<ol>
<li>cor do plano de fundo</li>
<li>imagem de plano de fundo</li>
<li>borda</li>
<li>filhos</li>
<li>contorno</li>
</ol>
</p>
<h4 id="Firefox_display_list">Lista de exibição do Firefox</h4>
O Firefox repassa a árvore de renderização e constrói uma lista de exibição para o retângulo pintado. Ela contém os renderizadores relevantes ao retângulo, na ordem correta de pintura (planos de fundo dos renderizadores, depois bordas etc.). Assim, a árvore deve ser atravessada apenas uma vez para uma nova pintura em vez de diversas vezes, realizando a pintura de todos os planos de fundo, em seguida de todas as imagens, depois todas as bordas, etc.

<p>
O Firefox otimiza o processo por não adicionar elementos que serão escondidos, como elementos completamente cobertos por outros elementos opacos.
</p>
<h4 id="Webkit_rectangle_storage">Armazenamento em retângulo do Webkit</h4>
Antes da nova pintura, o webkit salva o retângulo antigo como um bitmap. Em seguida pinta apenas o delta entre os retângulos antigo e novo.

<br>

<h3 id="Dynamic_changes">Mudanças dinâmicas</h3>
Os navegadores tentam executar o mínimo de ações possível em resposta a uma mudança. Por isso mudanças na cor de um elemento causam apenas a nova pintura desse elemento. Modificações na posição de um elemento provocam um novo layout e a nova pintura do elemento, de seus filhos e possivelmente de seus elementos correspondentes. A adição de um nó DOM provoca um novo layout e a nova pintura do nó. Mudanças maiores, como o aumento do tamanho da fonte no elemento "html" causam a invalidação dos caches, um novo layout e a nova pintura de toda a árvore.


<h3 id="The_rendering_engines_threads">As sequências do mecanismo de renderização</h3>
O mecanismo de renderização tem uma sequência única. Quase tudo, exceto operações de rede, acontece em uma sequência única. No Firefox e no Safari, esta é a principal sequência do navegador. No Google Chrome, é a sequência principal da guia de processos.
<br>
Operações de rede podem ser executadas por diversas sequências paralelas. O número de conexões paralelas é limitado, geralmente de 2 a 6 conexões. O Firefox 3, por exemplo, usa 6.
<h4 id="Event_loop">Loop de eventos</h4>
A sequência principal do navegador é um loop de eventos. É um loop infinito que mantém o processo ativo. Ele aguarda eventos (como eventos de layout e pintura) e os processa. Este é o código do Firefox para o loop de eventos principal:
<pre class="prettyprint">
while (!mExiting)
    NS_ProcessNextEvent(thread);
</pre>


<h3 id="css">Modelo visual CSS2</h3>
<h4 id="The_canvas">O canvas </h4>
<p>
De acordo com a <a href="http://www.w3.org/TR/CSS21/intro.html#processing-model">especificação do CSS2</a> (link em inglês), o termo canvas descreve "o espaço onde a estrutura de formatação é processada". - onde o navegador pinta o conteúdo. O canvas é infinito para cada dimensão do espaço, mas os navegadores escolhem uma largura inicial baseada nas dimensões da janela de visualização.
</p>
<p>
De acordo com <a href="http://www.w3.org/TR/CSS2/zindex.html">www.w3.org/TR/CSS2/zindex.html</a> (link em inglês), o canvas é transparente se contido em outro ou, caso contrário, tem uma cor definida pelo navegador.
</p>
<h4 id="CSS_Box_model">Modelo de box CSS </h4>
<p>
O <a href="http://www.w3.org/TR/CSS2/box.html">Modelo de box CSS</a> descreve os boxes retangulares gerados para elementos na árvore de documento e dispostos de acordo com o modelo de formatação visual.
<br>
Cada box tem uma área de conteúdo (por exemplo texto, uma imagem etc.) e preenchimento opcional ao redor, borda e áreas de margem.


<figure>
  <img src="image046.jpg" width="509" height="348" >
  <figcaption> <span>Imagem </span>: modelo de box CSS</figcaption>
</figure>


<p>
Cada nó gera de 0..a n boxes como esses.
<br>
Todos os elementos têm uma propriedade "display" que determina o tipo de box que será gerado por elas. Exemplos:

<pre class="prettyprint">
block  - generates a block box.
inline - generates one or more inline boxes.
none - no box is generated.
</pre>
O padrão é in-line, mas a folha de estilo do navegador determinou outros padrões. Por exemplo: a exibição padrão para o elemento "div" é bloco.
<br>
Você encontra um exemplo de folha de estilo padrão aqui: <a href="http://www.w3.org/TR/CSS2/sample.html">www.w3.org/TR/CSS2/sample.html</a> (link em inglês)
</p>

<h4 id="Positioning_scheme">Esquema de posicionamento</h4>
<p>
Existem três esquemas:
<ol>
<li>Normal: o objeto é posicionado de acordo com seu lugar no documento. Isso significa que seu lugar na árvore de renderização é equivalente a seu lugar na árvore DOM e disposto de acordo com seu tipo e dimensão de box</li>
<li>Float: o objeto inicialmente é disposto no fluxo normal e em seguida movido para a extrema direita ou esquerda </li>
<li>Absoluto: o objeto é colocado na árvore de renderização de maneira diferente àquela como é colocado na árvore DOM</li>
</ol>
</p>
<p>
O esquema de posicionamento é definido pela propriedade "position" e pelo atributo "float".
<ul>
<li>estático e relativo geram um fluxo normal</li>
<li>absoluto e fixo geram um posicionamento absoluto</li>
</ul>
<br>
No posicionamento estático, nenhuma posição é definida e o posicionamento padrão é utilizado. Em outros esquemas, o autor especifica a posição: top,bottom,left,right.
</p>
<p>
A forma com que o box é disposto é determinada por:
<ul>
<li>Tipo de box</li>
<li>Dimensões do box</li>
<li>Esquema de posicionamento</li>
<li>Informações externas - como tamanhos de imagens e tela</li>
</ul>
</p>
<h4 id="Box_types">Tipos de box</h4>
<p>
Box em bloco: forma um bloco - tem seu próprio retângulo na janela do navegador.
</p>


<figure>
  <img src="image057.png" width="150" height="127"  />
  <figcaption> <span>Ilustração </span>: box em bloco</figcaption>
</figure>

<p>
Box in-line: não tem seu próprio bloco, mas está dentro de um bloco recipiente.
</p>


<figure>
  <img src="image059.png" width="300" height="233" />
  <figcaption><span>Ilustração </span>: boxes in-line</figcaption>
</figure>



<p>
Blocos são formatados verticalmente um após o outro. In-lines são formatados horizontalmente.
</p>


<figure>
  <img src="image061.png" width="350" height="324" />
  <figcaption><span>Ilustração </span>: formatação em bloco e in-line</figcaption>
</figure>


<p>
Boxes in-line são dispostos dentro de linhas ou "boxes em linha". As linhas são no mínimo tão altas quanto o box mais alto, mas podem ser mais altas quando os boxes são dispostos em alinhamento "baseline", o que significa que a área da base de um elemento é alinhada a uma parte de outro box que não seja a base. Se a largura do recipiente não for suficiente, as in-lines serão dispostas em diversas linhas. Isso é o que costuma acontecer em um parágrafo.

</p>


<figure>
  <img src="image063.png" width="400" height="277" >
  <figcaption><span>Ilustração </span>: linhas</figcaption>
</figure>

<h3 id="Positioning">Posicionamento</h3>
<h4 id="Relative">Relativo</h4>
<p>
Posicionamento relativo - posicionado como de costume e movido para o delta solicitado.
</p>

<figure>
  <img src="image065.png" width="500" height="261" />
  <figcaption><span>Ilustração </span>: posicionamento relativo</figcaption>
</figure>

<h4 id="Floats">Floats</h4>
<p>
Um box em float é posicionado à esquerda ou direita de uma linha. O recurso interessante é que os outros boxes são posicionados em torno dele. O HTML:
<pre class="prettyprint">
&lt;p&gt;
  &lt;img style="float:right" src="images/image.gif" width="100" height="100"&gt;
  Lorem ipsum dolor sit amet, consectetuer...
&lt;/p&gt;
</pre>
Fica assim:
</p>


<figure>
  <img src="image067.png" width="444" height="203" />
  <figcaption><span>Ilustração </span>: float</figcaption>
</figure>


<h4 id="Absolute_and_fixed">Absoluto e fixo</h4>
<p>
O layout é definido exatamente, independentemente do fluxo normal. O elemento não participa do fluxo normal. As dimensões são relativas ao recipiente. Caso seja fixo, o recipiente é a janela de visualização.

<figure>
  <img src="image069.png" width="500" height="343" />
  <figcaption><span>Ilustração </span>: posicionamento fixo</figcaption>
</figure>


<br>
Observação: o box fixo não é movido, nem mesmo quando o documento é rolado.
</p>
<h3 id="Layered_representation">Representação em camadas</h3>
<p>
É especificada pela propriedade CSS z-index. Ela representa a terceira dimensão do box, sua posição no "eixo z".
</p>
<p>
Os boxes são divididos em <a id="stackingcontext">pilhas</a> (chamadas pilhas de contexto). Em cada pilha, os elementos de retorno são pintados em primeiro lugar e os elementos de avanço na parte superior, mais próximos ao usuário. Em caso de sobreposição, oculta o elemento anterior.
<br>
As pilhas são ordenadas de acordo com a propriedade z-index. Boxes com propriedade "z-index" de uma pilha local. A janela de visualização possui a pilha exterior.

<p>Exemplo:</p>

<pre class="prettyprint">
&lt;style type="text/css"&gt;
      div {
        position: absolute;
        left: 2in;
        top: 2in;
      }
&lt;/style&gt;

&lt;p&gt;
    &lt;div
         style="z-index: 3;background-color:red; width: 1in; height: 1in; "&gt;
    &lt;/div&gt;
    &lt;div
         style="z-index: 1;background-color:green;width: 2in; height: 2in;"&gt;
    &lt;/div&gt;
 &lt;/p&gt;
</pre>
Este será o resultado:
</p>


<figure>
  <img src="image071.png" width="254" height="227" />
  <figcaption><span>Ilustração </span>: posicionamento fixo</figcaption>
</figure>

<p>
Embora a div vermelha preceda a verde na marcação e devesse ser pintada antes em um fluxo normal, a propriedade z-index tem prioridade mais alta, então é movida adiante na pilha utilizada pelo box raiz.
</p>




<h3 id="Resources">Recursos</h3>
<div class="autonum">
  <ol>
      <li id="1">Arquitetura do navegador
          <ol>
              <li id="1_1">Grosskurth, Alan. <a href="http://grosskurth.ca/papers/browser-refarch.pdf">A Reference Architecture for Web Browsers (pdf)</a> (link em inglês)
              <li id="1_2">Gupta, Vineet. <a href="http://www.vineetgupta.com/2010/11/how-browsers-work-part-1-architecture/">How Browsers Work - Part 1 - Architecture</a> (link em inglês)
          </ol>

      <li id="2">Análise
          <ol>
              <li id="2_1">Aho, Sethi, Ullman, Compilers: Principles, Techniques, and Tools (também conhecido como "Dragon book"), Addison-Wesley, 1986
              <li id="2_2"> Rick Jelliffe. <a href="http://broadcast.oreilly.com/2009/05/the-bold-and-the-beautiful-two.html">The Bold and the Beautiful: two new drafts for HTML 5.</a> (link em inglês)
          </ol>

      <li id="3">Firefox
          <ol>
              <li id="3_1">L. David Baron, <a href="http://dbaron.org/talks/2008-11-12-faster-html-and-css/slide-6.xhtml">Faster HTML and CSS: Layout Engine Internals for Web Developers</a> (link em inglês).
              <li id="3_2">L. David Baron, <a href="https://www.youtube.com/watch?v=a2_6bGNZ7bA">Faster HTML and CSS: Layout Engine Internals for Web Developers (vídeo do Google tech talk)</a> (link em inglês)
              <li id="3_3">L. David Baron, <a href="http://www.mozilla.org/newlayout/doc/layout-2006-07-12/slide-6.xhtml">Mozilla's Layout Engine</a> (link em inglês)
              <li id="3_4">L. David Baron, <a href="http://www.mozilla.org/newlayout/doc/style-system.html">Mozilla Style System Documentation</a> (link em inglês)
              <li id="3_5">Chris Waterson, <a href="http://www.mozilla.org/newlayout/doc/reflow.html">Notes on HTML Reflow</a> (link em inglês)
              <li id="3_6">Chris Waterson, <a href="http://www.mozilla.org/newlayout/doc/gecko-overview.htm">Gecko Overview</a> (link em inglês)
              <li id="3_7">Alexander Larsson, <a href="https://developer.mozilla.org/en/The_life_of_an_HTML_HTTP_request">The life of an HTML HTTP request</a> (link em inglês)
          </ol>

      <li id="4">Webkit
          <ol>
              <li id="4_1">David Hyatt, <a href="http://weblogs.mozillazine.org/hyatt/archives/cat_safari.html">Implementing CSS (part 1)</a> (link em inglês)
              <li id="4_2">David Hyatt, <a href="http://weblogs.mozillazine.org/hyatt/WebCore/chapter2.html">An Overview of WebCore</a> (link em inglês)
              <li id="4_3">David Hyatt, <a href="http://webkit.org/blog/114/">WebCore Rendering</a> (link em inglês)
              <li id="4_5">David Hyatt, <a href="http://webkit.org/blog/66/the-fouc-problem/">The FOUC Problem</a> (link em inglês)
          </ol>

      <li id="5">Especificações W3C
          <ol>
              <li id="5_1"> <a href="http://www.w3.org/TR/html4/">HTML 4.01 Specification</a> (link em inglês)
              <li id="5_2"> <a href="http://dev.w3.org/html5/spec/Overview.html">W3C HTML5 Specification</a> (link em inglês)
              <li id="5_3"> <a href="http://www.w3.org/TR/CSS2/">Cascading Style Sheets Level 2 Revision 1 (CSS 2.1) Specification</a> (link em inglês)
          </ol>

      <li>Instruções sobre construção nos navegadores
          <ol>
              <li>Firefox. <a href="https://developer.mozilla.org/en/Build_Documentation">https://developer.mozilla.org/en/Build_Documentation</a> (link em inglês)
              <li>Webkit. <a href="http://webkit.org/building/build.html">http://webkit.org/building/build.html</a> (link em inglês)
          </ol>

  </ol>

  <!--  -->

</div>


</div>

<aside class="bio">

  <img align=left src="/static/images/profiles/taligarsiel.png">
  <p><a href="http://taligarsiel.com/">Tali Garsiel</a> (link em inglês) é uma desenvolvedora em Israel. Ela começou sua carreira como desenvolvedora da web em 2000 e familiarizou-se com o modelo "maligno" de camadas do Netscape. Como Richard Feynmann, ela era fascinada pela descoberta de como as coisas funcionam, então começou a pesquisar nas engrenagens dos navegadores e documentar o que descobria. Tali também publicou um <a href="http://taligarsiel.com/ClientSidePerformance.html">guia resumido sobre o desempenho do lado do cliente</a> (link em inglês). </p>

</aside>


<h4>Traduções</h4>
<p>Esta página foi traduzida para o japonês duas vezes. <a href="http://cou929.nu/docs/how-browsers-work/">How Browsers Work - Behind the Scenes of Modern Web Browsers (link em japonês)</a> por<a href="https://twitter.com/#!/_kosei_">@_kosei_</a> e também <a href="http://shanon-tech.blogspot.com/2011/09/web.html">ブラウザってどうやって動いてるの？（モダンWEBブラウザシーンの裏側</a> por <a href="https://twitter.com/#!/ikeike443">@ikeike443</a> e <a href="https://twitter.com/#!/kiyoto01">@kiyoto01</a>. Obrigado a todos!</p>


{% endblock %}
