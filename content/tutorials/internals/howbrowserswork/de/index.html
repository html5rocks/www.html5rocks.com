{% extends "tutorial.html" %}

{% block headauthor %}Tali Garsiel <tgarsiel@gmail.com>{% endblock %}
{% block pageauthor %}{% profilelinks taligarsiel paulirish %}{% endblock %}
{% block headtitle %}Funktionsweise von Browsern: Hinter den Kulissen moderner Webbrowser{% endblock %}
{% block pagetitle %}<b>Funktionsweise von Browsern: </b>Hinter den Kulissen moderner Webbrowser{% endblock %}
{% block head %}

{% endblock %}
{% block pagebreadcrumb %}Funktionsweise von Browsern: Hinter den Kulissen moderner Webbrowser{% endblock %}
{% block date %}16. August 2011{% endblock %}
{% block updated %}{% endblock %}
{% block onload %}{% endblock %}

{% block browsersupport %}
<span class="browser opera supported"><span class="browser_name">Opera</span><span class="support">unterstützt</span></span> <span class="browser ie supported"><span class="browser_name">Internet Explorer</span><span class="support">unterstützt</span></span> <span class="browser safari supported"><span class="browser_name">Safari</span><span class="support">unterstützt</span></span> <span class="browser ff supported"><span class="browser_name">Firefox</span><span class="support">unterstützt</span></span> <span class="browser chrome supported"><span class="browser_name">Chrome</span><span class="support">unterstützt</span></span>
{% endblock %}

{% block iscompatible %}

{% endblock %}


{% block content %}


<style>
  h1 b { display:block; font-size: 58px;}
  .browser_support, #html5badge, #html5badge + nav { display:none; }
  a[name] { color: currentColor; }
  blockquote { opacity: 0.9; border-left: 8px solid #ccc; padding-left: 20px; }
  body { line-height: 1.3; }
  li { margin: 3px 0;}
  h3 { font-size: 19px; }
  h4 { font-size: 15.5px; }
  h5 { font-size: 14px; }
  #stack { margin: 5px auto;}
  #stack td, #stack th { border-bottom: 1px dotted #999; }
  samp { background-color: #f2f2f2; border-radius: 2px; padding: 0 2px; }
  samp:empty { display:none; }
  ol.toc { padding-left: 20px; line-height: 1.1; }
  .autonum *:target { background: hsl(60, 73%, 93%);}
  cite { display:block; text-align: right; font-size: 80%; }
  figcaption span:after { content: attr(data-count) ; }

  .tocchap, .tocnum { cursor: default; }
  .tocchap { color: hsl(0, 0%, 60%); margin-bottom: 0; margin-top: 30px; }
  .tocchap + * { margin-top: 5px; }
  h2, h3, h4, h5 { position: relative; }
  .tocnum { position: absolute; left: -56px; width: 50px; text-align: right; font-size: 70%; top: 3px;
    color: hsl(0, 0%, 80%);
    -webkit-transition: all 0.3s ease-out;
       -moz-transition: all 0.3s ease-out;
        -ms-transition: all 0.3s ease-out;
         -o-transition: all 0.3s ease-out;
            transition: all 0.3s ease-out;
  }
  h2:hover .tocnum, h3:hover .tocnum, h4:hover .tocnum, h5:hover .tocnum { color: hsl(0, 0%, 20%); }
  .preface + hr + .tocchap { visibility: hidden;  }
  aside.bio  { border: 3px double hsl(0, 0%, 80%); padding: 10px; }
  aside.bio img { width: 70px; margin: 0 10px 0 0; border: 1px solid hsl(0, 0%, 50%); }
  aside.bio p { margin: 0; }
</style>
<script >
  [].forEach.call( document.querySelectorAll('header .date a'), function(elem, i) {
    elem.textContent += ' (' + ['author','editor'][i] + ')';
  });
</script>

<div class="preface">
<h2>Vorwort</h2>
<p>
  Dieser umfassende Leitfaden zu den internen Abläufen von WebKit und Gecko ist das Ergebnis intensiver Arbeit der israelischen Entwicklerin Tali Garsiel. Sie hat einige Jahre lang alle Veröffentlichungen zu Browser-Interna gesichtet <small>(siehe <a href="#Resources">Ressourcen</a>)</small> und eine Menge Zeit damit verbracht, Quellcodes von Webbrowsern zu lesen. Sie hat dazu Folgendes geschrieben:

  <blockquote>
    In Zeiten, als der Internet Explorer noch eine Dominanz von 90 % hatte, war der Browser so eine Art "Black Box". Aber jetzt, wo <a href="http://techcrunch.com/2011/08/01/open-web-browsers/">mehr als die Hälfte der Nutzer</a> Open Source-Browser verwenden, können wir einen Blick in ihr Innenleben werfen und uns ansehen, woraus ein Webbrowser eigentlich besteht. Nun, im Prinzip besteht er aus Millionen von C++-Zeilen ...
  </blockquote>
  Tali hat ihre Arbeit auf <a href="http://taligarsiel.com/">ihrer Website</a> veröffentlicht, aber wir waren der Meinung, dass sie ein größeres Publikum verdient, deshalb haben wir ihren Bericht etwas überarbeitet und hier nochmals veröffentlicht.

<p>
  Webentwickler <strong>können mit dem Wissen über die internen Abläufe von Browsern fundiertere Entscheidungen treffen und die Hintergründe von Best Practices für die Entwicklung kennenlernen</strong>. Nehmen Sie sich genug Zeit für dieses ausführliche Dokument. Wir garantieren, es lohnt sich.

  <cite>Paul Irish, Chrome Developer Relations</cite>


</div>

<hr>

<h2 id="Introduction">Einführung</h2>
<p>
Webbrowser sind wahrscheinlich die am häufigsten verwendete Software. In diesem Leitfaden möchte ich beschreiben, was hinter den Kulissen von Webbrowsern passiert. Wir werden uns ansehen, was eigentlich in der Zeit zwischen der Eingabe von <code>google.com</code> in die Adressleiste und der Darstellung der Google-Seite auf dem Browserbildschirm geschieht.
</p>

<h3>Inhaltsverzeichnis</h3>

<ol class="toc">
<li><a href="#Introduction">Einführung</a>
<ol>
  <li><a href="#The_browsers_we_will_talk_about">Die behandelten Browser</a></li>
  <li><a href="#The_browser_main_functionality">Hauptfunktion des Browsers</a></li>
  <li><a href="#The_browser_high_level_structure">Die High-Level-Struktur des Browsers</a></li>
</ol>
</li>
<li><a href="#The_rendering_engine">Das Rendering-Modul</a>
<ol>
  <li><a href="#Rendering_engines">Rendering-Module</a></li>
  <li><a href="#The_main_flow">Der Hauptablauf</a></li>
  <li><a href="#Main_flow_examples">Beispiele für den Hauptablauf</a></li>
</ol>
</li>
<li><a href="#Parsing_general">Konstruktion der Parsing- und DOM-Baumstruktur</a>
<ol>
  <li><a href="#Parsing_general">Parsing - allgemein</a>
  <ol>
      <li><a href="#Grammars">Grammatik</a></li>
      <li><a href="#Parser_Lexer_combination">Parser-Lexer-Kombination</a></li>
      <li><a href="#Translation">Übersetzung</a></li>
      <li><a href="#Parsing_example">Parsing-Beispiel</a></li>
      <li><a href="#Formal_definitions_for_vocabulary_and_syntax">Formale Definitionen für Vokabular und Syntax</a></li>
      <li><a href="#Types_of_parsers">Parser-Typen</a></li>
    <li><a href="#Generating_parsers_automatically">Automatisches Erstellen von Parsern</a></li>
  </ol>
  </li>
  <li><a href="#HTML_Parser">HTML-Parser</a>
  <ol>
      <li><a href="#The_HTML_grammar_definition">Definition der HTML-Grammatik</a></li>
      <li><a href="#Not_a_context_free_grammar">Keine kontextfreie Grammatik</a></li>
      <li><a href="#HTML_DTD">HTML-DTD</a></li>
    <li><a href="#DOM">DOM</a></li>
      <li><a href="#The_parsing_algorithm">Der Parsing-Algorithmus</a></li>
      <li><a href="#The_tokenization_algorithm">Der Tokenisierungs-Algorithmus</a></li>
    <li><a href="#Tree_construction_algorithm">Algorithmus zur Konstruktion der Baumstruktur</a></li>
      <li><a href="#Actions_when_the_parsing_is_finished">Aktionen nach dem Parsing</a></li>
      <li><a href="#Browsers_error_tolerance">Fehlertoleranz von Browsern</a></li>
  </ol>
  </li>
  <li><a href="#CSS_parsing">CSS-Parsing</a>
  <ol>
    <li><a href="#Webkit_CSS_parser">WebKit-CSS-Parser</a></li>
  </ol>
  </li>
  <li><a href="#The_order_of_processing_scripts_and_style_sheets">Die Organisation von Verarbeitungsskripts und Stylesheets</a>
  <ol>
      <li><a href="#Scripts">Skripts</a></li>
      <li><a href="#Speculative_parsing">Spekulatives Parsing</a></li>
      <li><a href="#Style_sheets">Stylesheets</a></li>
  </ol>
  </li>
</ol>
</li>
<li><a href="#Render_tree_construction">Konstruktion der Rendering-Baumstruktur</a>
<ol>
  <li><a href="#The_render_tree_relation_to_the_DOM_tree">Die Rendering-Struktur im Verhältnis zur DOM-Struktur</a></li>
  <li><a href="#The_flow_of_constructing_the_tree">Ablauf der Baumstruktur-Konstruktion</a></li>
  <li><a href="#Style_Computation">Stilberechnung</a>
<ol>
    <li><a href="#Sharing_style_data">Weitergabe von Stildaten</a></li>
    <li><a href="#Firefox_rule_tree">Firefox-Regelbaum</a>
<ol>
      <li><a href="#Division_into_structs">Unterteilung in Strukturen</a></li>
      <li><a href="#Computing_the_style_contexts_using_the_rule_tree">Berechnen der Stilkontexte mit dem Regelbaum</a></li>
    </ol>
</li>
    <li><a href="#Manipulating_the_rules_for_an_easy_match">Bearbeiten der Regeln für eine einfache Zuordnung</a></li>
<li><a href="#Applying_the_rules_in_the_correct_cascade_order">Anwendung der Regeln in der richtigen Kaskadenreihenfolge</a>
<ol>
    <li><a href="#Style_sheet_cascade_order">Kaskadierung von Stylesheets</a></li>
<li><a href="#Specificity">Spezifität</a></li>
<li><a href="#Sorting_the_rules">Sortieren der Regeln</a></li>
</ol>
</li>
</ol>
</li>
<li><a href="#Gradual_process">Schrittweiser Prozess</a></li>
</ol>
</li>
<li><a href="#Layout">Layout</a>
  <ol>
    <li><a href="#Dirty_bit_system">Dirty Bit-System</a></li>
    <li><a href="#Global_and_incremental_layout">Globales und inkrementelles Layout</a></li>
    <li><a href="#Asynchronous_and_Synchronous_layout">Asynchrones und synchrones Layout</a></li>
    <li><a href="#Optimizations">Optimierungen</a></li>
<li><a href="#The_layout_process">Der Layout-Prozess</a></li>
    <li><a href="#Width_calculation">Breitenberechnung</a></li>
    <li><a href="#Line_Breaking">Zeilenumbruch</a></li>
  </ol>
 </li>
<li><a href="#Painting">Painting</a>
  <ol>
    <li><a href="#Global_and_Incremental">Global und inkrementell</a></li>
    <li><a href="#The_painting_order">Painting-Reihenfolge</a></li>
    <li><a href="#Firefox_display_list">Firefox-Displayliste</a></li>
    <li><a href="#Webkit_rectangle_storage">WebKit-Rechteckspeicher</a></li>
  </ol>
 </li>
<li><a href="#Dynamic_changes">Dynamische Änderungen</a></li>
<li><a href="#The_rendering_engines_threads">Rendering-Modul-Threads</a>
<ol>
    <li><a href="#Event_loop">Ereignisschleife</a></li>
  </ol>
</li>
<li><a href="#css">Visuelles CSS2-Modell</a>
  <ol>
    <li><a href="#The_canvas">Canvas</a></li>
    <li><a href="#CSS_Box_model">CSS-Boxmodell</a></li>
    <li><a href="#Positioning_scheme">Positionierungsschema</a></li>
    <li><a href="#Box_types">Boxtypen</a></li>
<li><a href="#Positioning">Positionierung</a>
<ol>
      <li><a href="#Relative">Relativ</a></li>
      <li><a href="#Floats">Floats</a></li>
  <li><a href="#Absolute_and_fixed">Absolut und fest</a></li>
</ol>
</li>
<li><a href="#Layered_representation">Ebenendarstellung</a></li>
  </ol>
 </li>
<li><a href="#Resources">Ressourcen</a></li>
</ol>



<div>

<h3 id="The_browsers_we_will_talk_about">Die behandelten Browser</h3>
<p>
Zurzeit werden hauptsächlich fünf Browser verwendet: Internet Explorer, Firefox, Safari, Chrome und Opera. Ich möchte Beispiele von den Open Source-Browsern Firefox, Chrome und Safari (der teilweise Open Source ist) geben. Laut den <a href="http://gs.statcounter.com/">StatCounter-Browserstatistiken</a> verfügen Firefox, Safari und Chrome derzeit gemeinsam über einen Nutzungsanteil von fast 60 % (Stand August 2011). Open Source-Browser sind heutzutage also ein wesentlicher Teil der Browserwelt.
</p>

<h3 id="The_browser_main_functionality">Hauptfunktion des Browsers</h3>
<p>
Die Hauptfunktion des Browsers besteht darin, Ihnen Ihre ausgewählte Webressource zu zeigen, indem er sie vom Server abruft und im Browserfenster darstellt. Die Ressource ist normalerweise ein HTML-Dokument, es kann sich jedoch auch um PDF-Dateien, Bilder oder andere Formate handeln. Der Standort der Ressource wird vom Nutzer mithilfe einer URI (Uniform Resource Identifier) angegeben.
</p>
<p>
Die Art, wie der Browser HTML-Dateien interpretiert und darstellt, ist in den HTML- und CSS-Spezifikationen angegeben. Diese Spezifikationen werden vom World Wide Web Consortium <a id="w3c">W3C</a>, der Normungsorganisation für das Web, verwaltet. 
<br>
<!-- The current version of HTML is 4 (<a href="http://www.w3.org/TR/html401/">http://www.w3.org/TR/html401/</a>). Version 5 is in progress.
The current CSS version is 2 (<a href="http://www.w3.org/TR/CSS2/">http://www.w3.org/TR/CSS2/</a>) and version 3 is in progress.
<br> -->
Jahrelang haben Browser nur einen Teil der Spezifikationen befolgt und ihre eigenen Erweiterungen entwickelt. Dies führte zu ernsthaften Kompatibilitätsproblemen für Webautoren. Heute richten sich die meisten Browser mehr oder weniger nach den Spezifikationen.
</p>
<p>
Die Benutzeroberflächen der Browser haben viel gemeinsam. Zu den gängigen Benutzeroberflächen-Elementen gehören folgende:
<ul>
<li>Adressleiste zur Eingabe der URI</li>
<li>Zurück- und Vorwärts-Schaltflächen</li>
<li>Lesezeichenoptionen</li>
<li>Schaltflächen zum Aktualisieren und Anhalten, mit denen das Laden der aktuellen Dokumente neu gestartet bzw. beendet werden kann</li>
<li>Startseiten-Schaltfläche, über die Sie zu Ihrer Startseite gelangen</li>
</ul>

<p>
Seltsamerweise ist die Benutzeroberfläche von Browsern in keiner formalen Spezifikation definiert, sie hat sich mit den Jahren einfach aus bewährten Vorgehensweisen und gegenseitiger Nachahmung der Browser entwickelt. In der HTML5-Spezifikation werden keine Benutzeroberflächen-Elemente von Browsern definiert, aber einige häufig verwendete Elemente aufgeführt. Zu diesen gehören die Adressleiste, die Statusleiste und die Symbolleiste. Es gibt natürlich auch browserspezifische Funktionen wie etwa den Download-Manager von Firefox.
</p>
<h3 id="The_browser_high_level_structure">Die High-Level-Struktur des Browsers</h3>
<p>
Dies sind die Hauptkomponenten eines Browsers (<a href="#1_1">1.1</a>):
</p>

<ol>

  <li><strong>Die Benutzeroberfläche </strong> (User Interface, UI) - diese enthält die Adressleiste, Zurück- und Vorwärts-Schaltflächen, ein Lesezeichenmenü usw. Hierzu zählt jeder Teil der Browserdarstellung mit Ausnahme des Hauptfensters, in dem die angeforderte Seite angezeigt wird.</li>
  <li><strong>Das Browser-Modul </strong>- arrangiert die Aktionen zwischen der Benutzeroberfläche und dem Rendering-Modul.</li>
  <li><strong>Das Rendering-Modul</strong>- zuständig für die Darstellung des angeforderten Inhalts. Handelt es sich bei dem angeforderten Inhalt beispielsweise um HTML, ist das Modul dafür verantwortlich, den HTML- und CSS-Inhalt zu parsen und den geparsten Inhalt auf dem Bildschirm darzustellen.</li>
  <li><strong>Netzwerk </strong>- wird für Netzwerk-Aufrufe wie HTTP-Anforderungen verwendet. Es verfügt über eine plattformunabhängige Schnittstelle und zugrunde liegende Implementierungen für jede Plattform.</li>
  <li><strong>UI-Backend </strong>- wird zur Darstellung grundlegender Widgets wie Kombinationsfelder und Fenster verwendet. Es verfügt über eine generische Schnittstelle, die nicht plattformspezifisch ist. Darunter verwendet es die Benutzeroberflächenmethoden des Betriebssystems.</li>
  <li><strong>JavaScript-Interpreter</strong> - wird zum Parsen und Ausführen des JavaScript-Codes verwendet.</li>
  <li><strong>Datenspeicher</strong> - dies ist eine Persistenzebene. Der Browser muss alle möglichen Arten von Daten auf der Festplatte speichern, zum Beispiel Cookies. In der neuen HTML-Spezifikation (HTML5) wird die "Webdatenbank" definiert, bei der es sich um eine vollständige und dennoch schlanke Datenbank im Browser handelt.</li>

</ol>


<figure>
  <img src="layers.png" width="500" height="339" alt="" title="" />
  <figcaption><span>Abbildung </span>: Hauptkomponenten eines Browsers</figcaption>
</figure>


<p>
Beachten Sie, dass Chrome im Gegensatz zu den meisten Browsern über mehrere Instanzen des Rendering-Moduls verfügt - eine für jeden Tab. Jeder Tab stellt einen eigenen Prozess dar.
</p>

<h2 id="The_rendering_engine">Das Rendering-Modul</h2>
<p>
Die Aufgabe des Rendering-Moduls ist ... naja, das Rendern, also die angeforderten Inhalte auf dem Browserbildschirm darzustellen.
</p>
<p>
Das Rendering-Modul kann standardmäßig HTML- und XML-Dokumente sowie Bilder darstellen. Mithilfe eines Plug-ins oder einer Browsererweiterung kann es auch andere Formate darstellen, zum Beispiel PDF-Dokumente über ein PDF Viewer-Plug-in. In diesem Kapitel werden wir uns jedoch auf den Hauptanwendungsfall konzentrieren: die Darstellung von HTML und Bildern, die mit CSS formatiert wurden.</p>

<h3 id="Rendering_engines">Rendering-Module</h3>
<p>
Die Browser, mit denen wir uns beschäftigen - Firefox, Chrome und Safari - basieren auf zwei Rendering-Modulen. Firefox verwendet Gecko - ein "hausgemachtes" Rendering-Modul von Mozilla. Safari und Chrome verwenden beide WebKit.
</p>
<p>
WebKit ist ein Open Source-Rendering-Modul, das zunächst als Modul für die Linux-Plattform entwickelt und von Apple für den Support von Mac und Windows modifiziert wurde. Weitere Einzelheiten finden Sie unter <a href="http://webkit.org/">webkit.org</a>.
</p>

<h3 id="The_main_flow">Der Hauptablauf</h3>
<p>
Das Rendering-Modul beginnt mit dem Abrufen der Inhalte des angeforderten Dokuments aus der Netzwerkebene. Dies erfolgt üblicherweise in 8 K-Blöcken.
</p>
<p>
Anschließend sieht der grundlegende Ablauf des Rendering-Moduls wie folgt aus:

</p>

<figure>
  <img src="flow.png" width="600" height="66" alt="" title=""   />
  <figcaption><span>Abbildung </span>: Grundlegender Ablauf des Rendering-Moduls</figcaption>
</figure>


<p>
Das Rendering-Modul beginnt mit dem Parsen des HTML-Dokuments und wandelt die Tags in <a href="#DOM">DOM</a>-Knoten in einem sogenannten "Inhaltsbaum" um. Die Stildaten sowohl in externen CSS-Dateien als auch in Stilelementen werden geparst. Die Stilinformationen werden zusammen mit den visuellen Anweisungen im HTML-Code zum Erstellen einer weiteren Baumstruktur verwendet - der <a href="#Render_tree_construction">Rendering-Struktur</a>.
</p>
<p>
Die Rendering-Struktur enthält Rechtecke mit visuellen Attributen wie Farbe und Abmessungen. Die Rechtecke befinden sich in der richtigen Reihenfolge für die Darstellung auf dem Bildschirm.
</p>
<p>
Nach der Konstruktion der Rendering-Struktur folgt der "<a href="#layout">Layout</a>"-Prozess. Dabei werden jedem Knoten die genauen Koordinaten zugewiesen, an denen er auf dem Bildschirm erscheinen soll. Die nächste Phase ist das <a href="#Painting">Painting</a>. Dabei wird die Rendering-Struktur durchlaufen und jeder Knoten mithilfe der UI-Backend-Ebene dargestellt.
</p>
<p>
Wichtig ist hierbei, dass es sich um einen schrittweisen Prozess handelt. Für eine bessere Nutzererfahrung versucht das Rendering-Modul, Inhalte so schnell wie möglich auf dem Bildschirm darzustellen. Es wartet nicht, bis das gesamte HTML-Dokument geparst wurde, bevor es mit dem Aufbau und dem Layout der Rendering-Struktur beginnt. Teile des Inhalts werden geparst und dargestellt, während der Prozess mit den übrigen Inhalten, die vom Netzwerk eintreffen, weiterläuft.
</p>

<h4 id="Main_flow_examples">Beispiele für den Hauptablauf</h4>

  <figure>
    <img src="webkitflow.png" width="624" height="289" alt=""  />
    <figcaption><span>Abbildung </span>: Hauptablauf bei WebKit</figcaption>
  </figure>


  <figure>
    <img src="image008.jpg" width="624" height="290" alt="" />
    <figcaption><span>Abbildung </span>: Hauptablauf bei Mozillas Rendering-Modul Gecko (<a href="#3_6">3.6</a>)</figcaption>
  </figure>


<p>
Anhand der Abbildungen 3 und 4 können Sie erkennen, dass WebKit und Gecko zwar eine leicht unterschiedliche Terminologie verwenden, der Ablauf jedoch im Prinzip gleich ist.
<p>
Bei Gecko wird die Baumstruktur der visuell formatierten Elemente "Frame Tree" genannt. Jedes Element ist ein Frame. WebKit verwendet den Begriff "Render Tree", welcher aus "Render Objects" besteht. WebKit bezeichnet das Platzieren der Elemente als "Layout", während Gecko diesen Vorgang "Reflow" nennt. "Attachment" heißt bei WebKit die Verbindung von DOM-Knoten und visuellen Informationen zum Erstellen der Rendering-Struktur. Ein kleiner nicht semantischer Unterschied ist, dass Gecko zwischen dem HTML-Code und der DOM-Struktur über eine zusätzliche Ebene verfügt. Diese wird "Content Sink", also in etwa "Inhaltsbecken", genannt und dient der Herstellung von DOM-Elementen. Wir besprechen jede Phase des Ablaufs einzeln:
<p>
<h3 id="Parsing_general">Parsing - allgemein</h3>
<p>
Da das Parsing ein sehr wichtiger Prozess innerhalb des Rendering-Moduls ist, werden wir uns etwas genauer damit beschäftigen. Fangen wir mit einer kurzen Einführung zum Parsing an.
</p>
<p>
Beim Parsen eines Dokuments wird dieses in eine sinnvolle Struktur übersetzt, die der Code verstehen und verwenden kann. Das Ergebnis des Parsings ist normalerweise ein Knotenbaum, der die Struktur des Dokuments wiedergibt. Dieser wird auch Analyse- oder Syntaxbaum genannt.
</p>

<p>
Beispiel: Beim Parsen des Ausdrucks <samp>2 + 3 - 1</samp> könnte folgende Baumstruktur zurückgegeben werden:

</p>



<figure>
  <img src="image009.png" width="400" height="155" />
  <figcaption> <span>Abbildung </span>: Knotenbaum des mathematischen Ausdrucks</figcaption>
</figure>

<h4 id="Grammars">Grammatik</h4>
<p>
Das Parsing basiert auf den Syntaxregeln, die das Dokument befolgt - die Sprache bzw. das Format, in der/dem es erstellt wurde. Jedes Format, das geparst werden kann, muss über eine deterministische Grammatik aus Vokabular und Syntaxregeln verfügen. Diese wird als <a href="#context_free_grammar">kontextfreie Grammatik</a> bezeichnet. Die menschlichen Sprachen erfüllen diese Voraussetzungen nicht und können daher nicht mit konventionellen Parsing-Techniken analysiert werden.
</p>
<h4 id="Parser_Lexer_combination">Parser-Lexer-Kombination</h4>
<p>
Das Parsing kann in zwei Unterprozesse unterteilt werden: die lexikalische Analyse und die Syntaxanalyse.
</p>
<p>
Bei der lexikalischen Analyse wird die Eingabe in Tokens aufgeschlüsselt. Bei Tokens handelt es sich um das Vokabular der Sprache - die Sammlung gültiger Bausteine. In der menschlichen Sprache besteht dieses aus allen Wörtern, die im Wörterbuch dieser Sprache vorkommen.
</p>
<p>
Bei der Syntaxanalyse werden die Syntaxregeln der Sprache angewendet.
</p>
<p>
Parser teilen die Arbeit üblicherweise zwischen zwei Komponenten auf: dem <b>Lexer</b> (gelegentlich auch Tokenizer genannt), der für das Aufschlüsseln in gültige Tokens zuständig ist, und dem <b>Parser</b>, der für die Konstruktion der Parsing-Struktur verantwortlich ist. Dazu analysiert er die Dokumentstruktur gemäß den Syntaxregeln der Sprache. Der Lexer kann irrelevante Zeichen wie Leerzeichen und Zeilenumbrüche isolieren.
</p>

<figure>
  <img src="image011.png" width="101" height="300" />
  <figcaption>  <span>Abbildung </span>: Vom Quelldokument zur Parsing-Struktur</figcaption>
</figure>

<p>
Der Parsing-Prozess ist iterativ. Der Parser fordert vom Lexer normalerweise ein neues Token an und versucht, das Token einer Syntaxregel zuzuordnen. Wird eine passende Regel gefunden, wird ein dem Token entsprechender Knoten zur Parsing-Struktur hinzugefügt und der Parser fordert ein weiteres Token an.
<p>
Falls keine übereinstimmende Regel gefunden wird, speichert der Parser das Token intern und fordert weiter Tokens an, bis eine passende Regel für alle intern gespeicherten Tokens gefunden wird. Wird keine Regel gefunden, löst der Parser eine Ausnahme aus. Das bedeutet, dass das Dokument ungültig war und Syntaxfehler enthielt.
</p>
<h4 id="Translation">Übersetzung</h4>
<p>
Häufig ist die Parsing-Struktur nicht das Endprodukt. Parsing wird oft für die Übersetzung verwendet - die Umwandlung des Eingabedokuments in ein anderes Format. Ein Beispiel hierfür ist die Kompilierung. Der Compiler, der einen Quellcode in Computercode kompiliert, erstellt zunächst eine Parsing-Struktur und übersetzt diese dann in ein Computercode-Dokument.
</p>


<figure>
  <img src="image013.png" width="104" height="400" />
  <figcaption><span>Abbildung </span>: Ablauf einer Kompilierung</figcaption>
</figure>


<h4 id="Parsing_example">Parsing-Beispiel</h4>
<p>
In Abbildung 5 haben wir eine Parsing-Struktur auf der Grundlage eines mathematischen Ausdrucks erstellt. Nun versuchen wir, eine einfache mathematische Sprache zu definieren und uns den Parsing-Vorgang anzusehen.
<p>
<p>
Vokabular: Unsere Sprache kann Ganzzahlen, Pluszeichen und Minuszeichen enthalten.
</p>
<p>
Syntax:
<ol>
<li> Die Bausteine der Sprachsyntax sind "expressions" (Ausdrücke), "terms" (Terme) und "operations" (Operationen).
<li> Unsere Sprache kann beliebig viele Ausdrücke enthalten.</li>
<li> Ein Ausdruck wird als Term gefolgt von einer Operation gefolgt von einem weiteren Term definiert.</li>
<li> Eine Operation ist ein Plus-Token oder ein Minus-Token.</li>
<li> Ein Term ist ein Ganzzahl-Token oder ein Ausdruck.</li>
</ol>
</p>
<p>
  Analysieren wir nun die Eingabe <samp>2 + 3 - 1</samp>.
  <br>
  Der erste Unterstring, der einer Regel entspricht, ist <samp>2</samp>. Gemäß Regel Nr. 5 ist dies ein Term. Die zweite Übereinstimmung ist <samp>2 + 3</samp>. Diese entspricht der dritten Regel: ein Term gefolgt von einer Operation gefolgt von einem weiteren Term. Die nächste Übereinstimmung folgt erst am Ende der Eingabe. <samp>2 + 3 - 1</samp> ist ein Ausdruck, da wir bereits wissen, dass <samp>2+3</samp> ein Term ist. Das heißt, wir haben einen Term gefolgt von einer Operation gefolgt von einem weiteren Term. <samp>2 + + </samp>entspricht keiner Regel und ist daher keine gültige Eingabe.
</p>
<h4 id="Formal_definitions_for_vocabulary_and_syntax">Formale Definitionen für Vokabular und Syntax</h4>
<p>
Vokabular wird normalerweise durch <a href="http://www.regular-expressions.info/">reguläre Ausdrücke</a> repräsentiert.
</p>
<p>
Unsere Sprache wird beispielsweise folgendermaßen definiert:
<pre class="prettyprint">
INTEGER :0|[1-9][0-9]*
PLUS : +
MINUS: -
</pre>
Wie Sie sehen, werden die Ganzzahlen durch einen regulären Ausdruck definiert.
</p>
<p>
Syntax wird üblicherweise im Format <a href="http://de.wikipedia.org/wiki/Backus-Naur-Form">BNF</a> definiert. Die Definition unserer Sprache sieht so aus:
<pre class="prettyprint">
expression :=  term  operation  term
operation :=  PLUS | MINUS
term := INTEGER | expression
</pre>
</p>
<p>
Wir haben bereits festgestellt, dass eine Sprache von regulären Parsern analysiert werden kann, wenn sie eine <a id="context_free_grammar">kontextfreie Grammatik</a> besitzt. Eine intuitive Definition einer kontextfreien Grammatik ist eine Grammatik, die vollständig in BNF ausgedrückt werden kann. Eine formale Definition finden Sie im <a href="http://de.wikipedia.org/wiki/Kontextfreie_Grammatik">Wikipedia-Artikel zur kontextfreien Grammatik</a>.
<h4 id="Types_of_parsers">Parser-Typen</h4>
<p>
Es gibt zwei grundlegende Typen von Parsern: Top-down-Parser und Bottom-up-Parser. Eine intuitive Erklärung ist, dass Top-down-Parser die High-Level-Struktur der Syntax erkennen und diese zuzuordnen versuchen. Bottom-up-Parser beginnen mit der Eingabe und wandeln diese schrittweise in die Syntaxregeln um. Dabei beginnen sie mit den Regeln auf unterster Ebene und fahren fort, bis die Regeln auf oberster Ebene erfüllt sind.
</p>
<p>
Sehen wir uns an, wie die beiden Parser in unserem Beispiel arbeiten:
</p>
<p>
Der Top-down-Parser beginnt mit der Regel auf oberster Ebene: Er identifiziert <samp>2 + 3</samp> als Ausdruck. Anschließend erkennt er <samp>2 + 3 - 1</samp> als Ausdruck. Der Vorgang der Identifizierung des Ausdrucks führt zur Zuordnung der anderen Regeln, Ausgangspunkt ist aber die Regel auf oberster Ebene.
</p>
<p>
Der Bottom-up-Parser scannt die Eingabe, bis eine passende Regel gefunden wird, und ersetzt dann die übereinstimmende Eingabe durch die Regel. Dieser Vorgang wird bis zum Ende der Eingabe fortgesetzt. Der teilweise zugeordnete Ausdruck wird im Stapel des Parsers abgelegt.
<table id="stack">
  <tr><th>Stapel</th>                <th>Eingabe</th></tr>
  <tr><td>&nbsp;</td>               <td><samp>2 + 3 - 1 </samp></td></tr>
  <tr><td>Term</td>                 <td><samp> + 3 - 1 </samp></td></tr>
  <tr><td>Term - Operation</td>       <td><samp> 3 - 1 </samp></td></tr>
  <tr><td>Ausdruck</td>           <td><samp>- 1 </samp></td></tr>
  <tr><td>Ausdruck - Operation</td> <td><samp>1 </samp></td></tr>
  <tr><td>Ausdruck</td>           <td><samp>&nbsp; </samp></td></tr>
</table>
Diese Art von Bottom-up-Parser wird als Shift-Reduce-Parser bezeichnet, da die Eingabe nach rechts verschoben wird (stellen Sie sich einen Zeiger vor, der zuerst am Beginn der Eingabe angezeigt wird und dann nach rechts wandert) und schrittweise auf Syntaxregeln reduziert wird.
</p>
<h4 id="Generating_parsers_automatically">Automatisches Erstellen von Parsern</h4>
<p>
Es gibt Tools, die einen Parser für Sie erstellen können. Diese werden Parser-Generatoren genannt. Sie füttern sie mit der Grammatik Ihrer Sprache - dem Vokabular und den Syntaxregeln - und sie erstellen einen funktionierenden Parser. Das Erstellen eines Parsers erfordert tief greifende Kenntnisse des Parsings und es ist nicht einfach, manuell einen optimierten Parser zu erstellen. Parser-Generatoren können daher sehr nützlich sein.
</p>
<p>
<a id="parser_generators">WebKit</a> verwendet zwei bekannte Parser-Generatoren: <a href="http://en.wikipedia.org/wiki/Flex_lexical_analyser">Flex</a> zum Erstellen eines Lexers und <a href="http://www.gnu.org/software/bison/">Bison</a> zum Erstellen eines Parsers (sie begegnen Ihnen möglicherweise auch unter den Namen "Lex" und "Yacc"). Bei der Flex-Eingabe handelt es sich um eine Datei, die reguläre Ausdrucksdefinitionen der Tokens enthält. Bei der Bison-Eingabe handelt es sich um die Syntaxregeln der Sprache im BNF-Format.
</p>
<h3 id="HTML_Parser">HTML-Parser</h3>
<p>
HTML-Parser haben die Aufgabe, die HTML-Auszeichnungssprache zu analysieren und in eine Parsing-Struktur zu bringen.
</p>
<h4 id="The_HTML_grammar_definition">Definition der HTML-Grammatik</h4>
<p>
Das Vokabular und die Syntax von HTML sind in <a href="#w3c">Spezifikationen</a> der W3C-Organisation definiert. Die aktuelle Version ist HTML4. HTML5 ist bereits in Arbeit.
</p>
<h4 id="Not_a_context_free_grammar">Keine kontextfreie Grammatik</h4>
<p>
Wie in der Einführung zum Parsing bereits erwähnt, kann die Grammatiksyntax formal mithilfe von Formaten wie BNF definiert werden.
</p><p>
Leider sind die konventionellen Parser-Themen nicht auf HTML anwendbar (ich habe diese aber nicht nur aus Spaß erwähnt, sie kommen beim Parsen von CSS und JavaScript zum Einsatz). HTML kann nicht einfach durch eine kontextfreie Grammatik definiert werden, die Parser benötigen.
</p><p>
Es gibt ein formales Format zur Definition von HTML - DTD (Document Type Definition) - dies ist jedoch keine kontextfreie Grammatik.
</p><p>
Dies hört sich zunächst seltsam an. HTML ähnelt doch relativ stark XML. XML-Parser sind viele verfügbar. Es gibt eine XML-Variation von HTML - XHTML - wo also ist der Unterschied?
</p><p>
Der Unterschied ist, dass der HTML-Ansatz "nachsichtiger" ist. Sie können bestimmte Tags weglassen, die implizit hinzugefügt werden, oder manchmal sogar den Beginn oder das Ende von Tags auslassen. Insgesamt ist es eine "weiche" Syntax, im Gegensatz zur steifen und anspruchsvollen XML-Syntax.
</p><p>
Diese zunächst klein erscheinende Abweichung macht augenscheinlich einen Riesenunterschied. Einerseits ist dies der Hauptgrund für die Beliebtheit von HTML: HTML verzeiht Ihnen Ihre Fehler und macht Webautoren das Leben einfacher. Andererseits wird es dadurch schwierig, eine formale Grammatik zu schreiben. Zusammengefasst lässt sich also festhalten, dass HTML nicht einfach so geparst werden kann: nicht von konventionellen Parsern, da seine Grammatik nicht kontextfrei ist, und auch nicht von XML-Parsern.
</p>
<h4 id="HTML_DTD">HTML-DTD</h4>
<p>
Die HTML-Definition erfolgt in einem DTD-Format. Dieses Format wird für die Definition von Sprachen der <a href="http://de.wikipedia.org/wiki/Standard_Generalized_Markup_Language">SGML</a>-Familie verwendet. Das Format enthält Definitionen für alle zulässigen Elemente, ihre Attribute und die Hierarchie. Wie bereits erwähnt, bildet die HTML-DTD keine kontextfreie Grammatik.
</p>
<p>
Die DTD verfügt über verschiedene Variationen. Der strenge Modus hält sich ausschließlich an die Spezifikationen, aber andere Modi unterstützen auch Auszeichnungssprachen, die von Browsern in der Vergangenheit verwendet wurden. Sinn und Zweck ist hier die Abwärtskompatibilität mit älteren Inhalten. Die aktuelle strenge DTD finden Sie hier: <a href="http://www.w3.org/TR/html4/strict.dtd">www.w3.org/TR/html4/strict.dtd</a>.
</p>
<h4 id="DOM">DOM</h4>
<p>
Die Ausgabestruktur - der "Parsing-Baum" - ist eine Baumstruktur aus DOM-Element- und Attributknoten. DOM steht für Document Object Model. Dies ist die Objektdarstellung des HTML-Dokuments und die Schnittstelle von HTML-Elementen mit der Außenwelt, zum Beispiel JavaScript.
<br>
Stamm des Baums ist das "<a  href="http://www.w3.org/TR/1998/REC-DOM-Level-1-19981001/level-one-core.html#i-Document">Document</a>"-Objekt.
</p>
<p>
Die DOM-Struktur steht nahezu in einem Eins-zu-eins-Verhältnis zur Auszeichnungssprache. Nehmen wir beispielsweise diese Auszeichnungssprache:
<pre class="prettyprint">
&lt;html&gt;
  &lt;body&gt;
    &lt;p&gt;
      Hello World
    &lt;/p&gt;
    &lt;div&gt; &lt;img src="example.png"/&gt;&lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>
Diese würde in den folgenden DOM-Baum übersetzt:

</p>

<figure>
  <img src="image015.png" width="400" height="219"  />
  <figcaption>  <span>Abbildung </span>: DOM-Baum der Beispiel-Auszeichnungssprache</figcaption>
</figure>

<p>
Wie HTML wird DOM von der W3C-Organisation definiert. Die Spezifikation finden Sie unter <a href="http://www.w3.org/DOM/DOMTR">www.w3.org/DOM/DOMTR</a>. Es handelt sich um eine allgemeine Spezifikation zum Bearbeiten von Dokumenten. HTML-spezifische Elemente werden in einem speziellen Modul beschrieben. Die HTML-Definitionen finden Sie hier: <a href="http://www.w3.org/TR/2003/REC-DOM-Level-2-HTML-20030109/idl-definitions.html">www.w3.org/TR/2003/REC-DOM-Level-2-HTML-20030109/idl-definitions.html</a>.
</p>
<p>
Mit der Aussage, dass der Baum DOM-Knoten enthält, ist gemeint, dass er aus Elementen besteht, die eine der DOM-Schnittstellen implementieren. Browser verwenden konkrete Implementierungen, die über andere, vom Browser intern verwendete Attribute verfügen.
</p>
<h4 id="The_parsing_algorithm">Der Parsing-Algorithmus</h4>
<p>
Wie in den vorherigen Abschnitten dargestellt wurde, kann HTML nicht mit den regulären Top-down- oder Bottom-up-Parsern analysiert werden.
</p>
<p>
Aus folgenden Gründen:
<ol>
<li>Der nachsichtige Charakter der Sprache</li>
<li>Die Tatsache, dass Browser über eine traditionelle Fehlertoleranz zur Unterstützung bekannter Fälle von ungültiger HTML verfügen</li>
<li>Der Parsing-Prozess ist eintrittsinvariant. Normalerweise ändert sich die Quelle während des Parsings nicht. In HTML können jedoch durch Skript-Tags, die <code>document.write</code> enthalten, zusätzliche Tokens hinzugefügt werden. In diesem Fall wird die Eingabe durch den Parsing-Prozess geändert.</li>
</ol>
<p>
Da sie die regulären Parsing-Techniken nicht verwenden können, erstellen Browser benutzerdefinierte Parser für das HTML-Parsing.
</p>
<p>
Der <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/parsing.html">Parsing-Algorithmus ist in der HTML5-Spezifikation ausführlich beschrieben</a>. Der Algorithmus besteht aus zwei Phasen: Tokenisierung und Baumkonstruktion.
<p>
Die Tokenisierung ist die lexikalische Analyse, bei der die Eingabe in Tokens aufgeschlüsselt wird. Zu den HTML-Tokens gehören Start-Tags, End-Tags, Attributnamen und Attributwerte.
</p>
<p>
Der Tokenizer erkennt das Token, gibt es an den Konstruktor weiter, analysiert das nächste Zeichen zur Erkennung des nächsten Tokens usw. - bis zum Ende der Eingabe.
</p>

<figure>
  <img src="image017.png" width="308" height="400" />
  <figcaption><span>Abbildung </span>: HTML-Parsing-Ablauf (aus der HTML5-Spezifikation)</figcaption>
</figure>

<h4 id="The_tokenization_algorithm">Der Tokenisierungs-Algorithmus</h4>
<p>
Der Algorithmus gibt ein HTML-Token aus. Der Algorithmus wird als Zustandsautomat ausgedrückt. Jeder Zustand liest eines oder mehrere Zeichen des Eingabestreams und aktualisiert den nächsten Zustand entsprechend diesen Zeichen. Die Entscheidung wird vom aktuellen Tokenisierungszustand und vom Zustand der Baumkonstruktion beeinflusst. Das bedeutet, dass dasselbe Zeichen je nach aktuellem Zustand unterschiedliche Ergebnisse für den nächsten richtigen Zustand erzeugen kann. Der Algorithmus ist zu komplex, um ihn vollständig zu beschreiben. Sehen wir uns darum ein einfaches Beispiel an, das das Prinzip des Algorithmus verdeutlicht.

</p><p>

Einfaches Beispiel - Tokenisierung des folgenden HTML-Codes:

</p>

<pre class="prettyprint">
&lt;html&gt;
  &lt;body&gt;
    Hello world
  &lt;/body&gt;
&lt;/html&gt;
</pre>

<p>

Der Anfangszustand ist der "Data"-Zustand. Wenn das Zeichen <code>&lt;</code> auftaucht, ändert sich der Zustand in <b>"Tag open"</b>. Das Lesen eines Zeichens von <code>a-z</code> führt zur Erstellung eines Start-Tag-Tokens und der Zustand ändert sich in <b>"Tag name"</b>. Dieser Zustand bleibt bis zum Auftauchen des <code>&gt;</code>-Zeichens erhalten. Jedes Zeichen wird an den Namen des neuen Tokens angehängt. In unserem Fall ist das erstellte Token ein <code>html</code>-Token.

</p><p>

Sobald das <code>&gt;</code>-Tag erreicht wird, wird das aktuelle Token ausgegeben und der Zustand ändert sich wieder in <b>"Data"</b>. Das <code>&lt;body&gt;</code>-Tag wird ebenso gehandhabt. Bisher wurden das <code>html</code>- und das <code>body</code>-Tag ausgegeben. Wir befinden uns jetzt wieder im <b>"Data"</b>-Zustand. Das Lesen des <code>H</code>-Zeichens in <code>Hello world</code> löst die Erstellung und Ausgabe eines Zeichen-Tokens aus. Dies wird solange fortgesetzt, bis <code>&lt;</code> von <code>&lt;/body&gt;</code> erreicht wird. Für jedes Zeichen in <code>Hello world</code> wird ein Zeichen-Token ausgegeben.

</p><p>

Wir befinden uns jetzt wieder im Zustand <b>"Tag open"</b>. Die Analyse der nächsten Eingabe, <code>/</code>, führt zum Erstellen eines <code>end tag token</code>. Dabei ändert sich der Zustand in <b>"Tag name"</b>. Wir bleiben wieder in diesem Zustand, bis wir <code>&gt;</code> erreichen. Dann wird das neue Tag-Token ausgegeben und wir kehren zum <b>"Data"</b>-Zustand zurück. Die <code>&lt;/html&gt;</code>-Eingabe wird ebenso gehandhabt.

</p>

<figure>
  <img src="image019.png" width="627" height="387" >
  <figcaption><span>Abbildung </span>: Tokenisierung der Beispieleingabe</figcaption>
</figure>

<h4 id="Tree_construction_algorithm">Algorithmus zur Konstruktion der Baumstruktur</h4>
<p>
Wenn der Parser erstellt wird, wird auch das "Document"-Objekt erstellt. Während der Baumkonstruktion wird der DOM-Baum mit dem "Document"-Objekt im Stamm geändert und es werden Elemente hinzugefügt. Jeder vom Tokenizer ausgegebene Knoten wird vom Baumkonstruktor verarbeitet. Die Spezifikation definiert für jedes Token, welches DOM-Element für dieses Token relevant ist und dafür erstellt wird. Das Element wird nicht nur zum DOM-Baum, sondern auch zu einem Stapel offener Elemente hinzugefügt. Dieser Stapel wird zur Korrektur verschachtelter Abweichungen und nicht geschlossener Tags verwendet. Der Algorithmus wird auch als Zustandsautomat beschrieben. Die Zustände werden Einfügemodi genannt.
</p>

<p>
Sehen wir uns den Ablauf der Baumkonstruktion für unsere Beispieleingabe an:
</p>


<pre class="prettyprint">
&lt;html&gt;
  &lt;body&gt;
    Hello world
  &lt;/body&gt;
&lt;/html&gt;
</pre>

<p>
Die Eingabe in der Phase der Baumkonstruktion ist eine Abfolge von Tokens aus der Tokenisierungsphase. Der erste Zustand ist <b>"initial mode"</b>. Der Empfang des "html"-Tokens löst einen Wechsel in den Modus <b>"before html"</b> und eine erneute Verarbeitung des Tokens in diesem Modus aus. Dabei entsteht das "HTMLHtmlElement", das an das "Document"-Objekt im Stamm angehängt wird.

</p><p>

Der Zustand ändert sich in <b>"before head"</b>. Das "body"-Token wird empfangen. Obwohl kein "head"-Token verfügbar ist, wird ein "HTMLHeadElement" implizit erstellt und zum Baum hinzugefügt.

</p><p>

Es folgen der <b>"in head"</b>-Modus und anschließend der <b>"after head"</b>-Modus. Das "body"-Token wird erneut verarbeitet, ein "HTMLBodyElement" wird erstellt und eingefügt und der Modus ändert sich in <b>"in body"</b>.

</p><p>

Nun werden die Zeichen-Tokens des "Hello world"-Strings empfangen. Das erste löst das Erstellen und Einfügen eines "Text"-Knotens aus. Die anderen Zeichen werden an diesen Knoten angehängt.

</p><p>

Durch den Empfang des "body"-End-Tokens ändert sich der Modus in <b>"after body"</b>. Nun wird das "html"-End-Tag empfangen, mit dem sich der Modus in <b>"after after body"</b> ändert. Mit dem Empfang des Dateiende-Tokens wird das Parsing beendet.
</p>

<figure>
  <img src="image022.gif" width="532" height="769" />
  <figcaption><span>Abbildung </span>: Baumkonstruktion des HTML-Beispiels</figcaption>
</figure>


<h4 id="Actions_when_the_parsing_is_finished">Aktionen nach dem Parsing</h4>
<p>
In dieser Phase markiert der Browser das Dokument als interaktiv und beginnt mit dem Parsing von Skripts im "deferred"-Modus. Das sind Skripts, die nach dem Parsen des Dokuments ausgeführt werden sollen. Der Dokumentzustand wird auf "complete" gesetzt und ein "load"-Ereignis wird ausgelöst.
</p>

<p>
Sie können sich <a href="http://www.w3.org/TR/html5/syntax.html#html-parser">die vollständigen Algorithmen für die Tokenisierung und Baumkonstruktion in der HTML5-Spezifikation</a> ansehen.
</p>

<h4 id="Browsers_error_tolerance">Fehlertoleranz von Browsern</h4>
<p>
Sie erhalten auf einer HTML-Seite nie einen Fehler über eine ungültige Syntax. Die Browser korrigieren ungültigen Inhalt einfach und fahren fort.

</p><p>
HTML-Beispiel:

</p>

<pre class="prettyprint">
&lt;html&gt;
  &lt;mytag&gt;
  &lt;/mytag&gt;
  &lt;div&gt;
  &lt;p&gt;
  &lt;/div&gt;
    Really lousy HTML
  &lt;/p&gt;
&lt;/html&gt;
</pre>

<p>

Ich habe hier sicherlich unzählige Regeln verletzt. So ist "mytag" zum Beispiel kein Standard-Tag und die "p"- und "div"-Elemente sind falsch verschachtelt. Der Browser zeigt das Ganze dennoch richtig an, ohne sich zu beschweren. Im Parser-Code wird also ein Großteil der Fehler des HTML-Autors korrigiert.

</p><p>

Die Fehlerbehandlung erfolgt in allen Browsern relativ ähnlich, ist jedoch erstaunlicherweise nicht Teil der aktuellen HTML-Spezifikation. Wie das Setzen von Lesezeichen und die Zurück-/Vorwärts-Schaltflächen ist es eine Eigenschaft, die sich mit der Zeit in Browsern entwickelt hat. Es gibt bekannte ungültige HTML-Konstrukte, die auf vielen Websites vorkommen, und die Browser versuchen diese in Übereinstimmung mit anderen Browsern zu beheben.

</p><p>

In der HTML5-Spezifikation werden allerdings einige dieser Voraussetzungen definiert. In WebKit wird dies im Kommentar zu Beginn der HTML-Parser-Klasse gut zusammengefasst:

</p>

<blockquote>
<p>Der Parser analysiert die tokenisierte Eingabe im Dokument und erstellt die Dokumentstruktur. Wenn das Dokument wohlgeformt ist, ist das Parsing einfach.</p>

<p>Leider treffen wir auf viele HTML-Dokumente, die nicht wohlgeformt sind, darum muss der Parser über eine gewisse Fehlertoleranz verfügen.</p>

<p>Wir müssen mindestens die folgenden Fehlerzustände berücksichtigen:</p>

<ol>
  <li>Das hinzugefügte Element ist innerhalb eines äußeren Tags ausdrücklich nicht zulässig. In diesem Fall schließen wir alle Tags bis zu dem Tag, in dem das Element nicht zulässig ist, und fügen es danach hinzu.
  <li>Das direkte Hinzufügen eines Elements ist nicht zulässig. Es ist möglich, dass der Autor des Dokuments ein Tag dazwischen vergessen hat (oder dass das Tag dazwischen optional ist). Dies könnte bei folgenden Tags der Fall sein: HTML HEAD BODY TBODY TR TD LI (habe ich eines vergessen?).
  <li>Wir möchten ein Block-Element innerhalb eines Inline-Elements hinzufügen. Alle Inline-Elemente bis zum nächsthöheren Block-Element werden geschlossen.
  <li>Falls dies nicht hilft, schließen wir solange Elemente, bis wir das Element hinzufügen oder das Tag ignorieren können.
</ol>

</blockquote>

<p>
Beispiele für die WebKit-Fehlertoleranz:
</p>
<h5>&lt;/br&gt; anstelle von &lt;br&gt;</h5>
<p>
Manche Websites verwenden &lt;/br&gt; anstelle von &lt;br&gt;. Für die Kompatibilität mit IE und Firefox behandelt WebKit diese Elemente wie &lt;br&gt;.
<br>
Der Code:
<pre class="prettyprint">
if (t->isCloseTag(brTag) && m_document->inCompatMode()) {
     reportError(MalformedBRError);
     t->beginTag = true;
}
</pre>
Hinweis: Die Fehlerbehandlung erfolgt intern und wird dem Nutzer nicht angezeigt.
</p>
<h5>Verirrte Tabelle</h5>
<p>
Eine verirrte Tabelle ist eine Tabelle innerhalb anderer Tabelleninhalte, aber nicht innerhalb einer Tabellenzelle.
<br>
Beispiel:
<pre class="prettyprint">
&lt;table&gt;
    &lt;table&gt;
        &lt;tr&gt;&lt;td&gt;inner table&lt;/td&gt;&lt;/tr&gt;
    &lt;/table&gt;
    &lt;tr&gt;&lt;td&gt;outer table&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
</pre>
WebKit ändert die Hierarchie in zwei gleichgeordnete Tabellen:
<pre class="prettyprint">
&lt;table&gt;
    &lt;tr&gt;&lt;td&gt;outer table&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
&lt;table&gt;
    &lt;tr&gt;&lt;td&gt;inner table&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
</pre>
Der Code:
<pre class="prettyprint">
if (m_inStrayTableContent && localName == tableTag)
        popBlock(tableTag);
</pre>
WebKit verwendet einen Stapel für die aktuellen Elementinhalte und löst die innere Tabelle aus dem Stapel der äußeren Tabelle heraus. Die Tabellen sind jetzt gleichgeordnet.
</p>
<h5>Verschachtelte Formularelemente</h5>
<p>
Falls der Nutzer ein Formular innerhalb eines anderen Formulars platziert, wird das zweite Formular ignoriert.
<br>
Der Code:
<pre class="prettyprint">
if (!m_currentFormElement) {
        m_currentFormElement = new HTMLFormElement(formTag,    m_document);
}
</pre>
</p>
<h5>Zu tiefe Tag-Hierarchie</h5>
<p>
Der Kommentar sagt alles:
<br>
<div class="comment">
<blockquote>
www.liceo.edu.mx ist ein Beispiel für eine Website, auf der bis zu 1500 Tags verschachtelt sind, alle über ein Bündel aus &lt;b&gt;s. Wir erlauben nur maximal zwanzig verschachtelte Tags desselben Typs, bevor wir sie einfach alle ignorieren.
</blockquote>
</div>
<pre class="prettyprint">
bool HTMLParser::allowNestedRedundantTag(const AtomicString& tagName)
{

unsigned i = 0;
for (HTMLStackElem* curr = m_blockStack;
         i &lt; cMaxRedundantTagDepth && curr && curr->tagName == tagName;
     curr = curr->next, i++) { }
return i != cMaxRedundantTagDepth;
}
</pre>
</p>
<h5>Falsch platzierte "html"- oder "body"-End-Tags</h5>
<p>
Auch hier sagt der Kommentar alles:

<blockquote>
Unterstützung wirklich fehlerhafter "html"-Tags. Wir schließen das "body"-Tag nie, da einige begriffsstutzige Webseiten es vor dem eigentlichen Ende des Dokuments schließen. Verlassen wir uns doch auf den "end()"-Aufruf zum endgültigen Schließen.
</blockquote>

<pre class="prettyprint">
if (t->tagName == htmlTag || t->tagName == bodyTag )
        return;

</pre>
Webautoren also aufgepasst: Solange Sie nicht als Beispiel in einem Code-Snippet zur Fehlertoleranz von WebKit auftauchen möchten, empfiehlt es sich, wohlgeformten HTML-Code zu schreiben.
</p>
<p>

<h3 id="CSS_parsing">CSS-Parsing</h3>
<p>
Erinnern Sie sich noch an die Parsing-Konzepte aus der Einführung? Im Gegensatz zu HTML handelt es sich bei CSS um eine kontextfreie Grammatik, die mit den in der Einführung beschriebenen Parsertypen analysiert werden kann. Tatsächlich werden in der <a href="http://www.w3.org/TR/CSS2/grammar.html">CSS-Spezifikation die lexikalische Grammatik und die Syntax-Grammatik von CSS definiert</a>.
</p>
<p>
Sehen wir uns einige Beispiele an:
<br>
Die lexikalische Grammatik (das Vokabular) wird durch reguläre Ausdrücke für jedes Token definiert:
<pre>
comment   \/\*[^*]*\*+([^/*][^*]*\*+)*\/
num   [0-9]+|[0-9]*"."[0-9]+
nonascii  [\200-\377]
nmstart   [_a-z]|{nonascii}|{escape}
nmchar    [_a-z0-9-]|{nonascii}|{escape}
name    {nmchar}+
ident   {nmstart}{nmchar}*
</pre>
<p>
"ident" steht für Identifier, etwa einen Klassennamen. "name" ist eine Element-ID (auf die mit "#" verwiesen wird).
</p>
<p>
Die Syntax-Grammatik ist in BNF beschrieben.
<pre class="prettyprint lang-css">
ruleset
  : selector [ ',' S* selector ]*
    '{' S* declaration [ ';' S* declaration ]* '}' S*
  ;
selector
  : simple_selector [ combinator selector | S+ [ combinator? selector ]? ]?
  ;
simple_selector
  : element_name [ HASH | class | attrib | pseudo ]*
  | [ HASH | class | attrib | pseudo ]+
  ;
class
  : '.' IDENT
  ;
element_name
  : IDENT | '*'
  ;
attrib
  : '[' S* IDENT S* [ [ '=' | INCLUDES | DASHMATCH ] S*
    [ IDENT | STRING ] S* ] ']'
  ;
pseudo
  : ':' [ IDENT | FUNCTION S* [IDENT S*] ')' ]
  ;
</pre>
Erklärung: Diese Struktur ist ein Regelsatz (ruleset):
<pre class="prettyprint lang-css">
div.error , a.error {
  color:red;
  font-weight:bold;
}
</pre>
"div.error" und "a.error" sind Selektoren. Der Teil innerhalb der geschweiften Klammern enthält die Regeln, die von diesem Regelsatz angewendet werden. Diese Struktur wird in der folgenden Definition formal definiert:
<pre class="prettyprint lang-css">
ruleset
  : selector [ ',' S* selector ]*
    '{' S* declaration [ ';' S* declaration ]* '}' S*
  ;
</pre>
Das heißt, ein Regelsatz besteht aus einem Selektor oder optional mehreren Selektoren, getrennt durch Komma und Leerzeichen. "S" steht hierbei für Leerzeichen (White Space). Ein Regelsatz enthält geschweifte Klammern, in denen sich eine Deklaration oder optional mehrere Deklarationen getrennt durch ein Semikolon befinden. "declaration" und "selector" werden in den nachfolgenden BNF-Definitionen definiert.
</p>
<h4 id="Webkit_CSS_parser">WebKit-CSS-Parser</h4>
<p>
WebKit verwendet die Parser-Generatoren <a href="#parser_generators">Flex und Bison</a>, um aus den CSS-Grammatikdateien automatisch Parser zu erstellen. Wie in der Einführung zu Parsern bereits erläutert, erstellt Bison einen Bottom-up-Shift-Reduce-Parser. Firefox verwendet einen manuell erstellten Top-down-Parser. In beiden Fällen wird jede CSS-Datei in ein Stylesheet-Objekt geparst und jedes Objekt enthält CSS-Regeln. Die CSS-Regelobjekte enthalten Selektor- und Deklarationsobjekte sowie weitere Objekte, die der CSS-Grammatik entsprechen.
</p>

<figure>
  <img src="image023.png" width="500" height="393" alt="" title="" border="0" align=""  />
  <figcaption><span>Abbildung </span>: CSS-Parsing</figcaption>
</figure>


<h3 id="The_order_of_processing_scripts_and_style_sheets">Die Organisation von Verarbeitungsskripts und Stylesheets</h3>
<h4 id="Scripts">Skripts</h4>
<p>
Das Modell des Web ist synchron. Autoren erwarten, dass Skripts sofort geparst und ausgeführt werden, wenn der Parser ein &lt;script&gt;-Tag erreicht. Das Parsing des Dokuments wird angehalten, bis das Skript ausgeführt wurde. Bei einem externen Skript muss zunächst die Ressource aus dem Netzwerk abgerufen werden. Dies erfolgt ebenfalls synchron und das Parsing wird pausiert, bis die Ressource abgerufen wurde. Dies war viele Jahre lang das Modell, das auch in den HTML4- und HTML5-Spezifikationen definiert ist. Autoren konnten ein Skript als "defer" markieren, damit das Dokument-Parsing nicht angehalten und das Skript erst nach dem Parsen ausgeführt wird. HTML5 bietet nun auch die Option, ein Skript als asynchron zu markieren, sodass es von einem anderen Thread geparst und ausgeführt wird.
</p>
<h4 id="Speculative_parsing">Spekulatives Parsing</h4>
<p>
Sowohl WebKit als auch Firefox verfügen über diese Optimierung. Beim Ausführen von Skripts wird der Rest des Dokuments von einem anderen Thread geparst, der ermittelt, welche anderen Ressourcen aus dem Netzwerk geladen werden müssen, und diese lädt. Auf diese Weise können Ressourcen auf parallelen Verbindungen geladen werden, wodurch sich die Gesamtgeschwindigkeit verbessert. Hinweis: Der spekulative Parser ändert den DOM-Baum nicht - dies überlässt er dem Hauptparser - er analysiert lediglich Verweise auf externe Ressourcen wie externe Skripts, Stylesheets und Bilder.
</p>
<h4 id="Style_sheets">Stylesheets</h4>
<p>
Stylesheets weisen dagegen ein anderes Modell auf. Da Stylesheets die DOM-Struktur nicht verändern, scheint es zunächst keinen Grund zu geben, auf sie zu warten und das Parsen des Dokuments anzuhalten. Es gibt jedoch das Problem, dass Skripts während des Dokument-Parsings Stilinformationen anfordern. Wurde der Stil noch nicht geladen und geparst, erhält das Skript falsche Antworten und dies führt offensichtlich zu einer Reihe von Problemen. Dies hört sich nach einer Randerscheinung an, tritt aber tatsächlich ziemlich häufig auf. Firefox blockiert alle Skripts, wenn ein Stylesheet noch geladen und geparst wird. WebKit blockiert Skripts nur, wenn sie auf bestimmte Stileigenschaften zugreifen möchten, die von nicht geladenen Stylesheets ausgeführt werden könnten.
</p>
<h3 id="Render_tree_construction">Konstruktion der Rendering-Baumstruktur</h3>
<p>
Während der Konstruktion des DOM-Baums konstruiert der Browser eine weitere Baumstruktur: die Rendering-Struktur. Diese Baumstruktur enthält visuelle Elemente in der Reihenfolge, in der sie später angezeigt werden. Dies ist die visuelle Darstellung des Dokuments. Zweck dieser Struktur ist es, das Darstellen der Inhalte in der richtigen Reihenfolge zu ermöglichen.
</p>
<p>
Bei Firefox werden die Elemente in der Rendering-Struktur als "Frames" bezeichnet. WebKit verwendet den Ausdruck "Renderer" oder "Render Object".
<br>
Ein Renderer weiß, wie er sich und seine untergeordneten Elemente anordnet und darstellt.
<br>
Die "RenderObject"-Klasse von WebKit, die Renderer-Basisklasse, wird folgendermaßen definiert:
<pre class="prettyprint">
class RenderObject{
  virtual void layout();
  virtual void paint(PaintInfo);
  virtual void rect repaintRect();
  Node* node;  //the DOM node
  RenderStyle* style;  // the computed style
  RenderLayer* containgLayer; //the containing z-index layer
}
</pre>
</p>
<p>
Jeder Renderer steht für einen rechteckigen Bereich, der normalerweise der CSS-Box des Knotens entspricht, wie in der CSS2-Spezifikation beschrieben. Er enthält geometrische Informationen wie Breite, Höhe und Position.
<br>
Der Boxtyp richtet sich nach dem "display"-Stilattribut, das für den Knoten relevant ist (siehe Abschnitt <a href="#style_computation">Stilberechnung</a>). Hier ist der WebKit-Code, mit dem entschieden wird, welche Art von Renderer gemäß dem "display"-Attribut für einen DOM-Knoten erstellt werden soll:
<pre class="prettyprint">
RenderObject* RenderObject::createObject(Node* node, RenderStyle* style)
{
    Document* doc = node->document();
    RenderArena* arena = doc->renderArena();
    ...
    RenderObject* o = 0;

    switch (style->display()) {
        case NONE:
            break;
        case INLINE:
            o = new (arena) RenderInline(node);
            break;
        case BLOCK:
            o = new (arena) RenderBlock(node);
            break;
        case INLINE_BLOCK:
            o = new (arena) RenderBlock(node);
            break;
        case LIST_ITEM:
            o = new (arena) RenderListItem(node);
            break;
       ...
    }

    return o;
}
</pre>
Der Elementtyp wird ebenfalls berücksichtigt. So verfügen beispielsweise Formularsteuerelemente und Tabellen über spezielle Frames.
<br>
Falls in WebKit ein Element einen speziellen Renderer erstellten möchte, wird die <code>createRenderer</code>-Methode überschrieben. Die Renderer verweisen auf Stilobjekte, die die nicht geometrischen Informationen enthalten.
</p>
<h5 id="The_render_tree_relation_to_the_DOM_tree">Die Rendering-Struktur im Verhältnis zur DOM-Struktur</h5>
Die Renderer entsprechen den DOM-Elementen, es handelt es sich jedoch nicht um ein Eins-zu-eins-Verhältnis. Nicht visuelle DOM-Elemente werden nicht in die Rendering-Struktur aufgenommen. Ein Beispiel hierfür ist das "head"-Element. Elemente, deren "display"-Attribut auf "none" gesetzt wurde, erscheinen ebenfalls nicht in der Struktur. Elemente mit dem Sichtbarkeitsattribut "hidden" werden dagegen aufgenommen.
</p>
<p>
Es gibt DOM-Elemente, die verschiedenen visuellen Objekten entsprechen. Dies sind üblicherweise Elemente mit einer komplexen Struktur, die nicht durch ein einzelnes Rechteck beschrieben werden können. Das Auswahlelement "select" verfügt beispielsweise über drei Renderer: einen für den Darstellungsbereich, einen für das Dropdown-Listenfeld und einen für die Schaltfläche. Auch wenn Text in mehrere Zeilen aufgeteilt wird, weil die Breite für eine Zeile nicht ausreicht, werden die neuen Zeilen als zusätzliche Renderer hinzugefügt.
<br>
Ein weiteres Beispiel für mehrere Renderer ist fehlerhafte HTML. Laut der CSS-Spezifikation darf ein Inline-Element entweder nur Block-Elemente oder nur Inline-Elemente enthalten. Werden diese Elemente gemischt, werden anonyme Block-Renderer erstellt, um die Inline-Elemente zu umschließen.
</p>
<p>
Einige Rendering-Objekte entsprechen einem DOM-Knoten, jedoch nicht an derselben Position in der Baumstruktur. Float-Elemente und absolut positionierte Elemente stehen außerhalb des Ablaufs. Sie werden an einer anderen Stelle der Struktur platziert und dem echten Frame zugeordnet. An ihrer Stelle wird ein Platzhalter-Frame angezeigt.
</p>

<a id="rendertree"></a>

  <figure>
      <img src="image025.png" width="731" height="396" >
    <figcaption><span>Abbildung </span>: Die Rendering-Struktur und die entsprechende DOM-Struktur (<a href="#3_1">3.1</a>). "Viewport" ist der ursprüngliche übergeordnete Block. In WebKit ist dies das "RenderView"-Objekt.</figcaption>
  </figure>



<h5 id="The_flow_of_constructing_the_tree">Ablauf der Baumstruktur-Konstruktion</h5>
<p>
In Firefox wird die Darstellung als Listener für DOM-Updates registriert. Die Darstellung delegiert die Frame-Erstellung an den <code>FrameConstructor</code> und der Konstruktor löst den Stil auf (siehe <a href="#style">Stilberechnung</a>) und erstellt einen Frame.
</p>
<p>
In WebKit werden das Auflösen des Stils und das Erstellen eines Renderers als "Attachment" (Anhängen) bezeichnet. Jeder DOM-Knoten verfügt über eine "attach"-Methode. Das Anhängen erfolgt synchron, durch das Einfügen des Knotens in die DOM-Struktur wird die "attach"-Methode des neuen Knotens aufgerufen.
<p>
Mit der Verarbeitung der "html"- und "body"-Tags wird der Stamm der Rendering-Struktur konstruiert. Das Stamm-Rendering-Objekt entspricht dem übergeordneten Block in der CSS-Spezifikation - dem obersten Block, der alle anderen Blöcke enthält. Seine Abmessungen stellen den Viewport dar: die Abmessungen des Darstellungsbereichs des Browserfensters. In Firefox wird dies als <code>ViewPortFrame</code> und in WebKit als <code>RenderView</code> bezeichnet. Dies ist das Rendering-Objekt, auf das das Dokument verweist. Der Rest der Baumstruktur wird durch das Einfügen von DOM-Knoten erstellt.
</p>
<p>
Weitere Informationen finden Sie in der <a href="http://www.w3.org/TR/CSS21/intro.html#processing-model">CSS2-Spezifikation zum Verarbeitungsmodell</a>.
</p>


<h4 id="Style_Computation">Stilberechnung</h4>
<p>
Zum Erstellen der Rendering-Struktur müssen die visuellen Eigenschaften jedes Rendering-Objekts berechnet werden. Dies erfolgt durch die Berechnung der Stileigenschaften jedes Elements.
</p>
<p>
Der Stil umfasst Stylesheets verschiedener Ursprünge, Inline-Stilelemente und visuelle Eigenschaften in der HTML, etwa die "bgcolor"-Eigenschaft. Letztere wird so übersetzt, dass sie den CSS-Stileigenschaften entspricht.
</p>
<p>
Die Stylesheets stammen aus den Standard-Stylesheets des Browsers, den vom Seitenautor bereitgestellten Stylesheets und Nutzer-Stylesheets - diese werden vom Nutzer des Browsers bereitgestellt (Sie können in Browsern Ihren bevorzugten Stil festlegen. In Firefox platzieren Sie dazu beispielsweise ein Stylesheet im Firefox-Profilordner ).
</p>
<p>
Die Stilberechnung birgt einige Schwierigkeiten:
<ol>
<li><a id="issue1">Stildaten</a> sind ein sehr umfangreiches Konstrukt, da sie die zahlreichen Stileigenschaften umfassen, und können daher zu Speicherproblemen führen.</li>
<li>
<p>Das <a id="issue2">Finden</a> der entsprechenden Regeln für jedes Element kann zu Leistungsproblemen führen, wenn dieser Vorgang nicht optimiert ist. Es erfordert einen großen Aufwand, die gesamte Regelliste für jedes Element zu durchlaufen, um Übereinstimmungen zu finden. Selektoren können über eine komplexe Struktur verfügen, aufgrund derer der Zuordnungsprozess auf einem vielversprechenden Pfad beginnt, der sich dann jedoch als nutzlos erweist, sodass ein neuer Pfad getestet werden muss.
</p>
<p>Zum Beispiel dieser Verbundselektor:</p>

<pre class="prettyprint">
div div div div{
  ...
}
</pre>
Dies bedeutet, dass die Regel für ein <code>&lt;div&gt;</code>-Element gilt, das auf drei andere "div"-Elemente folgt. Angenommen, Sie möchten prüfen, ob die Regel auf ein bestimmtes <code>&lt;div&gt;</code>-Element zutrifft. Sie wählen zur Überprüfung einen Pfad aus, der die Baumstruktur hinaufführt. Sie müssen möglicherweise den Knotenbaum nach oben durchlaufen, nur um festzustellen, dass nur zwei "div"-Elemente vorhanden sind und die Regel nicht zutrifft. Sie müssten dann andere Pfade in der Baumstruktur überprüfen.
</li>
<li>Das <a id="issue3">Anwenden</a> der Regeln beinhaltet ziemlich komplexe Kaskadenregeln, die die Hierarchie der Regeln definieren.</li>
</ol>
So gehen die Browser mit diesen Problemen um:

<h5 id="Sharing_style_data">Weitergabe von Stildaten</h5>
<p>
WebKit-Knoten verweisen auf Stilobjekte (RenderStyle). Diese Objekte können unter bestimmten Umständen von Knoten geteilt werden. Die Knoten sind gleichgeordnet oder verwandt und Folgendes trifft zu:
<ol>
<li>Die Elemente weisen denselben Mauszustand auf. (Das heißt beispielsweise, dass nicht ein Element sich im Zustand ":hover" befindet und das andere nicht.)</li>
<li> Keines der Elemente darf über eine ID verfügen.</li>
<li> Die Tag-Namen stimmen überein.</li>
<li> Die Klassen-Attribute stimmen überein.</li>
<li> Der Satz zugeordneter Attribute ist identisch.</li>
<li> Die Linkzustände stimmen überein.</li>
<li> Die Fokuszustände stimmen überein.</li>
<li> Kein Element darf von Attributselektoren betroffen sein. Dabei bedeutet "betroffen", dass eine beliebige Selektorübereinstimmung vorliegt, bei der ein Attributselektor an einer beliebigen Position innerhalb des Selektors verwendet wird.</li>
<li> Es dürfen keine Inline-Stilattribute bei den Elementen vorhanden sein.</li>
<li>Es dürfen keine gleichgeordneten Selektoren in Verwendung sein. WebCore löst einfach einen globalen Wechsel aus, wenn ein gleichgeordneter Selektor gefunden wird, und deaktiviert bei deren Vorkommen die Stilweitergabe für das gesamte Dokument. Dazu gehören auch der +-Selektor und Selektoren wie ":first-child" und ":last-child".</li>
</ol>

<h5 id="Firefox_rule_tree">Firefox-Regelbaum</h5>
<p>
Firefox verfügt über zwei zusätzliche Baumstrukturen für eine einfachere Stilberechnung: den Regelbaum und den Stilkontextbaum. WebKit verfügt ebenfalls über Stilobjekte, diese sind jedoch nicht in einer Baumstruktur wie dem Stilkontextbaum gespeichert. Der DOM-Knoten verweist nur auf seinen relevanten Stil.

</p>

<figure>
  <img src="image035.png" width="640" height="407" />
  <figcaption><span>Abbildung </span>: Stilkontextbaum bei Firefox (<a href="#2_2">2.2</a>)</figcaption>
</figure>


<p>
Die Stilkontexte enthalten Endwerte. Die Werte werden berechnet, indem alle zutreffenden Regeln in der richtigen Reihenfolge angewendet und Änderungen vorgenommen werden, die sie von logischen in konkrete Werte umwandeln. Ist der logische Wert beispielsweise ein Prozentsatz des Bildschirms, wird er berechnet und in absolute Einheiten umgewandelt. Die Idee eines Regelbaums ist wirklich clever. Sie ermöglicht die Weitergabe dieser Werte zwischen Knoten, um eine erneute Berechnung zu vermeiden. Dies spart auch Speicherplatz.
</p>

<p>
Alle zutreffenden Regeln werden in einer Baumstruktur gespeichert. Die unteren Knoten in einem Pfad besitzen eine höhere Priorität. Der Baum enthält alle Pfade für gefundene Regelübereinstimmungen. Das Speichern der Regeln erfolgt verzögert. Die Baumstruktur wird nicht zu Beginn für jeden Knoten berechnet, aber immer, wenn ein Knotenstil berechnet werden muss, werden die berechneten Pfade zu dem Baum hinzugefügt.
</p>
<p>
Die Idee dahinter ist, die Baumpfade wie Wörter in einem Lexikon zu betrachten. Angenommen, wir haben diesen Regelbaum bereits berechnet:

<figure>
  <img src="tree.png" width="400" height="261" alt="" title="" border="0" align=""  />
</figure>

Nehmen wir an, wir müssen Regeln für ein anderes Element im Inhaltsbaum zuordnen und finden heraus, dass die zutreffenden Regeln (in der richtigen Reihenfolge) B - E - I sind. Dieser Pfad ist in unserem Baum bereits vorhanden, da wir schon den Pfad A - B - E - I - L berechnet haben. Nun haben wir weniger Arbeit.
</p>
<p>
Sehen wir uns an, wie der Baum uns Arbeit erspart.
</p>
<h5 id="Division_into_structs">Unterteilung in Strukturen</h5>
<p>
Die Stilkontexte werden in Strukturen unterteilt. Diese Strukturen enthalten Stilinformationen für eine bestimmte Kategorie wie Rahmen oder Farbe. Alle Eigenschaften in einer Struktur sind entweder geerbt oder nicht geerbt. Geerbte Eigenschaften sind Eigenschaften, die vom übergeordneten Element übernommen werden, sofern sie nicht vom Element selbst definiert werden. Nicht geerbte Eigenschaften, auch "reset"-Eigenschaften genannt, verwenden Standardwerte, wenn sie nicht definiert werden.
</p>
<p>
Der Baum hilft uns, indem ganze Strukturen (mit den berechneten Endwerten) darin zwischengespeichert werden. Die Idee dahinter: Falls der untere Knoten keine Definition für eine Struktur bereitgestellt hat, kann eine zwischengespeicherte Struktur in einem oberen Knoten verwendet werden.
</p>
<h5 id="Computing_the_style_contexts_using_the_rule_tree">Berechnen der Stilkontexte mit dem Regelbaum</h5>
<p>
Beim Berechnen des Stilkontexts für ein bestimmtes Element berechnen wir zunächst einen Pfad im Regelbaum oder verwenden einen vorhandenen Pfad. Anschließend beginnen wir damit, die Regeln in dem Pfad anzuwenden, um die Strukturen in unserem neuen Stilkontext zu füllen. Wir beginnen mit dem untersten Knoten im Pfad - dem mit der höchsten Priorität (normalerweise der spezifischste Selektor) - und durchlaufen den Baum nach oben, bis unsere Struktur vollständig ist. Falls für die Struktur in diesem Regelknoten keine Spezifikation vorhanden ist, können wir optimieren: Wir wandern den Baum nach oben, bis wir einen Knoten mit einer vollständigen Spezifikation finden, und verweisen dann einfach darauf. Dies ist die bestmögliche Optimierung - die gesamte Struktur wird geteilt. So müssen wir weniger Endwerte berechnen und sparen Speicherplatz.
<br>
Falls wir Teildefinitionen finden, klettern wir den Baum nach oben, bis die Struktur vollständig ausgefüllt ist.
</p>
<p>
Falls wir gar keine Definitionen für unsere Struktur finden, verweisen wir auf die Struktur des übergeordneten Elements im <b>Kontextbaum</b>, falls es sich bei unserer Struktur um eine geerbte Struktur handelt. So können wir ebenfalls Strukturen weitergeben. Im Fall einer "reset"-Struktur werden Standardwerte verwendet.
</p>
<p>
Wenn der spezifischste Knoten Werte hinzufügt, müssen wir einige zusätzliche Berechnungen durchführen, um diese in tatsächliche Werte umzuwandeln. Anschließend wird das Ergebnis im Baumknoten zwischengespeichert, damit es von untergeordneten Elementen verwendet werden kann.
</p>
<p>
Falls ein Element über ein gleichgeordnetes oder verwandtes Element verfügt, das auf denselben Baumknoten verweist, kann der <b>gesamte Stilkontext</b> zwischen ihnen weitergegeben werden.
</p>
<p>
Beispiel: Angenommen, uns liegt folgender HTML-Code vor:


<pre class="prettyprint">
&lt;html&gt;
  &lt;body&gt;
    &lt;div class="err" id="div1"&gt;
      &lt;p&gt;
        this is a &lt;span class="big"&gt; big error &lt;/span&gt;
        this is also a
        &lt;span class="big"&gt; very  big  error&lt;/span&gt; error
      &lt;/p&gt;
    &lt;/div&gt;
    &lt;div class="err" id="div2"&gt;another error&lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>

Und die folgenden Regeln:
<pre class="prettyprint lang-css linenums">
div {margin:5px;color:black}
.err {color:red}
.big {margin-top:3px}
div span {margin-bottom:4px}
#div1 {color:blue}
#div2 {color:green}
</pre>
<p>
Gehen wir der Einfachheit halber davon aus, dass wir nur zwei Strukturen vervollständigen müssen: die Farbstruktur und die Randstruktur. Die Farbstruktur enthält nur ein Mitglied - die Farbe. Die Randstruktur umfasst die vier Seiten.
<br>
Der entstehende Regelbaum sieht folgendermaßen aus (die Knoten sind mit den Knotennamen gekennzeichnet : die Nummer der Regel, auf die sie verweisen):



<figure>
  <img src="image027.png" width="500" height="294" />
  <figcaption><span>Abbildung </span>: Regelbaum</figcaption>
</figure>


<br>
Der Kontextbaum sieht folgendermaßen aus (Knotenname : Regelknoten, auf den verwiesen wird):


<figure>
  <img src="image029.png" width="400" height="305" >
  <figcaption> <span>Abbildung </span>: Kontextbaum</figcaption>
</figure>



<p>
Angenommen, wir parsen den HTML-Code und gelangen zum zweiten &lt;div&gt;-Tag. Wir müssen einen Stilkontext für diesen Knoten erstellen und dessen Stilstrukturen ausfüllen.
<br>
Wir ordnen die Regeln zu und ermitteln, dass auf das &lt;div&gt;-Element die Regeln 1, 2 und 6 zutreffen. Das bedeutet, dass in dem Baum bereits ein Pfad vorhanden ist, den unser Element nutzen kann, und wir nur einen weiteren Knoten für Regel 6 hinzufügen müssen (Knoten F im Regelbaum).
<br>
Wir erstellen einen Stilkontext und fügen ihn in den Kontextbaum ein. Der neue Stilkontext verweist auf Knoten F im Regelbaum.
</p>
<p>
Nun müssen wir die Stilstrukturen füllen. Wir beginnen mit der Randstruktur. Da der letzte Regelknoten (F) nicht zur Randstruktur gehört, können wir den Baum hinaufwandern, bis wir eine zwischengespeicherte Struktur in einer vorherigen Knoteneinfügung finden, und diese verwenden. Wir finden diese auf Knoten B, dem obersten Knoten, der Randregeln angibt.
</p>
<p>
Wir verfügen über eine Definition für die Farbstruktur und können deshalb keine zwischengespeicherte Struktur verwenden. Da die Farbe nur ein einziges Attribut besitzt, müssen wir den Baum nicht durchlaufen, um weitere Attribute zu füllen. Wir berechnen den Endwert (String in RGB umwandeln usw.) und speichern die berechnete Struktur auf diesem Knoten zwischen.
</p>
<p>
Die Arbeit am zweiten &lt;span&gt;-Element ist sogar noch einfacher. Wir ordnen die Regeln zu und kommen zu dem Schluss, dass es wie das vorherige "span"-Element auf Regel G verweist. Da wir hier über gleichgeordnete Elemente verfügen, die auf denselben Knoten verweisen, können wir den gesamten Stilkontext teilen und einfach auf den Kontext des vorherigen "span"-Elements verweisen.
</p>
<p>
Für Strukturen, die von dem übergeordneten Element geerbte Regeln enthalten, erfolgt das Zwischenspeichern auf dem Kontextbaum. Die Farbeigenschaft wird eigentlich vererbt, aber Firefox behandelt sie als "reset"-Eigenschaft und speichert sie auf dem Regelbaum zwischen.
<br>
Angenommen, wir würden Regeln für Schriftarten in einem Absatz hinzufügen:
<pre class="prettyprint">
p {font-family:Verdana;font size:10px;font-weight:bold}
</pre>
Dann könnte das Absatzelement, das ein untergeordnetes Element des "div"-Elements im Kontextbaum ist, dieselbe Schriftartstruktur wie sein übergeordnetes Element verwendet haben. Dies ist der Fall, wenn keine Schriftartregeln für den Absatz angegeben wurden.
</p>
<p>
In WebKit, das nicht über einen Regelbaum verfügt, werden die zugeordneten Deklarationen viermal durchlaufen. Zunächst werden nicht wichtige Eigenschaften mit hoher Priorität angewendet. Dies sind Eigenschaften, die zuerst angewendet werden sollten, weil andere von ihnen abhängen, zum Beispiel die "display"-Eigenschaft. Danach folgen wichtige Regeln mit hoher Priorität, nicht wichtige Regeln mit normaler Priorität und schließlich wichtige Regeln mit normaler Priorität. Eigenschaften, die mehrfach auftreten, werden somit gemäß der korrekten Kaskadenreihenfolge aufgelöst. Der Letzte gewinnt.
<br>
</p>
<p>
Zusammengefasst löst also das Weitergeben der Stilobjekte (aller oder einiger darin vorhandener Strukturen) die Probleme <a href="#issue1">1</a> und <a href="#issue3">3</a>. Der Firefox-Regelbaum hilft außerdem dabei, die Eigenschaften in der richtigen Reihenfolge anzuwenden.
</p>
<h5 id="Manipulating_the_rules_for_an_easy_match">Bearbeiten der Regeln für eine einfache Zuordnung</h5>
<p>
Es gibt verschiedene Quellen für Stilregeln:
<ul>
<li>CSS-Regeln, entweder in externen Stylesheets oder in Stilelementen
<pre class="prettyprint">
p {color:blue}
</pre>
</li>
<li>Inline-Stilattribute wie
<pre class="prettyprint">
&lt;p style="color:blue" /&gt;
</pre>
</li>
<li>Visuelle HTML-Attribute (die relevanten Stilregeln zugeordnet werden)
<pre class="prettyprint">
&lt;p bgcolor="blue" /&gt;
</pre>
</li>
</ul>
<p>
Die beiden letzten können dem Element leicht zugeordnet werden, da es die Stilattribute enthält und HTML-Attribute mithilfe des Elements als Schlüssel zugeordnet werden können.
</p>
<p>
Wie in <a href="#issue2">Problem Nr. 2</a> bereits erwähnt, kann sich die Zuordnung der CSS-Regeln etwas schwieriger gestalten. Um diese Schwierigkeit zu beheben, werden die Regeln für einen einfacheren Zugriff bearbeitet.
</p><p>
Nach dem Parsen des Stylesheets werden die Regeln dem Selektor entsprechend zu einer von mehreren Hashmaps hinzugefügt. Es gibt Hashmaps für ID, Klassenname und Tag-Name sowie eine allgemeine Hashmap für alles, das nicht in diese Kategorien passt. Handelt es sich bei dem Selektor um eine ID, wird die Regel zur ID-Map hinzugefügt, bei einer Klasse wird sie zur Klassen-Map hinzugefügt usw.
<br>
Diese Bearbeitung erleichtert die Zuordnung von Regeln enorm. Es muss nicht jede Deklaration überprüft werden. Die relevanten Regeln für ein Element können aus den Hashmaps extrahiert werden. Mit dieser Optimierung können mehr als 95 % der Regeln aussortiert werden, sodass sie während des Zuordnungsvorgangs nicht einmal berücksichtigt werden müssen (<a href="#4_1">4.1</a>).
</p>
<p>
Sehen wir uns beispielsweise folgende Stilregeln an:
<pre class="prettyprint">
p.error {color:red}
#messageDiv {height:50px}
div {margin:5px}
</pre>
Die erste Regel wird in die Klassen-Hashmap eingefügt. Die zweite Regel wird in die ID-Map und die dritte in die Tag-Map eingefügt.
<br>
Bei dem folgenden HTML-Fragment
<pre class="prettyprint">
&lt;p class="error">an error occurred &lt;/p>
&lt;div id=" messageDiv">this is a message&lt;/div&gt;
</pre>
</p>
<p>
suchen wir zunächst nach Regeln für das "p"-Element. Die Klassen-Hashmap enthält einen Fehlerschlüssel, unter dem die Regel für "p.error" zu finden ist. Dem "div"-Element entsprechen relevante Regeln in der ID-Map (Schlüssel ist die ID) und der Tag-Map. Wir müssen nun nur noch herausfinden, welche der durch die Schlüssel extrahierten Regeln tatsächlich zutreffen.
<br>
Lautete die Regel für das "div"-Element zum Beispiel
<pre class="prettyprint">
table div {margin:5px}
</pre>
würde sie dennoch aus der Tag-Map extrahiert, da der Schlüssel der Selektor ganz rechts ist. Sie würde aber nicht mit unserem "div"-Element übereinstimmen, da dieses nicht über einen Tabellenvorgänger verfügt.
</P>
<P>
Sowohl WebKit als auch Firefox nehmen diese Bearbeitung vor.
</p>
<h5 id="Applying_the_rules_in_the_correct_cascade_order">Anwendung der Regeln in der richtigen Kaskadenreihenfolge</h5>
<p>
Das Stilobjekt verfügt über Eigenschaften, die jedem visuellen Attribut (allen CSS-Attributen, aber allgemeiner) entsprechen. Wird die Eigenschaft durch keine der zugeordneten Regeln definiert, können einige Eigenschaften vom Stilobjekt des übergeordneten Elements geerbt werden. Andere Eigenschaften verfügen über Standardwerte.
</p>
<p>
Das Problem entsteht, wenn es mehr als eine Definition gibt. Dieses Problem kann mithilfe der Kaskadenreihenfolge gelöst werden.
<h5 id="Style_sheet_cascade_order">Kaskadierung von Stylesheets</h5>
Eine Deklaration für eine Stileigenschaft kann in verschiedenen Stylesheets vorkommen sowie mehrere Male innerhalb eines Stylesheets. Die Reihenfolge, in der die Regeln angewendet werden, spielt demnach eine wichtige Rolle. Diese wird Kaskadenreihenfolge genannt. Gemäß der CSS2-Spezifikation sieht die Kaskadenreihenfolge folgendermaßen aus (von unten nach oben):
<ol>
  <li>Browserdeklarationen</li>
  <li>Normale Nutzerdeklarationen</li>
  <li>Normale Autorendeklarationen</li>
  <li>Wichtige Autorendeklarationen</li>
  <li>Wichtige Nutzerdeklarationen</li>
</ol>
</p>
<p>
Die Browserdeklarationen sind am wenigsten wichtig und Nutzer haben nur Vorrang vor Autoren, wenn die Deklaration als wichtig gekennzeichnet wurde. Deklarationen mit derselben Reihenfolge werden anhand der <a href="#Specificity">Spezifität</a> und dann anhand ihrer angegebenen Reihenfolge sortiert. Die visuellen HTML-Attribute werden in passende CSS-Deklarationen übersetzt. Sie werden als Autorenregeln mit niedriger Priorität behandelt.
</p>
<h5 id="Specificity">Spezifität</h5>
<p>
Die Selektorspezifität wird in der <a href="http://www.w3.org/TR/CSS2/cascade.html#specificity">CSS2-Spezifikation</a> folgendermaßen definiert:
<ul>
    <li>1, wenn die Deklaration eher von einem "style"-Attribut statt einer Regel mit einem Selektor stammt, ansonsten 0 (= a)</li>
    <li>Anzahl der ID-Attribute im Selektor (=b) </li>
    <li>Anzahl der anderen Attribute und Pseudoklassen im Selektor (=c) </li>
    <li>Anzahl der Elementnamen und Pseudoelemente im Selektor (=d) </li>
</ul>
Die Verkettung der vier Zahlen a-b-c-d (in einem Zahlensystem mit einer großen Basis) liefert die Spezifität.
</p>
<p>
Die Zahlenbasis, die Sie verwenden müssen, wird von Ihrem höchsten Wert in einer der Kategorien definiert.
<br>
Beispiel: Wenn a=14 ist, können Sie eine Hexadezimalbasis verwenden. Im unwahrscheinlichen Fall, dass a=17 ist, benötigen Sie eine siebzehnstellige Zahlenbasis. Diese Situation kann bei einem Selektor wie diesem auftreten: html body div div p ... (17 Tags in Ihrem Selektor ... nicht sehr wahrscheinlich)
</p>
<p>
Einige Beispiele:
<pre class="prettyprint">
 *             {}  /* a=0 b=0 c=0 d=0 -> specificity = 0,0,0,0 */
 li            {}  /* a=0 b=0 c=0 d=1 -> specificity = 0,0,0,1 */
 li:first-line {}  /* a=0 b=0 c=0 d=2 -> specificity = 0,0,0,2 */
 ul li         {}  /* a=0 b=0 c=0 d=2 -> specificity = 0,0,0,2 */
 ul ol+li      {}  /* a=0 b=0 c=0 d=3 -> specificity = 0,0,0,3 */
 h1 + *[rel=up]{}  /* a=0 b=0 c=1 d=1 -> specificity = 0,0,1,1 */
 ul ol li.red  {}  /* a=0 b=0 c=1 d=3 -> specificity = 0,0,1,3 */
 li.red.level  {}  /* a=0 b=0 c=2 d=1 -> specificity = 0,0,2,1 */
 #x34y         {}  /* a=0 b=1 c=0 d=0 -> specificity = 0,1,0,0 */
 style=""          /* a=1 b=0 c=0 d=0 -> specificity = 1,0,0,0 */
</pre>
</p>
<h5 id="Sorting_the_rules">Sortieren der Regeln</h5>
<p>
Nachdem die Regeln zugeordnet wurden, werden sie entsprechend den Kaskadierungsregeln sortiert. WebKit verwendet Bubblesort für kurze und Mergesort für lange Listen. WebKit implementiert die Sortierung durch Überschreiben des "&gt;"-Operators für die Regeln:
<pre class="prettyprint">
static bool operator >(CSSRuleData& r1, CSSRuleData& r2)
{
    int spec1 = r1.selector()->specificity();
    int spec2 = r2.selector()->specificity();
    return (spec1 == spec2) : r1.position() > r2.position() : spec1 > spec2;
}
</pre>
</p>
<h4 id="Gradual_process">Schrittweiser Prozess</h4>
<p>
WebKit verwendet eine Markierung, um zu kennzeichnen, ob alle Top-Level-Stylesheets (einschließlich @imports) geladen wurden. Wurde der Stil beim Anhängen noch nicht vollständig geladen, werden Platzhalter verwendet und dies wird im Dokument markiert. Sobald die Stylesheets geladen wurden, erfolgt eine erneute Berechnung.
</p>


<h3 id="Layout">Layout</h3>
<p>
Wenn der Renderer erstellt und zur Baumstruktur hinzugefügt wird, verfügt er weder über Position noch Größe. Die Berechnung dieser Werte wird als Layout oder Reflow bezeichnet.
</p>
<p>
HTML verwendet ein Flusslayout-Modell, mit dem es meistens möglich ist, die Geometrie in einem einzigen Durchlauf zu berechnen. Elemente, die später "im Fluss" auftauchen, beeinflussen typischerweise nicht die Geometrie von Elementen, die früher "im Fluss" aufgetreten sind. So kann das Layout von links nach rechts und oben nach unten das Dokument durchlaufen. Es gibt Ausnahmen - so können HTML-Tabellen beispielsweise mehr als einen Durchlauf erfordern (<a href="#3_5">3.5</a>).
</p>
<p>
Das Koordinatensystem ist relativ zum Stamm-Frame. Es werden obere und linke Koordinaten verwendet.
</p>
<p>
Das Layout ist ein rekursiver Prozess. Es beginnt beim Stamm-Renderer, der dem <code>&lt;html></code>-Element des HTML-Dokuments entspricht. Das Layout durchläuft rekursiv einen Teil der oder die gesamte Frame-Hierarchie und berechnet geometrische Informationen für jeden Renderer, der sie anfordert.
</p>
Die Position des Stamm-Renderers ist 0,0 und seine Abmessungen entsprechen dem Viewport - dem sichtbaren Teil des Browserfensters.
<p>
Alle Renderer verfügen über eine Layout- oder Reflow-Methode und jeder Renderer ruft die Layout-Methode seiner untergeordneten Elemente auf, die ein Layout benötigen.
</p>
<h4 id="Dirty_bit_system">Dirty Bit-System</h4>
<p>
Damit Browser nicht für jede kleine Änderung ein komplettes Layout vornehmen müssen, verwenden sie ein sogenanntes "Dirty Bit-System". Ein Renderer, der geändert oder hinzugefügt wurde, markiert sich selbst und seine untergeordneten Elemente als "dirty" = layoutbedürftig.
</p>
<p>
Es gibt zwei Markierungen: "dirty" und "children are dirty". "Children are dirty" bedeutet, dass zwar der Renderer selbst in Ordnung sein kann, aber mindestens ein untergeordnetes Element layoutbedürftig ist.
</p>
<h4 id="Global_and_incremental_layout">Globales und inkrementelles Layout</h4>
<p>
Das Layout kann auf der gesamten Rendering-Struktur ausgelöst werden. In diesem Fall handelt es sich um ein "globales" Layout. Dies kann folgende Ursachen haben:
<ol>
<li>Eine globale Stiländerung, die alle Renderer betrifft, z. B. die Änderung der Schriftgröße</li>
<li>Eine Änderung der Bildschirmgröße</li>
</ol>
</p>
<p>
Das Layout kann auch inkrementell sein. Dabei werden nur die "dirty" Renderer einem Layout unterzogen (dies kann Auswirkungen haben, die wiederum zusätzliches Layout erforderlich machen).
<br>
Das inkrementelle Layout wird (asynchron) ausgelöst, wenn Renderer als "dirty" markiert sind. Dies ist zum Beispiel der Fall, wenn neue Renderer an die Rendering-Struktur angehängt werden, nachdem zusätzliche Inhalte aus dem Netzwerk empfangen und zum DOM-Baum hinzugefügt wurden.
</p>


<figure>
  <img src="reflow.png" width="326" height="341" />
  <figcaption> <span>Abbildung </span>: Inkrementelles Layout - nur layoutbedürftige Renderer und ihre untergeordneten Elemente erhalten ein neues Layout (<a href="#3_6">3.6</a>).</figcaption>
</figure>

<h4 id="Asynchronous_and_Synchronous_layout">Asynchrones und synchrones Layout</h4>
Das inkrementelle Layout erfolgt asynchron. Firefox stellt "Reflow-Befehle" für inkrementelle Layouts in eine Warteschlange und ein Planer löst die Ausführung dieser Befehle im Batch aus. WebKit verfügt ebenfalls über einen Timer, der ein inkrementelles Layout ausführt. Die Baumstruktur wird durchlaufen und das Layout von Renderern, die als "dirty" markiert sind, wird aktualisiert.
<br>
Skripts wie "offsetHeight", die Stilinformationen anfordern, können ein inkrementelles Layout auch synchron auslösen.
<br>
Das globale Layout erfolgt normalerweise synchron.
<br>
Manchmal wird das Layout auch als Rückruf nach einem Anfangslayout ausgelöst, da einige Attribute wie etwa die Scrolling-Position sich geändert haben.
<h4 id="Optimizations">Optimierungen</h4>
Wenn ein Layout durch eine Größenanpassung oder eine Änderung der Rendererposition (nicht der Größe) ausgelöst wird, werden die Renderergrößen aus einem Cache abgerufen und nicht neu berechnet.
<br>
In einigen Fällen wird nur eine Unterstruktur bearbeitet und das Layout startet nicht vom Stamm aus. Dies kann vorkommen, wenn die Änderung lokal ist und keinen Einfluss auf ihre Umgebung hat, zum Beispiel Text, der in Textfelder eingefügt wird (andernfalls würde jeder Tastendruck ein Layout vom Stamm aus hervorrufen).
</p>
<h4 id="The_layout_process">Der Layout-Prozess</h4>
<p>
Das Layout weist normalerweise folgendes Muster auf:
<ol>
<li>Der übergeordnete Renderer bestimmt seine eigene Breite.
<li>Das übergeordnete Element hat Vorrang vor untergeordneten Elementen und:
  <ol>
    <li>platziert den untergeordneten Renderer (legt seine x- und y-Koordinaten fest).</li>
    <li>fordert gegebenenfalls ein Layout der untergeordneten Elemente an (falls sie z. B. als "dirty" markiert sind oder ein globales Layout durchgeführt wird) - so wird die Höhe der untergeordneten Elemente bestimmt.</li>
  </ol>
</li>
<li>Das übergeordnete Element verwendet die gesammelte Höhe der untergeordneten Elemente und die Höhe der Ränder und Abstände, um seine eigene Höhe festzulegen. Diese wird vom übergeordneten Element des übergeordneten Renderers verwendet.</li>
<li>Die "Dirty Bit"-Markierung wird auf "false" gesetzt.</li>
</ol>
</p>
<p>
Firefox verwendet ein "state"-Zustandsobjekt (nsHTMLReflowState) als Parameter für das Layout ("Reflow" genannt). Der Zustand umfasst unter anderem die Breite des übergeordneten Elements.
<br>
Das Firefox-Layout gibt ein "metrics"-Objekt aus (nsHTMLReflowMetrics). Dieses enthält die berechnete Renderer-Höhe.
</p>
<h4 id="Width_calculation">Breitenberechnung</h4>
<p>
Die Breite des Renderers wird mithilfe der Breite des Containerblocks, der "width"-Stileigenschaft des Renderers sowie den Rändern und Rahmen berechnet.
<br>
Die Breite des folgenden "div"-Elements:
<pre class="prettyprint">
&lt;div style="width:30%"/&gt;
</pre>
würde von WebKit beispielsweise folgendermaßen berechnet (Klasse "RenderBox", Methode "calcWidth"):
<ul>
<li>Die Containerbreite ist das Maximum aus der "availableWidth" des Containers und 0. Die "availableWidth" ist in diesem Fall die "contentWidth", die folgendermaßen berechnet wird:
<pre class="prettyprint">
clientWidth() - paddingLeft() - paddingRight()
</pre>
"clientWidth" und "clientHeight" stehen für das Innere eines Objekts ohne Rahmen und Bildlaufleiste.
</li>
<li>Die Breite der Elemente wird im "width"-Stilattribut angegeben. Diese wird als absoluter Wert berechnet, indem der Prozentsatz der Containerbreite ermittelt wird.
</li>
<li>Die horizontalen Rahmen und Abstände werden jetzt hinzugefügt.</li>
</ul>
Bislang haben wir die "bevorzugte Breite" berechnet. Nun werden die minimale und die maximale Breite berechnet.
<br>
Ist die bevorzugte Breite größer als die maximale Breite, wird die maximale Breite verwendet. Ist sie kleiner als die minimale Breite (die kleinste feststehende Einheit), wird die minimale Breite verwendet.
</p>
<p>
Die Werte werden zwischengespeichert, falls ein Layout erforderlich ist, aber die Breite sich nicht ändert.
</p>
<p>
<h4 id="Line_Breaking">Zeilenumbruch</h4>
<p>
Dieser erfolgt, wenn ein Renderer mitten im Layout entscheidet, dass eine Aufteilung erforderlich ist. In diesem Fall stoppt er und teilt seinem übergeordneten Element mit, dass er aufgeteilt werden muss. Das übergeordnete Element erstellt die zusätzlichen Renderer und fordert ein Layout für diese an.
</p>
<h3 id="Painting">Painting</h3>
<p>
In der Painting-Phase wird die Rendering-Struktur durchlaufen und die "paint"-Methode der Renderer aufgerufen, um deren Inhalt auf dem Bildschirm darzustellen. Painting verwendet die UI-Infrastrukturkomponente.
<h4 id="Global_and_Incremental">Global und inkrementell</h4>
Wie das Layout kann auch das Painting global, also auf die gesamte Struktur bezogen, oder inkrementell sein. Beim inkrementellen Painting ändern sich einige Renderer auf eine Art, die sich nicht auf die gesamte Struktur auswirkt. Durch die Änderung des Renderers wird sein Rechteck auf dem Bildschirm ungültig. Das Betriebssystem sieht dies dann als "dirty region" an und löst ein "paint"-Ereignis aus. Das Betriebssystem geht intelligent vor und fasst mehrere Regionen in einer zusammen. In Chrome ist dies etwas komplizierter, da der Renderer sich in einem anderen Vorgang als der Hauptprozess befindet. Chrome simuliert das Betriebssystemverhalten in gewissem Maß. Die Darstellung erkennt diese Ereignisse und delegiert die Meldung an den Rendering-Stamm. Die Baumstruktur wird durchlaufen, bis der relevante Renderer erreicht ist. Dieser aktualisiert seine Darstellung (und normalerweise die seiner untergeordneten Elemente) selbst.
<h4 id="The_painting_order">Painting-Reihenfolge</h4>
<a href="http://www.w3.org/TR/CSS21/zindex.html">In CSS2 wird die Reihenfolge des Painting-Prozesses definiert</a>. Dabei handelt es sich tatsächlich um die Reihenfolge, in der die Elemente in den <a href="#stackingcontext">Stapelkontexten</a> gestapelt sind. Diese Reihenfolge wirkt sich auf das Painting aus, da die Stapel von hinten nach vorne dargestellt werden. Die Stapelreihenfolge eines Block-Renderers sieht so aus:
<ol>
<li>Hintergrundfarbe</li>
<li>Hintergrundbild</li>
<li>Rahmen</li>
<li>Untergeordnete Elemente</li>
<li>Umriss</li>
</ol>
</p>
<h4 id="Firefox_display_list">Firefox-Displayliste</h4>
Firefox durchläuft die Rendering-Struktur und erstellt eine Display-Liste für das dargestellte Rechteck. Diese enthält die relevanten Renderer für das Rechteck in der richtigen Painting-Reihenfolge (Hintergründe der Renderer, dann Rahmen usw.). Auf diese Weise muss die Struktur für eine Darstellungsaktualisierung nur ein Mal durchlaufen werden. Dabei werden alle Hintergründe, dann alle Bilder, dann alle Rahmen usw. dargestellt.

<p>
Firefox optimiert den Ablauf, indem ausgeblendete Elemente nicht hinzugefügt werden. Dies sind zum Beispiel Elemente, die vollständig von anderen, undurchsichtigen Elementen verdeckt sind.
</p>
<h4 id="Webkit_rectangle_storage">WebKit-Rechteckspeicher</h4>
Vor der Darstellungsaktualisierung speichert WebKit das alte Rechteck als Bitmap. Anschließend wird nur das Delta zwischen den neuen und den alten Rechtecken dargestellt.

<br>

<h3 id="Dynamic_changes">Dynamische Änderungen</h3>
Die Browser versuchen, in Reaktion auf eine Änderung möglichst geringen Aufwand zu betreiben. Bei Änderungen an der Farbe eines Elements wird daher nur die Darstellung des Elements aktualisiert. Bei Änderungen an der Position des Elements werden das Layout und die Darstellung des Elements, seiner untergeordneten Elemente und möglicher gleichgeordneter Elemente aktualisiert. Beim Hinzufügen eines DOM-Knotens werden das Layout und die Darstellung des Knotens aktualisiert. Bei großen Änderungen, wie das Vergrößern der Schrift des "html"-Elements, werden die Caches ungültig und Layout sowie Darstellung der gesamten Struktur müssen aktualisiert werden.


<h3 id="The_rendering_engines_threads">Rendering-Modul-Threads</h3>
Das Rendering-Modul ist ein Single-Thread-Modul. Fast alles, bis auf die Netzwerkvorgänge, spielt sich in einem einzelnen Thread ab. Bei Firefox und Safari ist dies der Haupt-Thread des Browsers. In Chrome ist es der Haupt-Thread des Tab-Prozesses.
<br>
Netzwerkvorgänge können von mehreren parallelen Threads durchgeführt werden. Die Anzahl der parallelen Verbindung ist beschränkt (normalerweise zwei bis sechs Verbindungen. Firefox 3 verwendet zum Beispiel sechs).
<h4 id="Event_loop">Ereignisschleife</h4>
Beim Haupt-Thread des Browsers handelt es sich um eine Ereignisschleife. Dies ist eine Endlosschleife, die den Prozess am Leben erhält. Sie wartet auf Ereignisse, zum Beispiel Layout- oder Paint-Ereignisse, und verarbeitet diese. Dies ist der Firefox-Code für die Hauptereignisschleife:
<pre class="prettyprint">
while (!mExiting)
    NS_ProcessNextEvent(thread);
</pre>


<h3 id="css">Visuelles CSS2-Modell</h3>
<h4 id="The_canvas">Canvas</h4>
<p>
Laut der <a href="http://www.w3.org/TR/CSS21/intro.html#processing-model">CSS2-Spezifikation</a> beschreibt der Begriff Canvas "den Bereich, in dem die Formatierungsstruktur gerendert wird" - also den Bereich, in dem der Browser den Inhalt darstellt. Die Canvas-Größe ist für jede Abmessung des Bereichs unendlich, aber die Browser wählen eine Anfangsbreite basierend auf den Abmessungen des Viewport aus.
</p>
<p>
Gemäß <a href="http://www.w3.org/TR/CSS2/zindex.html">www.w3.org/TR/CSS2/zindex.html</a> ist der Canvas-Bereich transparent, wenn er sich innerhalb eines anderen Canvas-Elements befindet. Andernfalls wird eine vom Browser definierte Farbe verwendet.
</p>
<h4 id="CSS_Box_model">CSS-Boxmodell</h4>
<p>
Im <a href="http://www.w3.org/TR/CSS2/box.html">CSS-Boxmodell</a> werden die rechteckigen Felder beschrieben, die für Elemente in der Dokumentstruktur erstellt und gemäß dem visuellen Formatierungsmodell dargestellt werden.
<br>
Jede Box verfügt über einen Inhaltsbereich (z. B. Text, ein Bild usw.) und optional umliegende Abstände, Rahmen und Ränder.


<figure>
  <img src="image046.jpg" width="509" height="348" >
  <figcaption> <span>Abbildung </span>: CSS2-Boxmodell</figcaption>
</figure>


<p>
Jeder Knoten generiert 0..n solcher Boxen.
<br>
Alle Elemente verfügen über eine "display"-Eigenschaft, die den Boxtyp bestimmt, der für sie erstellt wird. Beispiele:

<pre class="prettyprint">
block  - generates a block box.
inline - generates one or more inline boxes.
none - no box is generated.
</pre>
Das Standardelement ist "inline", aber das Browser-Stylesheet legt andere Standards fest. Die Standard-Display-Eigenschaft für das "div"-Element ist zum Beispiel "block".
<br>
Hier finden Sie ein Beispiel für ein Standard-Stylesheet: <a href="http://www.w3.org/TR/CSS2/sample.html">www.w3.org/TR/CSS2/sample.html</a>.
</p>

<h4 id="Positioning_scheme">Positionierungsschema</h4>
<p>
Es gibt drei Schemas:
<ol>
<li>Normal - das Objekt wird entsprechend seiner Platzierung im Dokument positioniert, das heißt, sein Platz im Rendering-Baum entspricht seinem Platz im DOM-Baum und es wird in Übereinstimmung mit seinem Boxtyp und seinen Abmessungen dargestellt.</li>
<li>Float - das Objekt wird zuerst wie im normalen Ablauf dargestellt und dann so weit nach links bzw. rechts wie möglich verschoben. </li>
<li>Absolut - dem Objekt wird im Rendering-Baum ein anderer Platz zugewiesen als im DOM-Baum.</li>
</ol>
</p>
<p>
Das Positionierungsschema wird von der "position"-Eigenschaft und dem "float"-Attribut bestimmt.
<ul>
<li>"Statisch" und "relativ" lösen einen normalen Ablauf aus.</li>
<li>"Absolut" und "fest" führen zu einer absoluten Positionierung.</li>
</ul>
<br>
Bei der statischen Positionierung ist keine Position definiert und die Standardpositionierung wird verwendet. Bei den anderen Schemas gibt der Autor die Position an: oben, unten, links, rechts.
</p>
<p>
Die Darstellungsart der Box wird von folgenden Elementen bestimmt:
<ul>
<li>Boxtyp</li>
<li>Boxabmessungen</li>
<li>Positionierungsschema</li>
<li>Externe Informationen wie Bildgröße und Bildschirmgröße</li>
</ul>
</p>
<h4 id="Box_types">Boxtypen</h4>
<p>
Block-Box: bildet einen Block mit einem eigenen Rechteck im Browserfenster
</p>


<figure>
  <img src="image057.png" width="150" height="127"  />
  <figcaption> <span>Abbildung </span>: Block-Box</figcaption>
</figure>

<p>
Inline-Box: verfügt nicht über einen eigenen Block, sondern befindet sich innerhalb eines übergeordneten Blocks
</p>


<figure>
  <img src="image059.png" width="300" height="233" />
  <figcaption><span>Abbildung </span>: Inline-Boxen</figcaption>
</figure>



<p>
Blöcke werden vertikal nacheinander formatiert. Inline-Boxen werden horizontal formatiert.
</p>


<figure>
  <img src="image061.png" width="350" height="324" />
  <figcaption><span>Abbildung </span>: Block- und Inline-Formatierung</figcaption>
</figure>


<p>
Inline-Boxen werden innerhalb von Zeilen oder "Zeilenboxen" platziert. Die Zeilen sind mindestens so hoch wie die höchste Box, können aber auch höher sein, wenn die Boxen an der "Basislinie" ausgerichtet sind. Das bedeutet, der untere Teil eines Elements ist an einem Punkt einer anderen Box ausgerichtet, bei dem es sich nicht um den unteren Teil handelt. Falls die Containerbreite nicht ausreicht, werden die Inline-Boxen in mehrere Zeilen aufgeteilt. Dies passiert zum Beispiel in einem Absatz.

</p>


<figure>
  <img src="image063.png" width="400" height="277" >
  <figcaption><span>Abbildung </span>: Zeilen</figcaption>
</figure>

<h3 id="Positioning">Positionierung</h3>
<h4 id="Relative">Relativ</h4>
<p>
Relative Positionierung - positioniert wie gewöhnlich und dann um das erforderliche Delta verschoben
</p>

<figure>
  <img src="image065.png" width="500" height="261" />
  <figcaption><span>Abbildung </span>: Relative Positionierung</figcaption>
</figure>

<h4 id="Floats">Floats</h4>
<p>
Eine Float-Box wird an die linke oder rechte Seite einer Zeile verschoben. Interessant ist, dass die anderen Boxen darum herum fließen. Der HTML-Code:
<pre class="prettyprint">
&lt;p&gt;
  &lt;img style="float:right" src="images/image.gif" width="100" height="100"&gt;
  Lorem ipsum dolor sit amet, consectetuer...
&lt;/p&gt;
</pre>
Dies sieht dann so aus:
</p>


<figure>
  <img src="image067.png" width="444" height="203" />
  <figcaption><span>Abbildung </span>: Float</figcaption>
</figure>


<h4 id="Absolute_and_fixed">Absolut und fest</h4>
<p>
Das Layout wird genau definiert, unabhängig von dem normalen Fluss. Das Element wird nicht in den normalen Fluss integriert. Die Abmessungen sind relativ zum Container. Bei der festen Positionierung ist der Container der Viewport.

<figure>
  <img src="image069.png" width="500" height="343" />
  <figcaption><span>Abbildung </span>: Feste Positionierung</figcaption>
</figure>


<br>
Hinweis: Die feste Box bewegt sich selbst dann nicht, wenn das Dokument gescrollt wird!
</p>
<h3 id="Layered_representation">Ebenendarstellung</h3>
<p>
Diese wird von der CSS-Eigenschaft "z-index" angegeben. Sie stellt die dritte Dimension der Box dar, ihre Position entlang der z-Achse.
</p>
<p>
Die Boxen werden in <a id="stackingcontext">Stapel</a> aufgeteilt (Stapelkontexte genannt). In jedem Stapel werden zuerst die hinteren Elemente und dann darüber die vorderen Elemente dargestellt, da sie näher am Nutzer sind. Im Falle einer Überlappung wird das vorangegangene Element ausgeblendet.
<br>
Die Stapel werden entsprechend der "z-index"-Eigenschaft angeordnet. Boxen mit "z-index"-Eigenschaft bilden einen lokalen Stapel. Der Viewport umfasst den äußeren Stapel.

<p>Beispiel:</p>

<pre class="prettyprint">
&lt;style type="text/css"&gt;
      div {
        position: absolute;
        left: 2in;
        top: 2in;
      }
&lt;/style&gt;

&lt;p&gt;
    &lt;div
         style="z-index: 3;background-color:red; width: 1in; height: 1in; "&gt;
    &lt;/div&gt;
    &lt;div
         style="z-index: 1;background-color:green;width: 2in; height: 2in;"&gt;
    &lt;/div&gt;
 &lt;/p&gt;
</pre>
Das Ergebnis sieht so aus:
</p>


<figure>
  <img src="image071.png" width="254" height="227" />
  <figcaption><span>Abbildung </span>: Feste Positionierung</figcaption>
</figure>

<p>
Obwohl das rote "div"-Element in der Auszeichnungssprache vor dem grünen steht und im regulären Ablauf davor dargestellt worden wäre, ist die "z-index"-Eigenschaft höher. Darum wird es im Stapel der Stammbox weiter nach vorne verschoben.
</p>




<h3 id="Resources">Ressourcen</h3>
<div class="autonum">
  <ol>
      <li id="1">Browserarchitektur
          <ol>
              <li id="1_1">Grosskurth, Alan. <a href="http://grosskurth.ca/papers/browser-refarch.pdf">A Reference Architecture for Web Browsers (pdf)</a>
              <li id="1_2">Gupta, Vineet. <a href="http://www.vineetgupta.com/2010/11/how-browsers-work-part-1-architecture/">How Browsers Work - Part 1 - Architecture</a>
          </ol>

      <li id="2">Parsing
          <ol>
              <li id="2_1">Aho, Sethi, Ullman, Compilers: Principles, Techniques, and Tools ("Dragon Book"), Addison-Wesley, 1986
              <li id="2_2"> Rick Jelliffe. <a href="http://broadcast.oreilly.com/2009/05/the-bold-and-the-beautiful-two.html">The Bold and the Beautiful: two new drafts for HTML 5.</a>
          </ol>

      <li id="3">Firefox
          <ol>
              <li id="3_1">L. David Baron, <a href="http://dbaron.org/talks/2008-11-12-faster-html-and-css/slide-6.xhtml">Faster HTML and CSS: Layout Engine Internals for Web Developers.</a>
              <li id="3_2">L. David Baron, <a href="http://www.youtube.com/watch?v=a2_6bGNZ7bA">Faster HTML and CSS: Layout Engine Internals for Web Developers (Google Tech Talk-Video)</a>
              <li id="3_3">L. David Baron, <a href="http://www.mozilla.org/newlayout/doc/layout-2006-07-12/slide-6.xhtml">Mozilla's Layout Engine</a>
              <li id="3_4">L. David Baron, <a href="http://www.mozilla.org/newlayout/doc/style-system.html">Mozilla Style System Documentation</a>
              <li id="3_5">Chris Waterson, <a href="http://www.mozilla.org/newlayout/doc/reflow.html">Notes on HTML Reflow</a>
              <li id="3_6">Chris Waterson, <a href="http://www.mozilla.org/newlayout/doc/gecko-overview.htm">Gecko Overview</a>
              <li id="3_7">Alexander Larsson, <a href="https://developer.mozilla.org/en/The_life_of_an_HTML_HTTP_request">The life of an HTML HTTP request</a>
          </ol>

      <li id="4">WebKit
          <ol>
              <li id="4_1">David Hyatt, <a href="http://weblogs.mozillazine.org/hyatt/archives/cat_safari.html">Implementing CSS(part 1)</a>
              <li id="4_2">David Hyatt, <a href="http://weblogs.mozillazine.org/hyatt/WebCore/chapter2.html">An Overview of WebCore</a>
              <li id="4_3">David Hyatt, <a href="http://webkit.org/blog/114/">WebCore Rendering</a>
              <li id="4_5">David Hyatt, <a href="http://webkit.org/blog/66/the-fouc-problem/">The FOUC Problem</a>
          </ol>

      <li id="5">W3C-Spezifikationen
          <ol>
              <li id="5_1"> <a href="http://www.w3.org/TR/html4/">HTML 4.01-Spezifikation</a>
              <li id="5_2"> <a href="http://dev.w3.org/html5/spec/Overview.html">W3C-HTML5-Spezifikation</a>
              <li id="5_3"> <a href="http://www.w3.org/TR/CSS2/">Cascading Style Sheets Level 2 Revision 1 (CSS 2.1) - Spezifikation</a>
          </ol>

      <li>Anleitungen zum Browseraufbau
          <ol>
              <li>Firefox: <a href="https://developer.mozilla.org/de/Entwicklerhandbuch/Build_Anweisungen">https://developer.mozilla.org/de/Entwicklerhandbuch/Build_Anweisungen</a>
              <li>WebKit: <a href="http://webkit.org/building/build.html">http://webkit.org/building/build.html</a>
          </ol>

  </ol>

  <!--  -->

</div>


</div>

<aside class="bio">

  <img align=left src="/static/images/profiles/taligarsiel.png">
  <p><a href="http://taligarsiel.com/">Tali Garsiel</a> arbeitet als Entwicklerin in Israel. Sie hat im Jahr 2000 als Webentwicklerin angefangen und sich bald mit dem "teuflischen" Ebenenmodell von Netscape vertraut gemacht. Wie Richard Feynman war sie schon immer fasziniert davon herauszufinden, wie die Dinge funktionieren. Also ist sie tiefer in das Innenleben von Browsern eingetaucht und hat ihre Ergebnisse dokumentiert. Tali hat auch einen kurzen <a href="http://taligarsiel.com/ClientSidePerformance.html">Leitfaden zur clientseitigen Leistung</a> veröffentlicht. </p>

</aside>


<h4>Übersetzungen</h4>
<p>Diese Seite wurde ins Japanische übersetzt - zweimal! <a href="http://cou929.nu/docs/how-browsers-work/">Funktionsweise von Browsern: Hinter den Kulissen moderner Webbrowser (ja)</a> von <a href="https://twitter.com/#!/_kosei_">@_kosei_</a> sowie <a href="http://shanon-tech.blogspot.com/2011/09/web.html">ブラウザってどうやって動いてるの？（モダンWEBブラウザシーンの裏側</a> von <a href="https://twitter.com/#!/ikeike443">@ikeike443</a> und <a href="https://twitter.com/#!/kiyoto01">@kiyoto01</a>. Vielen Dank an alle!</p>

<script>
var toc = $('ol.toc');

function getReffedElem(elem){
  return $($(elem).attr('href'));
}

$(function(){

toc
  .find(' > li > a').each(function(i, elem) {
    // top level chapters get a preceding line
    $('<h5 class="tocchap"></h5>')
      .text('Chapter ' + (i + 1))
      .insertBefore(getReffedElem(elem));

    $(elem).parent().find(' > ol > li > a').each(function(j, elem2) {
      $('<span class="tocnum"></span>')
        .text( (i + 1) + '.' + (j + 1) + ' ')
        .prependTo(getReffedElem(elem2));

      $(elem2).parent().find(' > ol > li > a').each(function(k, elem3) {
        $('<span class="tocnum"></span>')
          .text( (i + 1) + '.' + (j + 1) + '.' + (k + 1) + ' ')
          .prependTo(getReffedElem(elem3));
      });
    });
  });
});


$('figcaption span').each(function(i, elem) {
  elem.setAttribute('data-count', i + 1);
});
  //console.log(elem, $(elem).attr('href'),  $('a[name="' +  )
</script>


{% endblock %}