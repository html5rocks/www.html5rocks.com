{% extends "tutorial.html" %}

{% block headauthor %}Tali Garsiel <tgarsiel@gmail.com>{% endblock %}
{% block pageauthor %}{% profilelinks taligarsiel paulirish %}{% endblock %}
{% block headtitle %}Cómo funcionan los navegadores: lo que hay detrás de los navegadores web actuales{% endblock %}
{% block pagetitle %}<b>Cómo funcionan los navegadores: </b> lo que hay detrás de los navegadores web actuales{% endblock %}
{% block head %}

{% endblock %}
{% block pagebreadcrumb %}Cómo funcionan los navegadores: lo que hay detrás de los navegadores web actuales{% endblock %}
{% block date %}16 de agosto de 2011{% endblock %}
{% block updated %}{% endblock %}
{% block onload %}{% endblock %}

{% block browsersupport %}
<span class="browser opera supported"><span class="browser_name">Compatible con </span><span class="support">Chrome</span></span> <span class="browser ie supported"><span class="browser_name">Compatible con </span><span class="support">Internet Explorer</span></span> <span class="browser safari supported"><span class="browser_name">Compatible con </span><span class="support">Safari</span></span> <span class="browser ff supported"><span class="browser_name">Compatible con </span><span class="support">Firefox</span></span> <span class="browser chrome supported"><span class="browser_name">Compatible con </span><span class="support">Chrome</span></span>
{% endblock %}

{% block iscompatible %}

{% endblock %}


{% block content %}


<style>
  h1 b { display:block; font-size: 58px;}
  .browser_support, #html5badge, #html5badge + nav { display:none; }
  a[name] { color: currentColor; }
  blockquote { opacity: 0.9; border-left: 8px solid #ccc; padding-left: 20px; }
  body { line-height: 1.3; }
  li { margin: 3px 0;}
  h3 { font-size: 19px; }
  h4 { font-size: 15.5px; }
  h5 { font-size: 14px; }
  #stack { margin: 5px auto;}
  #stack td, #stack th { border-bottom: 1px dotted #999; }
  samp { background-color: #f2f2f2; border-radius: 2px; padding: 0 2px; }
  samp:empty { display:none; }
  ol.toc { padding-left: 20px; line-height: 1.1; }
  .autonum *:target { background: hsl(60, 73%, 93%);}
  cite { display:block; text-align: right; font-size: 80%; }
  figcaption span:after { content: attr(data-count) ; }

  .tocchap, .tocnum { cursor: default; }
  .tocchap { color: hsl(0, 0%, 60%); margin-bottom: 0; margin-top: 30px; }
  .tocchap + * { margin-top: 5px; }
  h2, h3, h4, h5 { position: relative; }
  .tocnum { position: absolute; left: -56px; width: 50px; text-align: right; font-size: 70%; top: 3px;
    color: hsl(0, 0%, 80%);
    -webkit-transition: all 0.3s ease-out;
       -moz-transition: all 0.3s ease-out;
        -ms-transition: all 0.3s ease-out;
         -o-transition: all 0.3s ease-out;
            transition: all 0.3s ease-out;
  }
  h2:hover .tocnum, h3:hover .tocnum, h4:hover .tocnum, h5:hover .tocnum { color: hsl(0, 0%, 20%); }
  .preface + hr + .tocchap { visibility: hidden;  }
  aside.bio  { border: 3px double hsl(0, 0%, 80%); padding: 10px; }
  aside.bio img { width: 70px; margin: 0 10px 0 0; border: 1px solid hsl(0, 0%, 50%); }
  aside.bio p { margin: 0; }
</style>
<script >
  [].forEach.call( document.querySelectorAll('header .date a'), function(elem, i) {
    elem.textContent += ' (' + ['author','editor'][i] + ')';
  });
</script>

<div class="preface">
<h2>Prólogo</h2>
<p>
  Este completo manual sobre las operaciones internas de WebKit y Gecko es el resultado de las extensas investigaciones realizadas por la desarrolladora israelí Tali Garsiel. Durante varios años ha estado revisando toda la información publicada sobre las características internas de los navegadores web <small>(consulta la sección <a href="#Resources">Recursos</a>)</small> y ha pasado mucho tiempo leyendo su código fuente. Tali escribió lo siguiente:

  <blockquote>
    "En los años en los que Internet Explorer acaparaba el 90% del mercado, el navegador se podía considerar poco más que "caja negra", pero ahora que los navegadores de código abierto dominan <a href="http://techcrunch.com/2011/08/01/open-web-browsers/">más de la mitad del mercado</a>, es un buen momento para echar un vistazo al interior de los navegadores y ver lo que esconden. Bueno, lo que esconden millones de líneas de código en C++..."
  </blockquote>
  Tali ha publicado su investigación en <a href="http://taligarsiel.com/">su sitio web</a>, pero como sabíamos que se merecía un público más amplio, lo hemos publicado aquí también tras hacer algunas modificaciones.

<p>
  Como desarrolladora web, <strong>conocer las características internas de las operaciones de los navegadores sirve para tomar mejores decisiones y para conocer los motivos que justifican las prácticas de desarrollo recomendadas</strong>. Aunque se trata de un documento bastante extenso, te recomendamos que dediques un poco de tu tiempo a examinarlo. Ten por seguro que no te arrepentirás.

  <cite>Paul Irish, Relaciones con desarrolladores de Chrome</cite>


</div>

<hr>

<h2 id="Introduction">Introducción</h2>
<p>
Los navegadores son probablemente el software más utilizado de todos. En este manual se explica su funcionamiento interno. Veremos qué ocurre cuando escribes <code>google.com</code> en la barra de direcciones hasta que la página de Google aparece en la pantalla.
</p>

<h3>Índice</h3>

<ol class="toc">
<li><a href="#Introduction">Introducción</a>
<ol>
  <li><a href="#The_browsers_we_will_talk_about">Los navegadores de los que hablaremos</a></li>
  <li><a href="#The_browser_main_functionality">La función principal de un navegador</a></li>
  <li><a href="#The_browser_high_level_structure">Componentes principales del navegador</a></li>
</ol>
</li>
<li><a href="#The_rendering_engine">El motor de renderización</a>
<ol>
  <li><a href="#Rendering_engines">Motores de renderización</a></li>
  <li><a href="#The_main_flow">El flujo principal</a></li>
  <li><a href="#Main_flow_examples">Ejemplos del flujo principal</a></li>
</ol>
</li>
<li><a href="#Parsing_general">Análisis y construcción del árbol de DOM</a>
<ol>
  <li><a href="#Parsing_general">Análisis (general)</a>
  <ol>
      <li><a href="#Grammars">Gramáticas</a></li>
      <li><a href="#Parser_Lexer_combination">Analizador: combinación de analizadores léxicos</a></li>
      <li><a href="#Translation">Traducción</a></li>
      <li><a href="#Parsing_example">Ejemplo de análisis</a></li>
      <li><a href="#Formal_definitions_for_vocabulary_and_syntax">Definiciones formales de vocabulario y sintaxis</a></li>
      <li><a href="#Types_of_parsers">Tipos de analizadores</a></li>
    <li><a href="#Generating_parsers_automatically">Cómo generar analizadores automáticamente</a></li>
  </ol>
  </li>
  <li><a href="#HTML_Parser">Analizador de HTML</a>
  <ol>
      <li><a href="#The_HTML_grammar_definition">Definición de gramática HTML</a></li>
      <li><a href="#Not_a_context_free_grammar">No es una gramática libre de contexto</a></li>
      <li><a href="#HTML_DTD">DTD de HTML</a></li>
    <li><a href="#DOM">DOM</a></li>
      <li><a href="#The_parsing_algorithm">El algoritmo de análisis</a></li>
      <li><a href="#The_tokenization_algorithm">El algoritmo de tokenización</a></li>
    <li><a href="#Tree_construction_algorithm">Algoritmo de construcción de árbol</a></li>
      <li><a href="#Actions_when_the_parsing_is_finished">Acciones al finalizar el análisis</a></li>
      <li><a href="#Browsers_error_tolerance">Tolerancia a errores de los navegadores</a></li>
  </ol>
  </li>
  <li><a href="#CSS_parsing">Análisis de CSS</a>
  <ol>
    <li><a href="#Webkit_CSS_parser">Analizador de CSS de WebKit</a></li>
  </ol>
  </li>
  <li><a href="#The_order_of_processing_scripts_and_style_sheets">Orden de procesamiento de secuencias de comandos y hojas de estilo</a>
  <ol>
      <li><a href="#Scripts">Secuencias de comandos</a></li>
      <li><a href="#Speculative_parsing">Análisis especulativo</a></li>
      <li><a href="#Style_sheets">Hojas de estilo</a></li>
  </ol>
  </li>
</ol>
</li>
<li><a href="#Render_tree_construction">Construcción del árbol de renderización</a>
<ol>
  <li><a href="#The_render_tree_relation_to_the_DOM_tree">Relación del árbol de renderización con el árbol de DOM</a></li>
  <li><a href="#The_flow_of_constructing_the_tree">El flujo de construcción del árbol</a></li>
  <li><a href="#Style_Computation">Computación de estilos</a>
<ol>
    <li><a href="#Sharing_style_data">Datos de estilo compartidos</a></li>
    <li><a href="#Firefox_rule_tree">Árbol de reglas de Firefox</a>
<ol>
      <li><a href="#Division_into_structs">División en estructuras</a></li>
      <li><a href="#Computing_the_style_contexts_using_the_rule_tree">Cómo computar los contextos de estilo con el árbol de reglas</a></li>
    </ol>
</li>
    <li><a href="#Manipulating_the_rules_for_an_easy_match">Cómo manipular las reglas para obtener coincidencias fácilmente</a></li>
<li><a href="#Applying_the_rules_in_the_correct_cascade_order">Cómo aplicar las reglas en el orden de cascada correcto</a>
<ol>
    <li><a href="#Style_sheet_cascade_order">Orden en cascada de la hoja de estilo</a></li>
<li><a href="#Specificity">Especificidad</a></li>
<li><a href="#Sorting_the_rules">Cómo ordenar las reglas</a></li>
</ol>
</li>
</ol>
</li>
<li><a href="#Gradual_process">Proceso gradual</a></li>
</ol>
</li>
<li><a href="#Layout">Diseño</a>
  <ol>
    <li><a href="#Dirty_bit_system">Sistema de bit de modifiación (dirty bit)</a></li>
    <li><a href="#Global_and_incremental_layout">Diseño global e incremental</a></li>
    <li><a href="#Asynchronous_and_Synchronous_layout">Diseño asíncrono y síncrono</a></li>
    <li><a href="#Optimizations">Optimizaciones</a></li>
<li><a href="#The_layout_process">El proceso de diseño</a></li>
    <li><a href="#Width_calculation">Cálculo del ancho</a></li>
    <li><a href="#Line_Breaking">Salto de línea</a></li>
  </ol>
 </li>
<li><a href="#Painting">Pintura</a>
  <ol>
    <li><a href="#Global_and_Incremental">Global e incremental</a></li>
    <li><a href="#The_painting_order">Orden del proceso de pintura</a></li>
    <li><a href="#Firefox_display_list">Lista de visualización de Firefox</a></li>
    <li><a href="#Webkit_rectangle_storage">Almacenamiento de figuras rectangulares de WebKit</a></li>
  </ol>
 </li>
<li><a href="#Dynamic_changes">Cambios dinámicos</a></li>
<li><a href="#The_rendering_engines_threads">Subprocesos del motor de renderización</a>
<ol>
    <li><a href="#Event_loop">Bucle de eventos</a></li>
  </ol>
</li>
<li><a href="#css">Modelo de formato visual de CSS2</a>
  <ol>
    <li><a href="#The_canvas">El elemento canvas</a></li>
    <li><a href="#CSS_Box_model">Modelo de cajas de CSS</a></li>
    <li><a href="#Positioning_scheme">Esquema de posicionamiento</a></li>
    <li><a href="#Box_types">Tipos de cajas</a></li>
<li><a href="#Positioning">Posicionamiento</a>
<ol>
      <li><a href="#Relative">Relativo</a></li>
      <li><a href="#Floats">Flotante</a></li>
  <li><a href="#Absolute_and_fixed">Absoluto y fijo</a></li>
</ol>
</li>
<li><a href="#Layered_representation">Representación en capas</a></li>
  </ol>
 </li>
<li><a href="#Resources">Recursos</a></li>
</ol>



<div>

<h3 id="The_browsers_we_will_talk_about">Los navegadores de los que hablaremos</h3>
<p>
En la actualidad se utilizan principalmente cinco navegadores: Internet Explorer, Firefox, Safari, Chrome y Opera. Los ejemplos de este documento se refieren a navegadores de código abierto, como Firefox, Chrome y Safari (este último es en parte de código abierto). Según las <a href="http://gs.statcounter.com/">estadísticas sobre navegadores de StatCounter</a>, actualmente (agosto de 2011) el uso conjunto de Firefox, Safari y Chrome representa el 60%. Por tanto, en estos momentos los navegadores de código abierto constituyen una parte importante del mercado de los navegadores.
</p>

<h3 id="The_browser_main_functionality">La función principal de un navegador</h3>
<p>
La función principal de un navegador es solicitar al servidor los recursos web que elija el usuario y mostrarlos en una ventana. El recurso suele ser un documento HTML, pero también puede ser un archivo PDF, una imagen o un objeto de otro tipo. El usuario especifica la ubicación del recurso mediante el uso de una URI (siglas de Uniform Resource Identifier, identificador uniforme de recurso).
</p>
<p>
La forma en la que el navegador interpreta y muestra los archivos HTML se determina en las especificaciones de CSS y HTML. Estas especificaciones las establece el consorcio <a id="w3c">W3C</a> (World Wide Web Consortium), que es la organización de estándares de Internet.
<br>
<!-- The current version of HTML is 4 (<a href="http://www.w3.org/TR/html401/">http://www.w3.org/TR/html401/</a>). Version 5 is in progress.
The current CSS version is 2 (<a href="http://www.w3.org/TR/CSS2/">http://www.w3.org/TR/CSS2/</a>) and version 3 is in progress.
<br> -->
Durante años, los navegadores cumplían solo una parte de las especificaciones y desarrollaban sus propias extensiones. Esto provocó graves problemas de compatibilidad para los creadores de contenido web. En la actualidad, la mayoría de los navegadores cumplen las especificaciones en mayor o menor grado.
</p>
<p>
Las interfaces de usuario de los distintos navegadores tienen muchos elementos en común. Estos son algunos de los elementos comunes de las interfaces de usuario:
<ul>
<li>una barra de direcciones donde insertar las URI,</li>
<li>botones de avance y retroceso,</li>
<li>opciones de marcadores,</li>
<li>un botón para detener la carga de los documentos actuales y otro para volver a cargarlos,</li>
<li>un botón de inicio que permite volver a la página de inicio.</li>
</ul>

<p>
Estas coincidencias resultan extrañas, ya que la interfaz de usuario de los navegadores no se incluye en ninguna de las especificaciones formales, sino que procede de la experiencia acumulada a lo largo de los años y de los elementos que los navegadores han imitado unos de otros. La especificación de HTML5 no define los elementos que debe incluir la interfaz de usuario de los navegadores, pero muestra algunos elementos comunes. Entre estos elementos se encuentran la barra de direcciones, la barra de estado y la barra de herramientas. Existen, por supuesto, características únicas de cada navegador, como el administrador de descargas de Firefox.
</p>
<h3 id="The_browser_high_level_structure">Componentes principales del navegador</h3>
<p>
A continuación se especifican los componentes principales de un navegador (<a href="#1_1">1.1</a>).
</p>

<ol>

  <li><strong>Interfaz de usuario:</strong> incluye la barra de direcciones, el botón de avance/retroceso, el menú de marcadores, etc. (en general, todas las partes visibles del navegador, excepto la ventana principal donde se muestra la página solicitada).</li>
  <li><strong>Motor de búsqueda:</strong> coordina las acciones entre la interfaz y el motor de renderización.</li>
  <li><strong>Motor de renderización:</strong> es responsable de mostrar el contenido solicitado. Por ejemplo, si el contenido solicitado es HTML, será el responsable de analizar el código HTML y CSS y de mostrar el contenido analizado en la pantalla.</li>
  <li><strong>Red:</strong> es responsable de las llamadas de red, como las solicitudes HTTP. Tiene una interfaz independiente de la plataforma y realiza implementaciones en segundo plano para cada plataforma.</li>
  <li><strong>Servidor de la interfaz:</strong> permite presentar widgets básicos, como ventanas y cuadros combinados. Muestra una interfaz genérica que no es específica de ninguna plataforma. Utiliza métodos de la interfaz de usuario del sistema operativo en segundo plano.</li>
  <li><strong>Intérprete de JavaScript:</strong> permite analizar y ejecutar el código JavaScript.</li>
  <li><strong>Almacenamiento de datos:</strong> es una capa de persistencia. El navegador necesita guardar todo tipo de datos en el disco duro (por ejemplo, las cookies). La nueva especificación de HTML (HTML5) define el concepto de "base de datos web", que consiste en una completa (aunque ligera) base de datos del navegador.</li>

</ol>


<figure>
  <img src="layers.png" width="500" height="339" alt="" title="" />
  <figcaption><span>Figura </span>: componentes principales del navegador</figcaption>
</figure>


<p>
Es importante decir que Chrome, a diferencia de la mayoría de los navegadores, implementa varias instancias del motor de renderización, una por cada pestaña. Cada pestaña representa un proceso independiente.
</p>

<h2 id="The_rendering_engine">El motor de renderización</h2>
<p>
La responsabilidad del motor de renderización es "renderizar", es decir, mostrar el contenido solicitado en la pantalla del navegador.
</p>
<p>
De forma predeterminada, el motor de renderización puede mostrar imágenes y documentos HTML y XML. Puede mostrar otros tipos mediante el uso de complementos (o extensiones); por ejemplo, puede mostrar documentos PDF mediante un complemento capaz de leer archivos PDF. Sin embargo, en este capítulo nos centraremos en su uso principal: mostrar imágenes y código HTML con formato definido con CSS.</p>

<h3 id="Rendering_engines">Motores de renderización</h3>
<p>
Nuestros navegadores de referencia (Firefox, Chrome y Safari) están basados en dos motores de renderización. Firefox utiliza Gecko, un motor de renderización propio de Mozilla. Tanto Safari como Chrome utilizan WebKit.
</p>
<p>
WebKit es un motor de renderización de código abierto que empezó siendo un motor de la plataforma Linux y que fue modificado posteriormente por Apple para hacerlo compatible con Mac y Windows. Puedes obtener más información en <a href="http://webkit.org/">webkit.org</a>.
</p>

<h3 id="The_main_flow">El flujo principal</h3>
<p>
El motor de renderización empieza recibiendo el contenido del documento solicitado desde la capa de red, normalmente en fragmentos de 8.000 bytes.
</p>
<p>
A continuación, el motor de renderización realiza este flujo básico:

</p>

<figure>
  <img src="flow.png" width="600" height="66" alt="" title=""   />
  <figcaption><span>Figura </span>: flujo básico del motor de renderización</figcaption>
</figure>


<p>
El motor de renderización empieza a analizar el documento HTML y convierte las etiquetas en nodos <a href="#DOM">DOM</a> en un árbol denominado "árbol de contenido". Analiza los datos de estilo, tanto en los archivos CSS externos como en los elementos de estilo. Los datos de estilo, junto con las instrucciones visuales del código HTML, se utilizan para crear otro árbol: el <a href="#Render_tree_construction">árbol de renderización</a>.
</p>
<p>
El árbol de renderización contiene rectángulos con atributos visuales, como el color y las dimensiones. Los rectángulos están organizados en el orden en el que aparecerán en la pantalla.
</p>
<p>
Una vez construido el árbol de renderización, se inicia un proceso de "<a href="#layout">diseño</a>". Esto significa que a cada nodo se le asignan las coordenadas exactas del lugar de la pantalla en el que debe aparecer. La siguiente fase es la de <a href="#Painting">pintura</a>, en la que se recorre el árbol de renderización y se pinta cada uno de los nodos utilizando la capa de servidor de la interfaz de usuario.
</p>
<p>
Es importante comprender que se trata de un proceso gradual. Para mejorar la experiencia del usuario, el motor de renderización intentará mostrar el contenido en pantalla lo antes posible. No esperará a que se analice el código HTML para empezar a crear y diseñar el árbol de renderización. Se analizarán y se mostrarán algunas partes del contenido, mientras que se sigue procesando el resto del contenido que llega de la red.
</p>

<h4 id="Main_flow_examples">Ejemplos del flujo principal</h4>

  <figure>
    <img src="webkitflow.png" width="624" height="289" alt=""  />
    <figcaption><span>Figura </span>: flujo principal de WebKit</figcaption>
  </figure>


  <figure>
    <img src="image008.jpg" width="624" height="290" alt="" />
    <figcaption><span>Figura </span>: flujo principal del motor de renderización Gecko de Mozilla (<a href="#3_6">3.6</a>)</figcaption>
  </figure>


<p>
En las figuras 3 y 4 se puede ver que, aunque WebKit y Gecko utilizan una terminología ligeramente diferente, el flujo es básicamente el mismo.
<p>
Gecko denomina al árbol de elementos formateados visualmente "árbol de marcos". Cada uno de los elementos es un marco. WebKit utiliza los términos "árbol de renderización" y "objetos de renderización" en lugar de los anteriores. WebKit utiliza el término "diseño" para colocar los elementos, mientras que Gecko lo denomina "reflujo". WebKit utiliza el término "asociación" para conectar los nodos DOM con información visual para crear el árbol de renderización. Una pequeña diferencia no semántica es que Gecko dispone de una capa extra entre el código HTML y el árbol de DOM. Esta capa se denomina "depósito de contenido" y está dedicada a la creación de elementos DOM. Vamos a ver cada una de las partes del flujo:
<p>
<h3 id="Parsing_general">Análisis (general)</h3>
<p>
Dado que el análisis es un proceso muy importante del motor del renderización, vamos a verlo de una forma más detallada. Comencemos por una breve introducción a este proceso.
</p>
<p>
Analizar un documento significa traducirlo a una estructura que tenga sentido, es decir, algo que el código pueda comprender y utilizar. El resultado del análisis suele ser un árbol de nodos que representa la estructura del documento. Este árbol se denomina "árbol de análisis" o "árbol de sintaxis".
</p>

<p>
Ejemplo: el análisis de la expresión <samp>2 + 3 - 1</samp> podría dar como resultado este árbol:

</p>



<figure>
  <img src="image009.png" width="400" height="155" />
  <figcaption> <span>Figura </span>: nodo de árbol de expresión matemática</figcaption>
</figure>

<h4 id="Grammars">Gramáticas</h4>
<p>
El análisis se basa en las reglas de sintaxis por las que se rige el documento, es decir, el lenguaje o el formato en el que está escrito. Todos los formatos que se pueden analizar deben tener una gramática determinista formada por un vocabulario y unas reglas de sintaxis. Esto se denomina <a href="#context_free_grammar">gramática libre de contexto</a>. Los lenguajes humanos no son de este tipo y, por tanto, no se pueden analizar con técnicas de análisis convencionales.
</p>
<h4 id="Parser_Lexer_combination">Analizador: combinación de analizadores léxicos</h4>
<p>
El proceso de análisis se puede dividir en dos subprocesos: análisis léxico y análisis sintáctico.
</p>
<p>
El análisis léxico es el proceso de descomponer los datos de entrada en tokens. Los tokens son el vocabulario del lenguaje, un conjunto de bloques de construcción válidos. En el lenguaje humano, equivaldría a todas las palabras que aparecen en el diccionario de un determinado idioma.
</p>
<p>
El análisis sintáctico es la aplicación de las reglas sintácticas del lenguaje.
</p>
<p>
Los analizadores normalmente dividen el trabajo entre dos componentes: el <b>analizador léxico</b> (a veces denominado "tokenizador"), responsable de descomponer los datos de entrada en tokens válidos, y el <b>analizador normal</b>, responsable de construir el árbol tras analizar la estructura del documento según las reglas sintácticas del lenguaje. El analizador léxico es capaz de ignorar caracteres irrelevantes, como espacios en blanco y saltos de línea.
</p>

<figure>
  <img src="image011.png" width="101" height="300" />
  <figcaption>  <span>Figura </span>: del documento original al árbol de análisis</figcaption>
</figure>

<p>
El proceso de análisis es iterativo. El analizador normalmente pide al analizador léxico un nuevo token e intenta buscar coincidencias entre el token y una de las reglas de sintaxis. Si se encuentra una coincidencia, se añade al árbol de análisis un nodo correspondiente al token y el analizador solicita otro token.
<p>
Si no coincide con ninguna regla, el analizador almacena el token internamente y sigue solicitando tokens hasta que encuentra una regla que coincide con todos los tokens almacenados internamente. Si no encuentra ninguna regla, lanza una excepción. Esto significa que el documento no se considera válido por tener errores de sintaxis.
</p>
<h4 id="Translation">Traducción</h4>
<p>
Muchas veces, el árbol de análisis no es el producto final. El análisis se utiliza frecuentemente en la traducción, es decir, en la conversión del documento de entrada a otro formato. Un ejemplo sería la compilación. El compilador, que compila un código fuente en código de máquina, en primer lugar lo convierte en un árbol de análisis y, a continuación, traduce el árbol a un documento de código de máquina.
</p>


<figure>
  <img src="image013.png" width="104" height="400" />
  <figcaption><span>Figura </span>: flujo de compilación</figcaption>
</figure>


<h4 id="Parsing_example">Ejemplo de análisis</h4>
<p>
En la figura 5 se observa un árbol de análisis creado a partir de una expresión matemática. Intentemos definir un lenguaje matemático simple y veamos el proceso de análisis.
<p>
<p>
Vocabulario: nuestro lenguaje puede incluir números enteros, el signo más y el signo menos.
</p>
<p>
Sintaxis:
<ol>
<li> Los bloques de construcción de la sintaxis del lenguaje son expresiones, términos y operaciones.
<li> Nuestro lenguaje puede incluir cualquier cantidad de expresiones.</li>
<li> Una expresión está formada por un "término" seguido de una "operación" y de otro término.</li>
<li> Una operación es un token de suma o un token de resta.</li>
<li> Un término es un token de número entero o una expresión.</li>
</ol>
</p>
<p>
  Analicemos la entrada <samp>2 + 3 - 1</samp>.
  <br>
  La primera subcadena que coincide con una regla es <samp>2</samp>; según la regla 5, es un término. La segunda coincidencia es <samp>2 + 3</samp>, que coincide con la tercera regla (un término seguido de una operación y de otro término). La siguiente coincidencia solo se utilizará al final de la entrada. <samp>2 + 3 - 1</samp> es una expresión porque ya sabemos que <samp>2+3</samp> es un término, así que tenemos un término seguido de una operación y de otro término. <samp>2 + + </samp>no coincide con ninguna regla, por lo que no sería una entrada válida.
</p>
<h4 id="Formal_definitions_for_vocabulary_and_syntax">Definiciones formales de vocabulario y sintaxis</h4>
<p>
El vocabulario se suele expresar mediante <a href="http://www.regular-expressions.info/">expresiones regulares</a>.
</p>
<p>
Por ejemplo, nuestro lenguaje se definirá de la siguiente forma:
<pre class="prettyprint">
INTEGER :0|[1-9][0-9]*
PLUS : +
MINUS: -
</pre>
Como se puede observar, los números enteros se definen mediante una expresión regular.
</p>
<p>
La sintaxis normalmente se define en un formato denominado <a href="http://es.wikipedia.org/wiki/Notaci%C3%B3n_de_Backus-Naur">notación de Backus-Naur</a> (BNF). Nuestro idioma se definirá de la siguiente forma:
<pre class="prettyprint">
expression :=  term  operation  term
operation :=  PLUS | MINUS
term := INTEGER | expression
</pre>
</p>
<p>
Dijimos que un lenguaje se puede analizar mediante analizadores normales si su gramática es una <a id="context_free_grammar">gramática libre de contexto</a>. Una definición intuitiva de una gramática libre de contexto es una gramática que se puede expresar completamente en notación de Backus-Naur (BNF). Puedes consultar una definición formal en <a href="http://es.wikipedia.org/wiki/Gram%C3%A1tica_libre_de_contexto">este artículo de Wikipedia sobre las gramáticas libres de contexto</a>.
<h4 id="Types_of_parsers">Tipos de analizadores</h4>
<p>
Existen dos tipos básicos de analizadores: los descendentes y los ascendentes. Utilizando una explicación intuitiva, podríamos decir que los analizadores descendentes comprueban la estructura de nivel superior de la sintaxis e intentan buscar una coincidencia, mientras que los analizadores ascendentes comienzan con los datos de entrada y los van transformando gradualmente mediante las reglas sintácticas empezando por el nivel más bajo hasta que se cumplen las reglas de nivel superior.
</p>
<p>
Veamos cómo analizan el contenido de ejemplo estos dos tipos de analizadores:
</p>
<p>
Un analizador descendente empieza desde la regla de nivel superior: identifica <samp>2 + 3</samp> como una expresión. A continuación, identifica <samp>2 + 3 - 1</samp> como expresión (el proceso de identificar la expresión se desarrolla buscando coincidencias con el resto de las reglas, pero se empieza por la regla de nivel superior).
</p>
<p>
El analizador ascendente analiza los datos de entrada hasta que encuentra una coincidencia con una regla y, a continuación, sustituye la entrada coincidente con la regla. Este proceso continúa hasta que se analizan todos los datos de entrada. Las expresiones con coincidencias parciales se colocan en la pila del analizador.
<table id="stack">
  <tr><th>Pila</th>                <th>Entrada</th></tr>
  <tr><td>&nbsp;</td>               <td><samp>2 + 3 - 1 </samp></td></tr>
  <tr><td>término</td>                 <td><samp> + 3 - 1 </samp></td></tr>
  <tr><td>operación del término</td>       <td><samp> 3 - 1 </samp></td></tr>
  <tr><td>expresión</td>           <td><samp>- 1 </samp></td></tr>
  <tr><td>operación de la expresión</td> <td><samp>1 </samp></td></tr>
  <tr><td>expresión</td>           <td><samp>&nbsp; </samp></td></tr>
</table>
Este tipo de analizador ascendente se conoce como analizador de desplazamiento-reducción debido a que los datos de entrada se desplazan hacia la derecha (imagina un puntero que apunta primero al inicio de los datos de entrada y a continuación se desplaza hacia la derecha) y gradualmente se reducen según las reglas sintácticas.
</p>
<h4 id="Generating_parsers_automatically">Cómo generar analizadores automáticamente</h4>
<p>
Existen herramientas capaces de generar analizadores automáticamente. Se denominan generadores de analizadores. Estos generadores crean automáticamente un analizador funcional utilizando la gramática del lenguaje (vocabulario y reglas sintácticas) establecida por el desarrollador. Los generadores de analizadores son muy útiles, ya que, para crear un analizador, es necesario disponer de un profundo conocimiento del proceso de análisis, y no resulta fácil crear manualmente un analizador optimizado.
</p>
<p>
<a id="parser_generators">WebKit</a> utiliza dos generadores de analizadores muy conocidos: <a href="http://en.wikipedia.org/wiki/Flex_lexical_analyser">Flex</a>, para crear un analizador léxico, y <a href="http://www.gnu.org/software/bison/">Bison</a>, para crear un analizador normal (también se conocen como "Lex" y "Yacc"). La entrada de Flex consiste en un archivo con definiciones de expresiones regulares de los tokens. La entrada de Bison consiste en las reglas sintácticas del lenguaje en formato BNF.
</p>
<h3 id="HTML_Parser">Analizador de HTML</h3>
<p>
El trabajo del analizador de HTML es analizar las marcas HTML y organizarlas en un árbol de análisis.
</p>
<h4 id="The_HTML_grammar_definition">Definición de gramática HTML</h4>
<p>
Es la sintaxis y el vocabulario definidos en las <a href="#w3c">especificaciones</a> creadas por la organización W3C. La versión actual es HTML4 y actualmente se está trabajando en HTML5.
</p>
<h4 id="Not_a_context_free_grammar">No es una gramática libre de contexto</h4>
<p>
Como ya vimos en la introducción al análisis, la sintaxis de la gramática se puede definir formalmente mediante formatos como BNF.
</p><p>
Lamentablemente, no todos los temas sobre analizadores convencionales se pueden aplicar al lenguaje HTML (los he incluido porque se utilizarán en el análisis de CSS y JavaScript). El lenguaje HTML no se puede definir fácilmente mediante la gramática libre de contexto que necesitan los analizadores.
</p><p>
Existe un formato formal para definir el lenguaje HTML: DTD (definición de tipo de documento); sin embargo, no es una gramática libre de contexto.
</p><p>
Parece algo extraño a primera vista: el lenguaje HTML es bastante similar al XML. Hay una gran variedad de analizadores de XML disponibles. Existe una variación XML del lenguaje HTML, el XHTML, así que, ¿cuál es la diferencia?
</p><p>
La diferencia radica en que el lenguaje HTML es más "permisivo", ya que permite omitir ciertas etiquetas que se añaden de forma implícita, a veces se omite el principio o el final de las etiquetas, etc. En conjunto, es una sintaxis "flexible", en oposición a la sintaxis rígida y exigente del lenguaje XML.
</p><p>
Esta diferencia aparentemente pequeña es, en realidad, abismal. Por un lado, esta es la razón principal por la que el HTML es tan popular: permite errores y facilita las cosas a los autores de contenido web. Por otro lado, hace que resulte difícil escribir una gramática formal. En resumen: el lenguaje HTML no se puede analizar fácilmente mediante analizadores convencionales (porque no dispone de una gramática libre de contexto) ni mediante analizadores de XML.
</p>
<h4 id="HTML_DTD">DTD DE HTML</h4>
<p>
La definición de HTML está en formato DTD. Este formato se utiliza para definir lenguajes de la familia <a href="http://es.wikipedia.org/wiki/SGML">SGML</a>. Contiene definiciones de todos los elementos permitidos, de sus atributos y de su jerarquía. Como vimos antes, la definición DTD del lenguaje HTML no forma una gramática libre de contexto.
</p>
<p>
Existen algunas variaciones de la definición DTD. El modo estricto se ajusta únicamente a las especificaciones, pero otros modos admiten el marcado utilizado anteriormente por los navegadores. El objetivo es mantener la compatibilidad con el contenido más antiguo. La definición DTD estricta actual se encuentra en la siguiente página: <a href="http://www.w3.org/TR/html4/strict.dtd">www.w3.org/TR/html4/strict.dtd</a>
</p>
<h4 id="DOM">DOM</h4>
<p>
El árbol de salida ("árbol de análisis") está formado por elementos DOM y nodos de atributo. DOM son las siglas de "Document Object Model" (modelo de objetos del documento). Es la presentación de objetos del documento HTML y la interfaz de los elementos HTML para el mundo exterior, como JavaScript.
<br>
La raíz del árbol es el objeto <a  href="http://www.w3.org/TR/1998/REC-DOM-Level-1-19981001/level-one-core.html#i-Document">Document</a>.
</p>
<p>
El modelo DOM guarda una relación casi de uno a uno con el marcado. Veamos un ejemplo de marcado:
<pre class="prettyprint">
&lt;html&gt;
  &lt;body&gt;
    &lt;p&gt;
      Hello World
    &lt;/p&gt;
    &lt;div&gt; &lt;img src="example.png"/&gt;&lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>
El marcado anterior se traduciría en el siguiente árbol de DOM:

</p>

<figure>
  <img src="image015.png" width="400" height="219"  />
  <figcaption>  <span>Figura </span>: árbol de DOM del marcado de ejemplo</figcaption>
</figure>

<p>
Al igual que el HTML, la organización W3C ha especificado el modelo DOM. Puedes consultarlo en la página <a href="http://www.w3.org/DOM/DOMTR">www.w3.org/DOM/DOMTR</a>. Es una especificación genérica para la manipulación de documentos. Un módulo específico describe elementos HTML específicos. Puedes consultar las definiciones HTML en la página <a href="http://www.w3.org/TR/2003/REC-DOM-Level-2-HTML-20030109/idl-definitions.html">www.w3.org/TR/2003/REC-DOM-Level-2-HTML-20030109/idl-definitions.html</a>.
</p>
<p>
Cuando digo que el árbol contiene nodos DOM, quiero decir que está construido con elementos que implementan una de las interfaces DOM. Los navegadores utilizan implementaciones concretas que tienen otros atributos que el navegador utiliza internamente.
</p>
<h4 id="The_parsing_algorithm">El algoritmo de análisis</h4>
<p>
Como vimos en las secciones anteriores, el lenguaje HTML no se puede analizar mediante los analizadores ascendentes y descendentes normales.
</p>
<p>
Las razones son:
<ol>
<li>la naturaleza permisiva del lenguaje,</li>
<li>el hecho de que los navegadores presenten una tolerancia a errores tradicional para admitir casos bien conocidos de HTML no válido,</li>
<li>la naturaleza iterativa del proceso de análisis. Normalmente, el código no cambia durante el análisis. Sin embargo, en el caso del código HTML, las etiquetas de secuencias de comandos que contienen <code>document.write</code> pueden añadir tokens adicionales, por lo que el proceso de análisis llega a modificar los datos de entrada.</li>
</ol>
<p>
Al no poder utilizar las técnicas de análisis normales, los navegadores crean analizadores personalizados para analizar el código HTML.
</p>
<p>
El <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/parsing.html">algoritmo de análisis se describe de forma detallada en la especificación de HTML5</a>. El algoritmo presenta dos fases: la tokenización y la construcción del árbol.
<p>
La tokenización es el análisis léxico, es decir, el análisis y la conversión en tokens de los datos de entrada. Entre los tokens HTML se encuentran las etiquetas iniciales, las etiquetas finales y los valores de atributos.
</p>
<p>
El tokenizador reconoce el token, lo envía al constructor del árbol y consume el siguiente carácter para reconocer el siguiente token, y así sucesivamente hasta llegar al final de los datos.
</p>

<figure>
  <img src="image017.png" width="308" height="400" />
  <figcaption><span>Figura </span>: flujo de análisis de HTML (tomado de la especificación de HTML5)</figcaption>
</figure>

<h4 id="The_tokenization_algorithm">El algoritmo de tokenización</h4>
<p>
El algoritmo produce un token HTML. El algoritmo se expresa como una máquina de estado. Cada estado consume uno o varios caracteres del flujo de entrada y actualiza el siguiente estado de acuerdo con esos caracteres. La decisión está influenciada por el estado de tokenización actual y por el estado de construcción del árbol. Esto significa que el mismo carácter consumido producirá resultados diferentes para el siguiente estado correcto en función del estado actual. El algoritmo es demasiado complejo para describirlo en su totalidad, así que veremos algunos ejemplos sencillos que nos ayudarán a comprender el principio.

</p><p>

Ejemplo básico de tokenización del siguiente código HTML:

</p>

<pre class="prettyprint">
&lt;html&gt;
  &lt;body&gt;
    Hello world
  &lt;/body&gt;
&lt;/html&gt;
</pre>

<p>

El estado inicial es el de "estado de datos". Cuando se encuentra el carácter <code>&lt;</code>, el estado cambia a <b>estado de etiqueta abierta</b>. Al consumir un carácter <code>a-z</code>, se crea el estado "token de etiqueta inicial" y el estado cambia a <b>estado de nombre de etiqueta</b>. Este estado se mantiene hasta que se consume el carácter <code>&gt;</code>. Todos los caracteres se añaden al nombre del nuevo token. En nuestro caso, el nuevo token es un token <code>html</code>.

</p><p>

Al llegar a la etiqueta <code>&gt;</code>, se emite el token actual y el estado cambia a <b>estado de datos</b>. Se siguen los mismos pasos para la etiqueta <code>&lt;body&gt;</code>. Hasta ahora, se han emitido las etiquetas <code>html</code> y <code>body</code>. Ahora volvemos al <b>estado de datos</b>. Al consumir el carácter <code>H</code> de <code>Hello world</code>, se crea y se emite un token de carácter, y así sucesivamente hasta llegar al carácter <code>&lt;</code> de <code>&lt;/body&gt;</code>. Se emite un token de carácter por cada uno de los caracteres de <code>Hello world</code>.

</p><p>

Ahora volvemos al <b>estado de etiqueta abierta</b>. Al consumir la siguiente entrada <code>/</code>, se crea un <code>token de etiqueta final</code> y se pasa al <b>estado de nombre de etiqueta</b>. De nuevo, el estado se mantiene hasta llegar a <code>&gt;</code>. A continuación, se emite el token de la nueva etiqueta y se vuelve al <b>estado de datos</b>. La entrada <code>&lt;/html&gt;</code> se tratará como el caso anterior.

</p>

<figure>
  <img src="image019.png" width="627" height="387" >
  <figcaption><span>Figura </span>: tokenización de la entrada de ejemplo</figcaption>
</figure>

<h4 id="Tree_construction_algorithm">Algoritmo de construcción de árbol</h4>
<p>
Cuando se crea un analizador, se crea el objeto "Document". Durante la fase de construcción, se modifica el árbol de DOM que incluye el objeto "Document" en su raíz y se añaden elementos. El constructor del árbol procesa cada nodo emitido por el tokenizador. Por cada token, la especificación define qué elementos de DOM son relevantes y cuáles se deben crear para este token. Además de añadirse al árbol de DOM, el elemento se añade a una pila de elementos abiertos. Esta pila permite corregir incidencias de anidación y de etiquetas no cerradas. El algoritmo también se describe como una máquina de estado. Los estados se denominan "modos de inserción".
</p>

<p>
Veamos cuál sería el proceso de construcción del árbol para los datos de entrada del ejemplo:
</p>


<pre class="prettyprint">
&lt;html&gt;
  &lt;body&gt;
    Hello world
  &lt;/body&gt;
&lt;/html&gt;
</pre>

<p>
La entrada a la fase de construcción del árbol es una secuencia de tokens de la fase de tokenización. El primer modo es el <b>"modo inicial"</b>. Si se recibe el token html, se pasará al modo <b>"previo a html"</b> y se volverá a procesar el token en ese modo. Esto hará que el elemento "HTMLHtmlElement" se cree y se añada al objeto raíz "Document".

</p><p>

El estado cambiará a <b>"antes del encabezado"</b>. Recibimos el token "body". Se creará implícitamente un elemento "HTMLHeadElement", aunque no tengamos ningún token "head", y ese elemento se añadirá al árbol.

</p><p>

Ahora pasamos al modo <b>"en el encabezado"</b> y, a continuación, al modo <b>"después del encabezado"</b>. El token del cuerpo se vuelve a procesar, se crea y se inserta un elemento "HTMLBodyElement" y, por último, el modo pasa a <b>"en el cuerpo"</b>.

</p><p>

A continuación, se reciben los tokens de los caracteres de la cadena "Hello world". El primero hará que se cree y se inserte el nodo "Text", al que se añadirá el resto de caracteres.

</p><p>

La recepción del token de finalización del cuerpo provocará una transferencia al modo <b>"después del cuerpo"</b>. A continuación, se recibirá la etiqueta HTML final, que hará que se pase al modo <b>después del cuerpo</b>. Cuando se reciba el final del token del archivo, al análisis finalizará.
</p>

<figure>
  <img src="image022.gif" width="532" height="769" />
  <figcaption><span>Figura </span>: construcción de árbol del código HTML de ejemplo</figcaption>
</figure>


<h4 id="Actions_when_the_parsing_is_finished">Acciones al finalizar el análisis</h4>
<p>
En esta fase, el navegador marcará el documento como interactivo y empezará a analizar las secuencias de comandos que se encuentren en modo "aplazado", es decir, aquellas que se deben ejecutar una vez que se ha analizado el documento. A continuación, el estado del documento se establecerá como "completado" y se activará un evento de "carga".
</p>

<p>
Se pueden ver <a href="http://www.w3.org/TR/html5/syntax.html#html-parser">los algoritmos completos para tokenización y la construcción del árbol en la especificación de HTML5</a>.
</p>

<h4 id="Browsers_error_tolerance">Tolerancia a errores de los navegadores</h4>
<p>
Nunca se obtiene un error por "sintaxis no válida" en una página HTML. Los navegadores corrigen el contenido no válido y siguen.

</p><p>
Tomemos este código HTML como ejemplo:

</p>

<pre class="prettyprint">
&lt;html&gt;
  &lt;mytag&gt;
  &lt;/mytag&gt;
  &lt;div&gt;
  &lt;p&gt;
  &lt;/div&gt;
    Really lousy HTML
  &lt;/p&gt;
&lt;/html&gt;
</pre>

<p>

He debido de infringir un millón de reglas ("mytag" no es una etiqueta estándar, los elementos "p" y "div" están mal anidados, etc.), pero el navegador sigue mostrándolo correctamente y no muestra ningún error. Por lo tanto, una gran parte del código del analizador corrige los errores del autor de contenido HTML.

</p><p>

La gestión de errores es bastante consistente en los navegadores, pero lo más increíble es que no forma parte de la especificación actual de HTML. Al igual que los marcadores y los botones de avance y retroceso, es algo que se ha ido desarrollando a lo largo de los años. Hay algunas construcciones HTML conocidas que no son válidas y que se repiten en muchos sitios. Los navegadores intentan corregirlas de acuerdo con otros navegadores.

</p><p>

En cambio, en la especificación de HTML5 sí se definen algunos de estos requisitos. WebKit lo resume en el comentario que se encuentra al principio de la clase de analizador de HTML.

</p>

<blockquote>
<p>El analizador analiza la entrada tokenizada y la convierte en el documento, lo que crea el árbol del documento. Si el documento está bien construido, el análisis resulta sencillo.</p>

<p>Lamentablemente, debemos tratar con muchos documentos HTML que no están bien construidos, por lo que el analizador debe ser tolerante con estos errores.</p>

<p>Se debe tener cuidado, como mínimo, con los siguientes errores:</p>

<ol>
  <li>El elemento que se debe añadir está prohibido explícitamente en alguna etiqueta externa. En este caso, debemos cerrar todas las etiquetas hasta llegar a la que prohíbe el elemento y añadirlo a continuación.
  <li>No está permitido añadir el elemento directamente. Es posible que el autor del documento haya olvidado incluir una etiqueta en medio (o que la etiqueta sea opcional). Este podría ser el caso de estas etiquetas: HTML HEAD BODY TBODY TR TD LI (¿he olvidado alguna?).
  <li>Se quiere añadir un elemento de bloque dentro de un elemento integrado. Hay que cerrar todos los elementos integrados hasta llegar al siguiente elemento de bloque superior.
  <li>Si esto no funciona, se deben cerrar elementos hasta que se pueda añadir el elemento o ignorar la etiqueta.
</ol>

</blockquote>

<p>
Veamos algunos ejemplos de tolerancia a errores de WebKit:
</p>
<h5>&lt;/br&gt; en lugar de &lt;br&gt;</h5>
<p>
Algunos sitios utilizan &lt;/br&gt; en lugar de &lt;br&gt;. Para poder ser compatible con Internet Explorer y Firefox, WebKit trata la etiqueta como si fuera &lt;br&gt;.
<br>
Código:
<pre class="prettyprint">
if (t->isCloseTag(brTag) && m_document->inCompatMode()) {
     reportError(MalformedBRError);
     t->beginTag = true;
}
</pre>
Nota: los errores se gestionan de forma interna, es decir, no se muestran al usuario.
</p>
<h5>Tabla perdida</h5>
<p>
Una tabla perdida es una tabla incluida en el contenido de otra tabla, pero no en una celda.
<br>
Ejemplo:
<pre class="prettyprint">
&lt;table&gt;
    &lt;table&gt;
        &lt;tr&gt;&lt;td&gt;inner table&lt;/td&gt;&lt;/tr&gt;
    &lt;/table&gt;
    &lt;tr&gt;&lt;td&gt;outer table&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
</pre>
WebKit cambiará la jerarquía de dos tablas secundarias:
<pre class="prettyprint">
&lt;table&gt;
    &lt;tr&gt;&lt;td&gt;outer table&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
&lt;table&gt;
    &lt;tr&gt;&lt;td&gt;inner table&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
</pre>
Código:
<pre class="prettyprint">
if (m_inStrayTableContent && localName == tableTag)
        popBlock(tableTag);
</pre>
WebKit utiliza una pila para el contenido del elemento actual y saca la tabla interna de la pila de la tabla externa. Las tablas se encontrarán en el mismo nivel de la jerarquía.
</p>
<h5>Elementos de un formulario anidado</h5>
<p>
Si el usuario incluye un formulario dentro de otro, el segundo se ignorará.
<br>
Código:
<pre class="prettyprint">
if (!m_currentFormElement) {
        m_currentFormElement = new HTMLFormElement(formTag,    m_document);
}
</pre>
</p>
<h5>Jerarquía de etiquetas demasiado profunda</h5>
<p>
El comentario habla por sí solo.
<br>
<div class="comment">
<blockquote>
www.liceo.edu.mx es un ejemplo de un sitio con un nivel de anidamiento de unas 1.500 etiquetas, todas ellas procedentes de una serie de etiquetas &lt;b&gt;s. No se permite utilizar más de 20 etiquetas anidadas del mismo tipo. A partir de ese número, se ignoran todas.
</blockquote>
</div>
<pre class="prettyprint">
bool HTMLParser::allowNestedRedundantTag(const AtomicString& tagName)
{

unsigned i = 0;
for (HTMLStackElem* curr = m_blockStack;
         i &lt; cMaxRedundantTagDepth && curr && curr->tagName == tagName;
     curr = curr->next, i++) { }
return i != cMaxRedundantTagDepth;
}
</pre>
</p>
<h5>Etiquetas finales de cuerpo o HTML colocadas incorrectamente</h5>
<p>
De nuevo, el comentario habla por sí solo.

<blockquote>
Se tolera que HTML se rompa totalmente. Nunca cerramos la etiqueta del cuerpo (body), ya que algunas páginas web cometen el error de cerrarla antes de que haya acabado el documento. Por eso, nos fijamos en la llamada "end()" para cerrar elementos.
</blockquote>

<pre class="prettyprint">
if (t->tagName == htmlTag || t->tagName == bodyTag )
        return;

</pre>
Así que ya sabéis: a menos que queráis aparecer como ejemplo en un fragmento de código de tolerancia a errores de WebKit, escribid el código HTML correctamente.
</p>
<p>

<h3 id="CSS_parsing">Análisis de CSS</h3>
<p>
¿Os acordáis de los conceptos de análisis que vimos en la introducción? A diferencia del lenguaje HTML, CSS tiene una gramática libre de contexto y se puede analizar con los tipos de analizadores descritos en la introducción. De hecho, <a href="http://www.w3.org/TR/CSS2/grammar.html">la especificación del lenguaje CSS define su gramática sintáctica y léxica</a>.
</p>
<p>
Veamos algunos ejemplos:
<br>
La gramática léxica (el vocabulario) se define mediante expresiones regulares para cada token:
<pre>
comment   \/\*[^*]*\*+([^/*][^*]*\*+)*\/
num   [0-9]+|[0-9]*"."[0-9]+
nonascii  [\200-\377]
nmstart   [_a-z]|{nonascii}|{escape}
nmchar    [_a-z0-9-]|{nonascii}|{escape}
name    {nmchar}+
ident   {nmstart}{nmchar}*
</pre>
<p>
"ident" es la abreviatura de identificador, como el nombre de una clase. "name" es el identificador de un elemento (y se hace referencia a él mediante "#").
</p>
<p>
La gramática sintáctica se describe en BNF.
<pre class="prettyprint lang-css">
ruleset
  : selector [ ',' S* selector ]*
    '{' S* declaration [ ';' S* declaration ]* '}' S*
  ;
selector
  : simple_selector [ combinator selector | S+ [ combinator? selector ]? ]?
  ;
simple_selector
  : element_name [ HASH | class | attrib | pseudo ]*
  | [ HASH | class | attrib | pseudo ]+
  ;
class
  : '.' IDENT
  ;
element_name
  : IDENT | '*'
  ;
attrib
  : '[' S* IDENT S* [ [ '=' | INCLUDES | DASHMATCH ] S*
    [ IDENT | STRING ] S* ] ']'
  ;
pseudo
  : ':' [ IDENT | FUNCTION S* [IDENT S*] ')' ]
  ;
</pre>
Explicación: un conjunto de reglas es una estructura como la que se muestra a continuación.
<pre class="prettyprint lang-css">
div.error , a.error {
  color:red;
  font-weight:bold;
}
</pre>
"div.error" y "a.error" son selectores. La parte entre llaves contiene las reglas que se aplican a este conjunto de reglas. Esta estructura se define formalmente en esta definición:
<pre class="prettyprint lang-css">
ruleset
  : selector [ ',' S* selector ]*
    '{' S* declaration [ ';' S* declaration ]* '}' S*
  ;
</pre>
Esto significa que un conjunto de reglas es un selector o un número opcional de selectores separados por una coma y por espacios (S significa espacio en blanco). Un conjunto de reglas contiene una declaración entre llaves u, opcionalmente, una serie de declaraciones separadas por punto y coma. "declaration" y "selector" se definirán en las siguientes definiciones de BNF.
</p>
<h4 id="Webkit_CSS_parser">Analizador de CSS de WebKit</h4>
<p>
WebKit utiliza generadores de analizadores <a href="#parser_generators">Flex y Bison</a> para crear analizadores automáticamente a partir de los archivos de gramática de CSS. Como ya dijimos en la introducción a los analizadores, Bison crea un analizador ascendente de desplazamiento-reducción. Firefox utiliza un analizador descendente escrito manualmente. En ambos casos, los archivos CSS se analizan y se convierten en objetos "StyleSheet", cada uno de los cuales contiene reglas de CSS. Los objetos de regla de CSS contienen objetos de declaraciones y selectores, así como otros objetos relacionados con la gramática de CSS.
</p>

<figure>
  <img src="image023.png" width="500" height="393" alt="" title="" border="0" align=""  />
  <figcaption><span>Figura </span>: análisis de CSS</figcaption>
</figure>


<h3 id="The_order_of_processing_scripts_and_style_sheets">Orden de procesamiento de secuencias de comandos y hojas de estilo</h3>
<h4 id="Scripts">Secuencias de comandos</h4>
<p>
El modelo de la Web es síncrono. Los autores esperan que las secuencias de comandos se analicen y se ejecuten inmediatamente cuando el analizador llega a la etiqueta &lt;script&gt;. El análisis del documento se detiene hasta que la secuencia de comandos se ejecuta. La secuencia de comandos es externa, por lo que antes es necesario recuperar el recurso de la red. Esta acción se realiza también de una forma síncrona, es decir, que el análisis se detiene hasta que se recupera el recurso. Este modelo se utilizó durante muchos años y está incluido en las especificaciones de HTML 4 y 5. Los autores pueden marcar la secuencia de comandos como "aplazada". De ese modo, no se detiene el análisis del documento y la secuencia se ejecuta una vez que se ha completado el análisis. HTML5 añade una opción que permite marcar la secuencia de comandos como asíncrona para que se analice y se ejecute en un subproceso diferente.
</p>
<h4 id="Speculative_parsing">Análisis especulativo</h4>
<p>
Tanto WebKit y Firefox utilizan esta optimización. Al ejecutar las secuencias de comandos, otro subproceso analiza el resto del documento, busca en la red otros recursos necesarios y los carga. De esta forma, los recursos se pueden cargar mediante conexiones paralelas, lo que mejora la velocidad general. Nota: el analizador especulativo no modifica el árbol de DOM (de eso se encarga el analizador principal), solo analiza las referencias a recursos externos, como secuencias de comandos externas, hojas de estilo e imágenes.
</p>
<h4 id="Style_sheets">Hojas de estilo</h4>
<p>
Las hojas de estilo, por otro lado, tienen un modelo diferente. Conceptualmente, parece que, dado que las hojas de estilo no modifican el árbol de DOM, no hay razón para esperarlas y detener el análisis del documento. Sin embargo, se produce una incidencia cuando las secuencias de comandos solicitan información de estilo durante la fase de análisis del documento. Si el estilo aún no se ha cargado ni analizado, la secuencia de comandos obtendrá respuestas incorrectas y, aparentemente, esto causará muchas complicaciones. Parece que se trata de un caso extremo, pero es bastante común. Firefox bloquea todas las secuencias de comandos si todavía se está cargando y analizando una hoja de estilo. WebKit bloquea las secuencias de comandos solo cuando intentan acceder a determinadas propiedades de estilo que se pueden ver afectadas por las hojas de estilo descargadas.
</p>
<h3 id="Render_tree_construction">Construcción del árbol de renderización</h3>
<p>
Mientras se está construyendo el árbol DOM, el navegador construye otro árbol: el árbol de renderización. Este árbol está formado por elementos visuales que se muestran en el mismo orden en que aparecerán. Es la representación visual del documento. El propósito de este árbol es poder representar el contenido en el orden correcto.
</p>
<p>
Firefox denomina a los elementos del árbol de renderización "marcos" (o "frames"). WebKit utiliza el término "renderizador" u "objeto de renderización" (o "render").
<br>
Un renderizador es capaz de representarse a sí mismo y a sus elementos secundarios.
<br>
La clase "RenderObject" de WebKit, la clase básica de los renderizadores, tiene la siguiente definición:
<pre class="prettyprint">
class RenderObject{
  virtual void layout();
  virtual void paint(PaintInfo);
  virtual void rect repaintRect();
  Node* node;  //the DOM node
  RenderStyle* style;  // the computed style
  RenderLayer* containgLayer; //the containing z-index layer
}
</pre>
</p>
<p>
Cada renderizador representa un área rectangular que normalmente se corresponde con la caja de CSS del nodo, según se describe en la especificación de CSS2. Contiene información geométrica como el ancho, la altura y la posición.
<br>
El tipo de caja se ve afectado por el atributo de estilo "display" relevante para el nodo (consulta la sección <a href="#style_computation">Computación de estilos</a>). Este es el código de WebKit que se utiliza para decidir qué tipo de renderizador se debe crear para un nodo DOM, según el atributo de visualización:
<pre class="prettyprint">
RenderObject* RenderObject::createObject(Node* node, RenderStyle* style)
{
    Document* doc = node->document();
    RenderArena* arena = doc->renderArena();
    ...
    RenderObject* o = 0;

    switch (style->display()) {
        case NONE:
            break;
        case INLINE:
            o = new (arena) RenderInline(node);
            break;
        case BLOCK:
            o = new (arena) RenderBlock(node);
            break;
        case INLINE_BLOCK:
            o = new (arena) RenderBlock(node);
            break;
        case LIST_ITEM:
            o = new (arena) RenderListItem(node);
            break;
       ...
    }

    return o;
}
</pre>
El tipo de elemento también se tiene en cuenta. Por ejemplo, las tablas y los controles de los formularios tienen marcos especiales.
<br>
En WebKit, si un elemento quiere crear un renderizador especial, sobrescribe el método <code>createRenderer</code>. Los renderizadores apuntan a objetos de estilo que contienen la información no geométrica.
</p>
<h5 id="The_render_tree_relation_to_the_DOM_tree">Relación del árbol de renderización con el árbol de DOM</h5>
Los renderizadores corresponden a elementos DOM, pero la relación no es de uno a uno. Los elementos DOM no visuales no se insertan en el árbol de renderización. Un ejemplo sería el elemento "head". Los elementos cuyo atributo de visualización se ha asignado a "none" tampoco aparecen en el árbol (los elementos con el atributo de visibilidad "hidden" sí aparecen en el árbol).
</p>
<p>
Algunos elementos DOM corresponden a varios objetos visuales. Estos suelen ser elementos con una estructura compleja que no se pueden describir en un solo rectángulo. Por ejemplo, el elemento "select" tiene tres renderizadores: uno para el área de visualización, otro para el cuadro de lista desplegable y otro para el botón. Además, cuando el texto se divide en varias líneas porque el ancho no es suficiente para una línea, las nuevas líneas se añaden como renderizadores adicionales.
<br>
Otro ejemplo con varios renderizadores sería un código HTML roto. Según la especificación de CSS, un elemento integrado debe contener únicamente elementos de bloque o elementos integrados. Si el contenido es mixto, se crean renderizadores de bloques anónimos para incluir los elementos integrados.
</p>
<p>
Algunos objetos de renderización corresponden a un nodo DOM de un lugar del árbol diferente. Los elementos flotantes y aquellos con posición absoluta quedan fuera del flujo, en un lugar diferente del árbol y asignados al marco real. Deberían haber estado en un marco de marcador.
</p>

<a id="rendertree"></a>

  <figure>
      <img src="image025.png" width="731" height="396" >
    <figcaption><span>Figura </span>: el árbol renderizador y el árbol de DOM correspondiente (<a href="#3_1">3.1</a>) La "ventana gráfica" es el bloque contenedor inicial. En WebKit, será el objeto "RenderView".</figcaption>
  </figure>



<h5 id="The_flow_of_constructing_the_tree">El flujo de construcción del árbol</h5>
<p>
En Firefox, la presentación se registra como un detector de actualizaciones de DOM. La presentación delega la creación de marcos en <code>FrameConstructor</code> y el constructor resuelve el estilo (consulta la sección <a href="#style">Computación de estilos</a>) y crea un marco.
</p>
<p>
En WebKit, el proceso para resolver el estilo y crear un renderizador se denomina "asociación". Cada nodo DOM dispone de un método de "asociación". El proceso de asociación es síncrono, es decir, que la inserción de nodos en el árbol de DOM activa el método de "asociación" del nuevo nodo.
<p>
Al procesar las etiquetas "html" y "body", se construye la raíz del árbol de renderización. El objeto de renderización raíz se corresponde con lo que la especificación de CSS denomina "bloque contenedor", es decir, el bloque superior que contiene el resto de los bloques. Sus dimensiones se corresponden con la ventana gráfica, es decir, con las dimensiones del área de visualización de la ventana del navegador. Firefox lo denomina <code>ViewPortFrame</code> y WebKit <code>RenderView</code>. Este es el objeto de renderización al que apunta el documento. El resto del árbol se construye como una inserción de nodos DOM.
</p>
<p>
Consulta la <a href="http://www.w3.org/TR/CSS21/intro.html#processing-model">especificación de CSS2 en el modelo de procesamiento</a>.
</p>


<h4 id="Style_Computation">Computación de estilos</h4>
<p>
Para crear el árbol de renderización, es necesario calcular las propiedades visuales de cada uno de los objetos de renderización. Para hacerlo, hay que calcular las propiedades de estilo de cada elemento.
</p>
<p>
El estilo incluye hojas de estilo de varios orígenes, elementos de estilo integrados y propiedades visuales en el código HTML (como la propiedad "bgcolor"). Estas últimas se transforman en las propiedades de estilo de CSS correspondientes.
</p>
<p>
Los orígenes de las hojas de estilo son las hojas de estilo predeterminadas del navegador, las proporcionadas por el autor de la página y las proporcionadas por el usuario del navegador (los navegadores permiten al usuario definir su estilo favorito. En Firefox, por ejemplo, se puede hacer colocando una hoja de estilo en la carpeta de perfiles del navegador).
</p>
<p>
La computación de estilos conlleva algunas dificultades:
<ol>
<li>Al contener las numerosas propiedades de los estilos, los datos de <a id="issue1">estilo</a> llegan a alcanzar unas dimensiones considerables, lo que puede provocar un uso excesivo de memoria.</li>
<li>
<p>La <a id="issue2">búsqueda</a> de las reglas coincidentes de cada elemento puede afectar al rendimiento si no se optimiza el proceso. Recorrer la lista completa de reglas de cada elemento para encontrar coincidencias es una tarea muy pesada. Los selectores pueden tener una estructura compleja, lo que puede hacer que se empiece a buscar en una ruta que aparentemente sea buena, pero que finalmente no sea así y se deba probar con otra ruta.
</p>
<p>Pongamos como ejemplo este selector complejo:</p>

<pre class="prettyprint">
div div div div{
  ...
}
</pre>
Significa que las reglas se aplican a un elemento <code>&lt;div&gt;</code> que es el descendiente de tres elementos "div". Supongamos que quieres comprobar si la regla se aplica a un elemento <code>&lt;div&gt;</code> determinado. Debes seleccionar una ruta superior del árbol para comprobarlo. Es posible que debas ascender por todo el árbol de nodos solo para averiguar que únicamente existen dos elementos "div" y que la regla no se aplica. A continuación, debes probar con otras rutas del árbol.
</li>
<li>Para <a id="issue3">aplicar</a> las reglas, es necesario utilizar reglas en cascada bastante complejas que definen la jerarquía de las reglas.</li>
</ol>
Veamos cómo se enfrentan los navegadores a estas dificultades:

<h5 id="Sharing_style_data">Datos de estilo compartidos</h5>
<p>
Los nodos de WebKit hacen referencia los objetos de estilo (RenderStyle). Los nodos pueden compartir estos objetos en algunas circunstancias. Los nodos son del mismo nivel, ya pertenezcan al mismo nodo principal o a otro nodo del mismo nivel que este, y:
<ol>
<li>Los elementos deben tener el mismo estado de ratón (por ejemplo, uno no puede estar en ":hover" y el otro en otro estado).</li>
<li> Ninguno de los elementos debe tener un identificador.</li>
<li> Los nombres de las etiquetas deben coincidir.</li>
<li> Los atributos de clase deben coincidir.</li>
<li> El conjunto de atributos asignados debe ser idéntico.</li>
<li> Los estados de enlace deben coincidir.</li>
<li> Los estados de enfoque deben coincidir.</li>
<li> Ningún elemento se debe ver afectado por selectores de atributos, es decir, no debe presentar ninguna coincidencia con ningún selector que utilice un selector de atributo en ninguna posición dentro del selector.</li>
<li> No debe haber ningún atributo de estilo integrado en los elementos.</li>
<li>No debe haber ningún selector del mismo nivel en uso. WebCore simplemente aplica un cambio global si detecta un selector del mismo nivel e inhabilita la opción de compartir estilos en todo el documento cuando está presente. Esto incluye el selector + y selectores como ":first-child" y ":last-child".</li>
</ol>

<h5 id="Firefox_rule_tree">Árbol de reglas de Firefox</h5>
<p>
Firefox cuenta con dos árboles adicionales para una computación de estilos más sencilla: el árbol de reglas y el árbol de contextos de estilo. WebKit también cuenta con objetos de estilo, pero no se almacenan en un árbol como el árbol de contextos de estilo. Solo el nodo de DOM indica el estilo pertinente.

</p>

<figure>
  <img src="image035.png" width="640" height="407" />
  <figcaption><span>Figura </span>: árbol de contextos de estilo (<a href="#2_2">2.2</a>)</figcaption>
</figure>


<p>
Los contextos de estilo incluyen valores finales. Para computar los valores, se aplican todas las reglas con las que se hayan encontrado coincidencias en el orden correcto y se realizan manipulaciones que transforman los valores lógicos en concretos. Por ejemplo, si el valor lógico es un porcentaje de la pantalla, se calculará y se transformará en unidades absolutas. La idea del árbol de reglas es muy ingeniosa, ya que permite compartir estos valores entre nodos para evitar que se vuelvan a computar. Además, ahorra espacio.
</p>

<p>
Todas las reglas con las que se encuentra alguna coincidencia se almacenan en un árbol. Los nodos inferiores de una ruta tienen mayor prioridad. El árbol incluye todas las rutas de las coincidencias que se han encontrado para una regla. Las reglas se almacenan lentamente. El árbol no se computa al principio de cada nodo, pero siempre que se debe computar el estilo de un nodo, las rutas se añaden al árbol.
</p>
<p>
La idea es que las rutas del árbol se muestren como las palabras de un lexicón. Imaginemos, por ejemplo, que ya hemos computado este árbol de reglas:

<figure>
  <img src="tree.png" width="400" height="261" alt="" title="" border="0" align=""  />
</figure>

Supongamos que necesitamos encontrar coincidencias para reglas de otros elementos del árbol de contenido y obtenemos las siguientes reglas (en el orden correcto): B - E - I. Ya teníamos esta ruta del árbol porque ya habíamos computado la ruta A - B - E - I - L, por lo que ahora tendremos menos trabajo que hacer.
</p>
<p>
Vamos a comprobar cómo guarda el árbol nuestro trabajo.
</p>
<h5 id="Division_into_structs">División en estructuras</h5>
<p>
Los contextos de estilo se dividen en estructuras que incluyen información de estilo de una cierta categoría, como el borde o el color. Todas las propiedades de un estructura pueden ser heredadas o no heredadas. Las propiedades heredadas son propiedades que, a menos que las defina el elemento, se heredan del elemento principal. Las propiedades no heredadas (denominadas propiedades "reset") utilizan los valores predeterminados en caso de que no se definan.
</p>
<p>
El árbol guarda en caché estructuras completas (que incluyen los valores finales computados) del árbol. De esa forma, si el nodo inferior no proporciona una definición para una estructura, se puede utilizar una estructura guardada en caché de un nodo superior.
</p>
<h5 id="Computing_the_style_contexts_using_the_rule_tree">Cómo computar los contextos de estilo con el árbol de reglas</h5>
<p>
Cuando se computa el contexto de estilo de un elemento específico, primero se computa una ruta del árbol de reglas o se utiliza una existente. A continuación, se aplican las reglas de la ruta para completar las estructuras del nuevo contexto de estilo. Empezamos por el nodo inferior de la ruta, es decir, el nodo de mayor prioridad (normalmente el selector más específico), y recorremos el árbol en sentido ascendente hasta completar la estructura. Si este nodo de reglas no incluye ninguna especificación para la estructura, podemos optimizarlo considerablemente (la mejor forma es recorrer el árbol en sentido ascendente hasta encontrar un nodo que incluya una especificación completa y apuntar después a este nodo) y compartir la estructura completa. Gracias a este método ahorramos valores finales y memoria.
<br>
Si encontramos definiciones parciales, recorremos el árbol en sentido ascendente hasta completar la estructura.
</p>
<p>
Si no encontramos definiciones para la estructura, en caso de que esta sea de tipo "heredada", apuntamos a la estructura del elemento principal del <b>árbol de contextos</b>. En este caso, también conseguimos compartir las estructuras. Si la estructura es de tipo "no heredada", se utilizarán los valores predeterminados.
</p>
<p>
Si el nodo más específico no añade valores, tendremos que efectuar cálculos adicionales para transformarlos en valores reales. Posteriormente, almacenamos en caché en el árbol el resultado del nodo para que se pueda utilizar como elemento secundario.
</p>
<p>
En caso de que un elemento tenga un elemento de su mismo nivel que apunte al mismo nodo del árbol, ambos elementos pueden compartir el <b>contexto de estilo completo</b>.
</p>
<p>
Veamos un ejemplo. Supongamos que tenemos el siguiente código HTML:


<pre class="prettyprint">
&lt;html&gt;
  &lt;body&gt;
    &lt;div class="err" id="div1"&gt;
      &lt;p&gt;
        this is a &lt;span class="big"&gt; big error &lt;/span&gt;
        this is also a
        &lt;span class="big"&gt; very  big  error&lt;/span&gt; error
      &lt;/p&gt;
    &lt;/div&gt;
    &lt;div class="err" id="div2"&gt;another error&lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>

Y las siguientes reglas:
<pre class="prettyprint lang-css linenums">
div {margin:5px;color:black}
.err {color:red}
.big {margin-top:3px}
div span {margin-bottom:4px}
#div1 {color:blue}
#div2 {color:green}
</pre>
<p>
Para simplificar la tarea, digamos que tenemos que completar solo dos estructuras: la estructura de color y la estructura de margen. La estructura de color solo contiene un miembro, el color, mientras que la estructura de margen contiene los cuatro lados.
<br>
El árbol de reglas que se obtiene tendrá la siguiente apariencia (los nodos se marcan así: "nombre del nodo : número de la regla a la que apunta"):



<figure>
  <img src="image027.png" width="500" height="294" />
  <figcaption><span>Figura </span>: árbol de reglas</figcaption>
</figure>


<br>
El árbol de contextos tendrá la siguiente apariencia (nombre del nodo : nodo de regla a la que apunta):


<figure>
  <img src="image029.png" width="400" height="305" >
  <figcaption> <span>Figura </span>: árbol de contextos</figcaption>
</figure>



<p>
Supongamos que analizamos el código HTML y obtenemos la segunda etiqueta &lt;div&gt;. Tendremos que crear un contexto de estilo para el nodo y completar sus estructuras de estilo.
<br>
Buscamos las reglas que coincidan con &lt;div&gt; y descubrimos que son 1, 2 y 6. Esto significa que ya existe una ruta del árbol que podemos utilizar para nuestro elemento, por lo que solo necesitamos añadir otro nodo para la regla 6 (nodo F del árbol de reglas).
<br>
Crearemos un contexto de estilo y lo incluiremos en el árbol de contextos. El nuevo contexto de estilo apuntará al nodo F del árbol de reglas.
</p>
<p>
Ahora necesitamos completar las estructuras de estilo. Empezaremos completando la estructura de margen. Como el último nodo de regla (F) no se añade a la estructura de margen, podemos ascender por el árbol hasta encontrar una estructura almacenada en caché computada en la inserción de un nodo anterior y utilizarla. Encontraremos esta estructura en el nodo B, que es el nodo de nivel más superior que especifica reglas de margen.
</p>
<p>
Ya tenemos una definición para la estructura de color, por lo que no podemos utilizar una estructura almacenada en caché. Como el color tiene un atributo, no necesitamos ascender por el árbol para completar otros atributos. Computamos el valor final (convertimos la cadena a RGB, etc.) y almacenamos en caché en este nodo la estructura computada.
</p>
<p>
El trabajo relacionado con el elemento &lt;span&gt; es aún más sencillo. Buscamos las reglas que coinciden con este elemento y llegamos a la conclusión de que la regla a la que apunta es G, como el elemento "span" anterior. Como tenemos elementos del mismo nivel que apuntan al mismo nodo, podemos compartir el contexto de estilo completo y apuntar solo al contexto del elemento "span" anterior.
</p>
<p>
En el caso de las estructuras que incluyen reglas heredadas del elemento principal, el proceso de almacenamiento en caché se lleva a cabo en el árbol de contextos (aunque la propiedad de color se hereda, Firefox trata esta propiedad como no heredada y la guarda en caché en el árbol de reglas).
<br>
Por ejemplo, imaginemos que añadimos reglas para las fuentes de un parágrafo:
<pre class="prettyprint">
p {font-family:Verdana;font size:10px;font-weight:bold}
</pre>
El elemento de párrafo, que es un elemento secundario del elemento "div" del árbol de contextos, podría compartir la misma estructura de fuente que el elemento principal. Este caso se podría aplicar si no se especificasen reglas de fuente para el párrafo.
</p>
<p>
En WebKit, no existen los árboles de reglas, por lo que las declaraciones que coinciden se recorren cuatro veces. En primer lugar, se aplican las propiedades de alta prioridad de menor importancia (estas propiedades se deben aplicar primero porque hay otras que dependen de ellas, como "display"); a continuación, se aplican las propiedades de alta prioridad de mayor importancia; posteriormente, las propiedades de prioridad normal de menor importancia y, por último, las reglas de prioridad normal de mayor importancia. Esto significa que las propiedades que aparezcan varias veces se resolverán según el orden de cascada correcto. La última es la más importante.
<br>
</p>
<p>
En resumen, compartir objetos de estilo (ya sea en su totalidad o compartiendo solamente algunas de sus estructuras) soluciona las incidencias <a href="#issue1">1</a> y <a href="#issue3">3</a>. El árbol de reglas de Firefox también ayuda a aplicar las propiedades en el orden correcto.
</p>
<h5 id="Manipulating_the_rules_for_an_easy_match">Cómo manipular las reglas para obtener coincidencias fácilmente</h5>
<p>
A continuación se muestran las distintas fuentes de reglas de los modificadores de estilo.
<ul>
<li>Reglas de CSS, tanto en hojas de estilo internas como en elementos de estilo:
<pre class="prettyprint">
p {color:blue}
</pre>
</li>
<li>Atributos de estilo integrados, como el siguiente:
<pre class="prettyprint">
&lt;p style="color:blue" /&gt;
</pre>
</li>
<li>Atributos visuales HTML (que se asignan a reglas de estilo relevantes):
<pre class="prettyprint">
&lt;p bgcolor="blue" /&gt;
</pre>
</li>
</ul>
<p>
Las dos últimas fuentes coinciden fácilmente con el elemento, ya que este incluye los atributos de estilo, y los atributos HTML se pueden asignar utilizando el elemento como clave.
</p>
<p>
Como se comentó previamente en la <a href="#issue2">incidencia 2</a>, buscar una coincidencia con la regla de CSS puede resultar bastante complicado. Para resolver esta dificultad, las reglas se manipulan para facilitar el acceso.
</p><p>
Después de analizar la hoja de estilo, las reglas se añaden a uno de varios mapas hash, de acuerdo con el selector. Existen mapas organizados por ID, nombre de clase y nombre de etiqueta, y un mapa general para todo lo que no se puede incluir en estas categorías. Si el selector es un ID, la regla se añadirá al mapa de ID; si es una clase, se añadirá al mapa de clase, etc.
<br>
Esta manipulación facilita considerablemente la tarea de asignación de reglas. No hace falta revisar cada declaración, podemos extraer las reglas relevantes para un elemento de los mapas. Esta optimización elimina más del 95% de las reglas, por lo que ni siquiera es necesario tenerlas en cuenta durante el proceso de búsqueda de coincidencias (<a href="#4_1">4.1</a>).
</p>
<p>
Analicemos las reglas de estilo que se incluyen a continuación:
<pre class="prettyprint">
p.error {color:red}
#messageDiv {height:50px}
div {margin:5px}
</pre>
La primera regla se insertará en el mapa de clase, la segunda en el mapa de ID y la tercera en el mapa de etiquetas.
<br>
Para el siguiente fragmento de HTML:
<pre class="prettyprint">
&lt;p class="error">an error occurred &lt;/p>
&lt;div id=" messageDiv">this is a message&lt;/div&gt;
</pre>
</p>
<p>
En primer lugar, intentaremos buscar reglas para el elemento "p". El mapa de clase incluirá una clave "error" dentro de la que se encuentra la regla para "p.error". El elemento "div" tendrá reglas relevantes en el mapa de ID (la clave es el ID) y el mapa de etiqueta. Por tanto, solo queda averiguar qué reglas extraídas de las claves realmente coinciden.
<br>
Por ejemplo, si la regla del elemento "div" fuera la siguiente:
<pre class="prettyprint">
table div {margin:5px}
</pre>
se extraería del mapa de etiqueta, porque la clave es el selector situado más a la derecha, pero no coincidiría con el elemento "div", que no cuenta con un antecesor de tabla.
</P>
<P>
Tanto WebKit como Firefox utilizan esta manipulación.
</p>
<h5 id="Applying_the_rules_in_the_correct_cascade_order">Cómo aplicar las reglas en el orden de cascada correcto</h5>
<p>
El objeto de estilo tiene propiedades que se corresponden con cada atributo visual (todos los atributos CSS, pero más genéricos). Si ninguna de las reglas que coinciden define la propiedad, algunas propiedades se pueden heredar del elemento principal del objeto de estilo. Otras propiedades tienen valores predeterminados.
</p>
<p>
La incidencia se produce cuando existe más de una definición, y es entonces cuando se debe utilizar el orden en cascada para resolverla.
<h5 id="Style_sheet_cascade_order">Orden en cascada de la hoja de estilo</h5>
Una declaración de una propiedad de estilo puede aparecer en varias hojas de estilo y varias veces dentro de una misma hoja. Por ese motivo, el orden de aplicación de las reglas tiene una gran importancia. Este orden se conoce como "cascada". De acuerdo con las especificaciones de CSS2, el orden en cascada es el siguiente (de menor a mayor):
<ol>
  <li>declaraciones del navegador,</li>
  <li>declaraciones normales del usuario,</li>
  <li>declaraciones normales del autor,</li>
  <li>declaraciones importantes del autor,</li>
  <li>declaraciones importantes del usuario.</li>
</ol>
</p>
<p>
Las declaraciones del navegador son las que tienen menos importancia y las del usuario solo tienen prioridad sobre las del autor si están marcadas como importantes. Las declaraciones con el mismo orden se ordenan según la <a href="#Specificity">especificidad</a> y, posteriormente, según el orden en el que se han especificado. Los atributos visuales HTML se traducen en las declaraciones CSS correspondientes. Se tratan como reglas de autor de prioridad baja.
</p>
<h5 id="Specificity">Especificidad</h5>
<p>
La <a href="http://www.w3.org/TR/CSS2/cascade.html#specificity">especificación de CSS2</a> define la especificidad del selector como se indica a continuación:
<ul>
    <li>"1" si la declaración es de un atributo "style" en lugar de una regla con un selector; en caso contrario, "0" (= a),</li>
    <li>número de atributos de ID del selector (= b), </li>
    <li>número de otros atributos y pseudoclases del selector (= c), </li>
    <li>número de nombres de elementos y de pseudoelementos del selector (= d). </li>
</ul>
La especificidad se obtiene al concatenar los cuatro números a-b-c-d (en un sistema de números de base amplia).
</p>
<p>
La base numérica que se debe utilizar es el número de recuento más elevado de una de las categorías.
<br>
Por ejemplo, si a=14, se puede utilizar una base hexadecimal. En el improbable caso de que a=17, se deberá utilizar una base numérica de 17 dígitos. El último caso sería el de un selector como html body div div p... con 17 etiquetas en el selector, pero esto es muy poco probable.
</p>
<p>
Algunos ejemplos:
<pre class="prettyprint">
 *             {}  /* a=0 b=0 c=0 d=0 -> specificity = 0,0,0,0 */
 li            {}  /* a=0 b=0 c=0 d=1 -> specificity = 0,0,0,1 */
 li:first-line {}  /* a=0 b=0 c=0 d=2 -> specificity = 0,0,0,2 */
 ul li         {}  /* a=0 b=0 c=0 d=2 -> specificity = 0,0,0,2 */
 ul ol+li      {}  /* a=0 b=0 c=0 d=3 -> specificity = 0,0,0,3 */
 h1 + *[rel=up]{}  /* a=0 b=0 c=1 d=1 -> specificity = 0,0,1,1 */
 ul ol li.red  {}  /* a=0 b=0 c=1 d=3 -> specificity = 0,0,1,3 */
 li.red.level  {}  /* a=0 b=0 c=2 d=1 -> specificity = 0,0,2,1 */
 #x34y         {}  /* a=0 b=1 c=0 d=0 -> specificity = 0,1,0,0 */
 style=""          /* a=1 b=0 c=0 d=0 -> specificity = 1,0,0,0 */
</pre>
</p>
<h5 id="Sorting_the_rules">Cómo ordenar las reglas</h5>
<p>
Después de buscar coincidencias, las reglas se ordenan según las reglas de cascada. WebKit utiliza el ordenamiento de burbuja para listas pequeñas y el ordenamiento por mezcla para listas grandes. WebKit ordena las reglas sobrescribiendo el operador "&gt;" para las reglas:
<pre class="prettyprint">
static bool operator >(CSSRuleData& r1, CSSRuleData& r2)
{
    int spec1 = r1.selector()->specificity();
    int spec2 = r2.selector()->specificity();
    return (spec1 == spec2) : r1.position() > r2.position() : spec1 > spec2;
}
</pre>
</p>
<h4 id="Gradual_process">Proceso gradual</h4>
<p>
WebKit utiliza un indicador que muestra si se han cargado todas las hojas de estilo de nivel superior (incluidas las de @imports). Si las hojas de estilo no se cargan por completo al asociarlas, se utilizan marcadores de posición (indicándolo en el documento), que se vuelven a calcular una vez que se han cargado las hojas de estilo.
</p>


<h3 id="Layout">Diseño</h3>
<p>
Cuando el renderizador se crea y se añade al árbol, no tiene posición ni tamaño. El cálculo de estos valores se conoce como diseño o reflujo.
</p>
<p>
HTML utiliza un modelo de diseño basado en flujo, lo que significa que, la mayoría de las veces, los cálculos geométricos se pueden realizar con una sola operación. Los elementos que entran posteriormente "en el flujo" no suelen influir en la geometría de los elementos que ya se encuentran en él, por lo que el diseño se puede aplicar de izquierda a derecha y de arriba a abajo en todo el documento. Hay excepciones, como las tablas HTML, que pueden requerir más de un cálculo (<a href="#3_5">3.5</a>).
</p>
<p>
El sistema de coordenadas se refiere al marco raíz. Se utilizan las coordenadas superior e izquierda.
</p>
<p>
El diseño consiste en un proceso recurrente. Se inicia en el renderizador raíz, que corresponde al elemento <code>&lt;html></code> del documento HTML. El diseño se aplica de forma recurrente a través de toda la jerarquía de marcos o de una parte de ella, calculando información geométrica para cada renderizador que lo requiere.
</p>
La posición del renderizador raíz es 0,0 y su dimensión es la ventana gráfica, es decir, la parte visible de la ventana del navegador.
<p>
Todos los renderizadores incluyen un método de "diseño" o de "reflujo" y cada uno activa el método de diseño del elemento secundario al que se debe aplicar el diseño.
</p>
<h4 id="Dirty_bit_system">Sistema de bit de modificación (dirty bit)</h4>
<p>
Para no iniciar un proceso de diseño completo con cada pequeña modificación, el navegador utiliza un sistema de bit de modificación (dirty bit). Cuando se añade o se modifica un renderizador, tanto el propio renderizador como su elemento secundario se marcan con el indicador "dirty", lo que significa que se deben someter a un proceso de diseño.
</p>
<p>
Existen dos indicadores: "dirty" y "children are dirty". El indicador "children are dirty" especifica que, aunque el renderizador no haya sufrido cambios, al menos uno de sus elementos secundarios necesita someterse a un proceso de diseño.
</p>
<h4 id="Global_and_incremental_layout">Diseño global e incremental</h4>
<p>
El proceso de diseño se puede activar en todo el árbol de renderización, lo que se conoce como diseño "global". A continuación se indican algunos motivos por los que puede ser necesario un diseño global:
<ol>
<li>un cambio de estilo global que afecte a todos los renderizadores, como un cambio de tamaño de fuente,</li>
<li>un cambio de tamaño de la pantalla.</li>
</ol>
</p>
<p>
El diseño puede ser incremental, en cuyo caso solo se someterán a un proceso de diseño los renderizadores marcados como "dirty" (este hecho puede provocar daños que pueden requerir procesos de diseño adicionales).
<br>
Cuando los renderizadores están marcados como "dirty", se activa (de forma asíncrona) el diseño incremental (por ejemplo, cuando se añaden renderizadores nuevos al árbol de renderización después de incluir contenido adicional de la red en el árbol de DOM).
</p>


<figure>
  <img src="reflow.png" width="326" height="341" />
  <figcaption> <span>Figura </span>: diseño incremental en el que solo se someten a un proceso de diseño los renderizadores modificados y sus elementos secundarios (<a href="#3_6">3.6</a>)</figcaption>
</figure>

<h4 id="Asynchronous_and_Synchronous_layout">Diseño asíncrono y síncrono</h4>
El diseño incremental se efectúa de forma asíncrona. Firefox almacena "comandos de reflujo" para los diseños incrementales y un programador activa la ejecución en lote de estos comandos. WebKit también incluye un temporizador que ejecuta el diseño incremental (se recorre el árbol y se aplica diseño a los renderizadores marcados como "dirty").
<br>
Las secuencias de comandos que solicitan información de estilo, como "offsetHeight", pueden activar el diseño incremental de forma síncrona.
<br>
El diseño global se suele activar de forma síncrona.
<br>
A veces, el diseño se activa como una devolución de llamada posterior a un diseño inicial debido a los cambios que sufren algunos atributos, como la posición de desplazamiento.
<h4 id="Optimizations">Optimizaciones</h4>
Cuando se activa un proceso de diseño por un "cambio de tamaño" o por un cambio en la posición del renderizador (no en su tamaño), el tamaño de los renderizadores se toma de una caché en lugar de recalcularse.
<br>
En algunos casos, solo se modifica un subárbol, por lo que el proceso de diseño no se inicia desde la raíz. Esto puede suceder en aquellos casos en los que el cambio es local y no afecta a los elementos que lo rodean, como el texto insertado en campos de texto (de lo contrario, cada tecla activaría un diseño desde la raíz) .
</p>
<h4 id="The_layout_process">El proceso de diseño</h4>
<p>
El proceso de diseño suele seguir el patrón que se indica a continuación:
<ol>
<li>El renderizador principal determina su propio ancho.
<li>El renderizador principal analiza los elementos secundarios y:
  <ol>
    <li>Sitúa el renderizador secundario (establece su valor x e y).</li>
    <li>Activa la aplicación del diseño del renderizador secundario en caso necesario (si está marcado como "dirty", si se trata de un diseño global o por alguna otra causa), lo que hace que se calcule la altura del renderizador secundario.</li>
  </ol>
</li>
<li>El renderizador principal utiliza las alturas acumulativas de los elementos secundarios y las alturas de los márgenes y el relleno para establecer su propia altura, que utilizará el elemento principal del renderizador principal.</li>
<li>Establece el bit de modificación (dirty bit) en "false".</li>
</ol>
</p>
<p>
Firefox utiliza un objeto "state" (nsHTMLReflowState) como parámetro de diseño (conocido como "reflujo"). Entre otros valores, el objeto de estado incluye el ancho de los elementos principales.
<br>
El resultado del diseño de Firefox es un objeto "metrics" (nsHTMLReflowMetrics) que incluirá la altura computada del renderizador.
</p>
<h4 id="Width_calculation">Cálculo del ancho</h4>
<p>
El ancho del renderizador se calcula utilizando el ancho del bloque contenedor, la propiedad de estilo "width" del renderizador, los márgenes y los bordes.
<br>
Utilicemos para nuestro ejemplo el siguiente elemento "div":
<pre class="prettyprint">
&lt;div style="width:30%"/&gt;
</pre>
WebKit calcularía su ancho de la siguiente forma (clase "RenderBox", método "calcWidth"):
<ul>
<li>El ancho del contenedor es el valor máximo de la propiedad "availableWidth" de los contenedores y 0. En este caso, la propiedad "availableWidth" es la propiedad "contentWidth", que se calcula así:
<pre class="prettyprint">
clientWidth() - paddingLeft() - paddingRight()
</pre>
Las propiedades "clientWidth" y "clientHeight" representan el interior de un objeto, excluyendo el borde y la barra de desplazamiento.
</li>
<li>El ancho de los elementos es el atributo de estilo "width", que se calcula como un valor absoluto computando el porcentaje del ancho del contenedor.
</li>
<li>A continuación, se añaden el relleno y los bordes horizontales.</li>
</ul>
Hasta ahora, hemos calculado el "ancho preferente". Ahora vamos a calcular los anchos mínimo y máximo.
<br>
Si el ancho preferente es superior al ancho máximo, se utiliza el ancho máximo. Si, por el contrario, es inferior al ancho mínimo (la unidad indivisible más pequeña), se utiliza el ancho mínimo.
</p>
<p>
Los valores se almacenan en caché en caso de que se necesite activar un proceso de diseño sin que varíe el ancho.
</p>
<p>
<h4 id="Line_Breaking">Salto de línea</h4>
<p>
El salto de línea se produce cuando un renderizador decide que debe interrumpirse en mitad del diseño. Se detiene y comunica el salto al renderizador principal. El renderizador principal crea renderizadores adicionales y activa sus procesos de diseño.
</p>
<h3 id="Painting">Pintura</h3>
<p>
En la fase de pintura, se recorre el árbol de renderización y se activa el método de "pintura" de los renderizadores para que se muestre su contenido en la pantalla. En la fase de pintura, se utiliza el componente de infraestructura de la interfaz.
<h4 id="Global_and_Incremental">Global e incremental</h4>
Al igual que ocurre en la fase de diseño, la pintura también puede ser un proceso global (se pinta el árbol de renderización completo) o incremental. En el caso de la pintura incremental, algunos de los renderizadores se modifican de una forma que no afecta a la totalidad del árbol. El renderizador modificado invalida su rectángulo correspondiente en la pantalla. Esto hace que el sistema operativo considere esta región como modificada y que genere un evento de "pintura". El sistema operativo fusiona ingeniosamente varias regiones en una. En Chrome, esta operación resulta más complicada, ya que el renderizador se encuentra en un proceso diferente al proceso principal. Chrome simula el comportamiento del sistema operativo hasta cierto punto. La presentación escucha estos eventos y delega el mensaje en la raíz de la renderización. Se recorre el árbol hasta llegar al renderizador correspondiente. En consecuencia, se vuelve a pintar el renderizador y, normalmente, sus elementos secundarios.
<h4 id="The_painting_order">Orden del proceso de pintura</h4>
Haz clic <a href="http://www.w3.org/TR/CSS21/zindex.html">aquí</a> para conocer el orden del proceso de pintura en CSS2. Es el orden en el que se apilan los elementos en los <a href="#stackingcontext">contextos de pila</a>. Este orden influye en la pintura, ya que las pilas se pintan de atrás hacia delante. El orden de apilamiento de un renderizador de bloque es el siguiente:
<ol>
<li>color de fondo,</li>
<li>imagen de fondo,</li>
<li>borde,</li>
<li>elementos secundarios,</li>
<li>contorno.</li>
</ol>
</p>
<h4 id="Firefox_display_list">Lista de visualización de Firefox</h4>
Firefox analiza el árbol de renderización y crea una lista de visualización para el área rectangular pintada que incluye los renderizadores relevantes para el área rectangular en el orden de pintura correcto (primero los fondos de los renderizadores, luego los bordes, etc.). De esta forma, si se quiere volver a pintar el árbol, solo se tendrá que recorrer una vez (primero se pintan todos los fondos, después todas las imágenes, a continuación todos los bordes, etc.).

<p>
Para optimizar el proceso, Firefox no añade elementos que vayan a quedar ocultos, como los elementos que quedan totalmente ocultos bajo otros elementos opacos.
</p>
<h4 id="Webkit_rectangle_storage">Almacenamiento de figuras rectangulares de WebKit</h4>
Antes de volver a iniciar un proceso de pintura, WebKit guarda el rectángulo antiguo como un mapa de bits. Posteriormente, solo pinta el área diferencial existente entre los rectángulos nuevo y antiguo.

<br>

<h3 id="Dynamic_changes">Cambios dinámicos</h3>
Los navegadores intentan ejecutar la menor cantidad posible de acciones cuando se produce un cambio. Por tanto, si se producen cambios en el color de un elemento, solo se volverá a pintar ese elemento. Si se producen cambios en la posición de un elemento, se volverá a diseñar y a pintar ese elemento, sus elementos secundarios y, posiblemente, los elementos que estén a su mismo nivel. Si se añade un nodo DOM, se activará un proceso de diseño y de nueva pintura del nodo. Si se producen cambios de mayor importancia, como el aumento del tamaño de fuente del elemento "html", se invalidarán las cachés y se activará un nuevo proceso de diseño y de pintura del árbol completo.


<h3 id="The_rendering_engines_threads">Subprocesos del motor de renderización</h3>
El motor de renderización solo consta de un subproceso. Casi todas las operaciones, excepto las de red, se desarrollan en un único subproceso. En Firefox y Safari, es el subproceso principal del navegador. En Chrome, es el subproceso principal del proceso de pestaña.
<br>
Las operaciones de red se pueden realizar mediante varios subprocesos paralelos. El número de conexiones paralelas es limitado (normalmente, de dos a seis conexiones. Por ejemplo, Firefox 3 utiliza seis).
<h4 id="Event_loop">Bucle de eventos</h4>
El subproceso principal del navegador es un bucle de eventos, que consiste en un bucle infinito que mantiene activo el proceso. Espera a que se inicien eventos (como los de diseño y pintura) y los procesa. Este es el código de Firefox para el bucle de eventos principal:
<pre class="prettyprint">
while (!mExiting)
    NS_ProcessNextEvent(thread);
</pre>


<h3 id="css">Modelo de formato visual de CSS2</h3>
<h4 id="The_canvas">El elemento canvas</h4>
<p>
De acuerdo con la <a href="http://www.w3.org/TR/CSS21/intro.html#processing-model">especificación de CSS2</a>, el término canvas describe "el espacio en el que se representa la estructura de formato", es decir, el lugar en el que el navegador pinta el contenido. Aunque el elemento canvas es infinito para cada dimensión del espacio, los navegadores eligen un ancho inicial en función de las dimensiones de la ventana gráfica.
</p>
<p>
De acuerdo con las indicaciones de la página <a href="http://www.w3.org/TR/CSS2/zindex.html">www.w3.org/TR/CSS2/zindex.html</a>, el elemento canvas es transparente si se incluye dentro de otro elemento o tiene un color definido por el navegador si no se incluye en ningún elemento.
</p>
<h4 id="CSS_Box_model">Modelo de cajas de CSS</h4>
<p>
El <a href="http://www.w3.org/TR/CSS2/box.html">modelo de cajas de CSS</a> describe las cajas rectangulares que se generan para los elementos del árbol del documento y que se diseñan de acuerdo con el modelo de formato visual.
<br>
Cada caja consta de un área de contenido (por ejemplo, texto, una imagen, etc.) y de áreas circundantes opcionales de margen, borde y relleno.


<figure>
  <img src="image046.jpg" width="509" height="348" >
  <figcaption> <span>Figura </span>: modelo de cajas de CSS2</figcaption>
</figure>


<p>
Cada nodo genera entre 0y n cajas de este tipo.
<br>
Todos los elementos tienen una propiedad "display" que determina el tipo de caja que se generará. Ejemplos:

<pre class="prettyprint">
block  - generates a block box.
inline - generates one or more inline boxes.
none - no box is generated.
</pre>
Aunque el tipo de caja predeterminado es "inline", la hoja de estilo del navegador establece otros tipos predeterminados. Por ejemplo, el tipo de visualización predeterminado de un elemento "div" es "block".
<br>
Puedes consultar un ejemplo de hoja de estilo predeterminada en la página <a href="http://www.w3.org/TR/CSS2/sample.html">www.w3.org/TR/CSS2/sample.html</a>.
</p>

<h4 id="Positioning_scheme">Esquema de posicionamiento</h4>
<p>
A continuación se indican los tres tipos de esquemas disponibles.
<ol>
<li>Flujo normal: el objeto se coloca en función del lugar que ocupa en el documento (esto significa que el lugar que ocupa en el árbol de renderización es similar al lugar que ocupa en el árbol de DOM) y se diseña de acuerdo con sus dimensiones y con el tipo de caja.</li>
<li>Flotante: el objeto se diseña primero según el flujo normal y, posteriormente, se mueve hacia la derecha o hacia la izquierda todo lo posible. </li>
<li>Posicionamiento absoluto: el objeto se coloca en el árbol de renderización de una forma diferente a la que se utiliza para colocarlo en el árbol de DOM.</li>
</ol>
</p>
<p>
La propiedad "position" y el atributo "float" determinan el esquema de posicionamiento.
<ul>
<li>Si se utilizan "static" y "relative", se genera un flujo normal.</li>
<li>Si se utilizan "absolute" y "fixed", se produce un posicionamiento absoluto.</li>
</ul>
<br>
Cuando el posicionamiento es estático, no se define ninguna posición, por lo que se utiliza el posicionamiento predeterminado. En otros esquemas, el autor especifica la posición: arriba, abajo, izquierda, derecha.
</p>
<p>
Los siguientes valores determinan el diseño de la caja:
<ul>
<li>tipo de caja,</li>
<li>dimensiones de la caja,</li>
<li>esquema de posicionamiento,</li>
<li>información externa, como el tamaño de las imágenes y el tamaño de la pantalla.</li>
</ul>
</p>
<h4 id="Box_types">Tipos de cajas</h4>
<p>
Caja de bloque: forma un bloque (tiene su propio rectángulo en la ventana del navegador).
</p>


<figure>
  <img src="image057.png" width="150" height="127"  />
  <figcaption> <span>Figura </span>: caja de bloque</figcaption>
</figure>

<p>
Caja integrada: no tiene bloque propio, sino que se incluye en un bloque de contención.
</p>


<figure>
  <img src="image059.png" width="300" height="233" />
  <figcaption><span>Figura </span>: cajas integradas</figcaption>
</figure>



<p>
Las cajas de bloque se colocan en vertical, una detrás de otra, mientras que las cajas integradas se distribuyen horizontalmente.
</p>


<figure>
  <img src="image061.png" width="350" height="324" />
  <figcaption><span>Figura </span>: formato de cajas de bloque e integradas</figcaption>
</figure>


<p>
Las cajas integradas se colocan dentro de líneas o "cajas de línea". Cuando las cajas se alinean tomando como punto de referencia su base, es decir, la parte inferior de un elemento se alinea con otra caja tomando como referencia una parte diferente a la inferior, las líneas tienen como mínimo la misma altura que la caja más alta, aunque pueden ser más altas. En caso de que el ancho del contenedor no sea suficiente, las cajas integradas se colocan en diferentes líneas. Esto es lo que suele ocurrir en un párrafo.

</p>


<figure>
  <img src="image063.png" width="400" height="277" >
  <figcaption><span>Figura </span>: líneas</figcaption>
</figure>

<h3 id="Positioning">Posicionamiento</h3>
<h4 id="Relative">Relativo</h4>
<p>
Posicionamiento relativo: el elemento se coloca normalmente y, a continuación, se mueve según el diferencial correspondiente.
</p>

<figure>
  <img src="image065.png" width="500" height="261" />
  <figcaption><span>Figura </span>: posicionamiento relativo</figcaption>
</figure>

<h4 id="Floats">Flotante</h4>
<p>
Una caja flotante se desplaza a la izquierda o a la derecha de una línea. Lo más interesante de este posicionamiento es que las demás cajas fluyen a su alrededor. A continuación, se incluye un ejemplo con código HTML:
<pre class="prettyprint">
&lt;p&gt;
  &lt;img style="float:right" src="images/image.gif" width="100" height="100"&gt;
  Lorem ipsum dolor sit amet, consectetuer...
&lt;/p&gt;
</pre>
La apariencia sería la siguiente:
</p>


<figure>
  <img src="image067.png" width="444" height="203" />
  <figcaption><span>Figura </span>: caja flotante</figcaption>
</figure>


<h4 id="Absolute_and_fixed">Absoluto y fijo</h4>
<p>
El diseño se define con exactitud independientemente del flujo normal. El elemento no participa en el flujo normal. Las dimensiones son relativas al contenedor. En el posicionamiento fijo, el contenedor es la ventana gráfica.

<figure>
  <img src="image069.png" width="500" height="343" />
  <figcaption><span>Figura </span>: posicionamiento fijo</figcaption>
</figure>


<br>
Nota: la caja fija no se moverá aunque el usuario se desplace por el documento.
</p>
<h3 id="Layered_representation">Representación en capas</h3>
<p>
Las capas se especifican con la propiedad "z-index" de CSS. Representa la tercera dimensión de la caja, es decir, su posición a lo largo del "eje z".
</p>
<p>
Las cajas se dividen en <a id="stackingcontext">pilas</a> (denominadas "contextos de pila"). En cada pila, los elementos que quedan debajo se pintan en primer lugar, y los elementos que quedan encima se colocan en la parte superior, más cerca del usuario. En caso de superposición, se oculta el elemento que queda debajo.
<br>
Las pilas se ordenan según la propiedad "z-index". Las cajas que tienen la propiedad "z-index" forman una pila local. La ventana gráfica forma la pila exterior.

<p>Ejemplo:</p>

<pre class="prettyprint">
&lt;style type="text/css"&gt;
      div {
        position: absolute;
        left: 2in;
        top: 2in;
      }
&lt;/style&gt;

&lt;p&gt;
    &lt;div
         style="z-index: 3;background-color:red; width: 1in; height: 1in; "&gt;
    &lt;/div&gt;
    &lt;div
         style="z-index: 1;background-color:green;width: 2in; height: 2in;"&gt;
    &lt;/div&gt;
 &lt;/p&gt;
</pre>
Se obtendrá el siguiente resultado:
</p>


<figure>
  <img src="image071.png" width="254" height="227" />
  <figcaption><span>Figura </span>: posicionamiento fijo</figcaption>
</figure>

<p>
Aunque el elemento "div" rojo preceda al verde en el marcado y se pinte en primer lugar en un flujo normal, el valor de la propiedad "z-index" es superior, por lo que se encuentra más adelantado en la pila de la caja raíz.
</p>




<h3 id="Resources">Recursos</h3>
<div class="autonum">
  <ol>
      <li id="1">Arquitectura del navegador
          <ol>
              <li id="1_1">Grosskurth, Alan. <a href="http://grosskurth.ca/papers/browser-refarch.pdf">A Reference Architecture for Web Browsers (pdf)</a>
              <li id="1_2">Gupta, Vineet. <a href="http://www.vineetgupta.com/2010/11/how-browsers-work-part-1-architecture/">How Browsers Work - Part 1 - Architecture</a>
          </ol>

      <li id="2">Análisis
          <ol>
              <li id="2_1">Aho, Sethi, Ullman, Compilers: Principles, Techniques, and Tools, también conocido como "The Dragon Book" (El libro del dragón), Addison-Wesley, 1986
              <li id="2_2"> Rick Jelliffe. <a href="http://broadcast.oreilly.com/2009/05/the-bold-and-the-beautiful-two.html">The Bold and the Beautiful: two new drafts for HTML 5</a>
          </ol>

      <li id="3">Firefox
          <ol>
              <li id="3_1">L. David Baron, <a href="http://dbaron.org/talks/2008-11-12-faster-html-and-css/slide-6.xhtml">Faster HTML and CSS: Layout Engine Internals for Web Developers</a>
              <li id="3_2">L. David Baron, <a href="http://www.youtube.com/watch?v=a2_6bGNZ7bA">Faster HTML and CSS: Layout Engine Internals for Web Developers (vídeo de Google Tech Talks)</a>
              <li id="3_3">L. David Baron, <a href="http://www.mozilla.org/newlayout/doc/layout-2006-07-12/slide-6.xhtml">Mozilla's Layout Engine</a>
              <li id="3_4">L. David Baron, <a href="http://www.mozilla.org/newlayout/doc/style-system.html">Mozilla Style System Documentation</a>
              <li id="3_5">Chris Waterson, <a href="http://www.mozilla.org/newlayout/doc/reflow.html">Notes on HTML Reflow</a>
              <li id="3_6">Chris Waterson, <a href="http://www.mozilla.org/newlayout/doc/gecko-overview.htm">Gecko Overview</a>
              <li id="3_7">Alexander Larsson, <a href="https://developer.mozilla.org/en/The_life_of_an_HTML_HTTP_request">The life of an HTML HTTP request</a>
          </ol>

      <li id="4">WebKit
          <ol>
              <li id="4_1">David Hyatt, <a href="http://weblogs.mozillazine.org/hyatt/archives/cat_safari.html">Implementing CSS(part 1)</a>
              <li id="4_2">David Hyatt, <a href="http://weblogs.mozillazine.org/hyatt/WebCore/chapter2.html">An Overview of WebCore</a>
              <li id="4_3">David Hyatt, <a href="http://webkit.org/blog/114/">WebCore Rendering</a>
              <li id="4_5">David Hyatt, <a href="http://webkit.org/blog/66/the-fouc-problem/">The FOUC Problem</a>
          </ol>

      <li id="5">Especificaciones de W3C
          <ol>
              <li id="5_1"> <a href="http://www.w3.org/TR/html4/">HTML 4.01 Specification</a>
              <li id="5_2"> <a href="http://dev.w3.org/html5/spec/Overview.html">W3C HTML5 Specification</a>
              <li id="5_3"> <a href="http://www.w3.org/TR/CSS2/">Cascading Style Sheets Level 2 Revision 1 (CSS 2.1) Specification</a>
          </ol>

      <li>Instrucciones de creación de navegadores
          <ol>
              <li>Firefox: <a href="https://developer.mozilla.org/en/Build_Documentation">https://developer.mozilla.org/en/Build_Documentation</a>
              <li>WebKit: <a href="http://webkit.org/building/build.html">http://webkit.org/building/build.html</a>
          </ol>

  </ol>

  <!--  -->

</div>


</div>

<aside class="bio">

  <img align=left src="/static/images/profiles/taligarsiel.png">
  <p><a href="http://taligarsiel.com/">Tali Garsiel</a> es una desarrolladora de Israel. Empezó su andadura como desarrolladora web en el año 2000 y se familiarizó con el "maléfico" modelo de capas de Netscape. Al igual que Richard Feynmann, sentía fascinación por descubrir cómo funcionaban las cosas, por lo que empezó a investigar los mecanismos de funcionamiento interno de los navegadores y a documentar todos sus descubrimientos. Tali también ha publicado una pequeña <a href="http://taligarsiel.com/ClientSidePerformance.html">guía sobre rendimiento de aplicaciones cliente</a>. </p>

</aside>


<h4>Traducciones</h4>
<p>Esta página se ha traducido al japonés ¡dos veces! <a href="http://cou929.nu/docs/how-browsers-work/">Cómo funcionan los navegadores: lo que hay detrás de los navegadores web actuales (ja)</a> por <a href="https://twitter.com/#!/_kosei_">@_kosei_</a> y <a href="http://shanon-tech.blogspot.com/2011/09/web.html">ブラウザってどうやって動いてるの？（モダンWEBブラウザシーンの裏側</a> por <a href="https://twitter.com/#!/ikeike443">@ikeike443</a> y <a href="https://twitter.com/#!/kiyoto01">@kiyoto01</a>. ¡Gracias a todos!</p>

<script>
var toc = $('ol.toc');

function getReffedElem(elem){
  return $($(elem).attr('href'));
}

$(function(){

toc
  .find(' > li > a').each(function(i, elem) {
    // top level chapters get a preceding line
    $('<h5 class="tocchap"></h5>')
      .text('Chapter ' + (i + 1))
      .insertBefore(getReffedElem(elem));

    $(elem).parent().find(' > ol > li > a').each(function(j, elem2) {
      $('<span class="tocnum"></span>')
        .text( (i + 1) + '.' + (j + 1) + ' ')
        .prependTo(getReffedElem(elem2));

      $(elem2).parent().find(' > ol > li > a').each(function(k, elem3) {
        $('<span class="tocnum"></span>')
          .text( (i + 1) + '.' + (j + 1) + '.' + (k + 1) + ' ')
          .prependTo(getReffedElem(elem3));
      });
    });
  });
});


$('figcaption span').each(function(i, elem) {
  elem.setAttribute('data-count', i + 1);
});
  //console.log(elem, $(elem).attr('href'),  $('a[name="' +  )
</script>


{% endblock %}