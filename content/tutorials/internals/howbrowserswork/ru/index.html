{% extends "tutorial.html" %}

{% block headauthor %}Tali Garsiel <tgarsiel@gmail.com>{% endblock %}
{% block pageauthor %}{% profilelinks taligarsiel paulirish %}{% endblock %}
{% block headtitle %}How Browsers Work: Behind the Scenes of Modern Web Browsers{% endblock %}
{% block pagetitle %}<b>How Browsers Work: </b> Behind the Scenes of Modern Web Browsers{% endblock %}
{% block head %}

{% endblock %}
{% block pagebreadcrumb %}How Browsers Work: Behind the Scenes of Modern Web Browsers{% endblock %}
{% block date %}August 16, 2011{% endblock %}
{% block updated %}{% endblock %}
{% block onload %}{% endblock %}

{% block browsersupport %}
<span class="browser opera supported"><span class="browser_name">Opera</span><span class="support">supported</span></span> <span class="browser ie supported"><span class="browser_name">Internet Explorer</span><span class="support">supported</span></span> <span class="browser safari supported"><span class="browser_name">Safari</span><span class="support">supported</span></span> <span class="browser ff supported"><span class="browser_name">Firefox</span><span class="support">supported</span></span> <span class="browser chrome supported"><span class="browser_name">Chrome</span><span class="support">supported</span></span>
{% endblock %}

{% block iscompatible %}

{% endblock %}


{% block content %}


<style>
  h1 b { display:block; font-size: 58px;}
  .browser_support, #html5badge, #html5badge + nav { display:none; }
  a[name] { color: currentColor; }
  blockquote { opacity: 0.9; border-left: 8px solid #ccc; padding-left: 20px; }
  body { line-height: 1.3; }
  li { margin: 3px 0;}
  h3 { font-size: 19px; }
  h4 { font-size: 15.5px; }
  h5 { font-size: 14px; }
  #stack { margin: 5px auto;}
  #stack td, #stack th { border-bottom: 1px dotted #999; }
  samp { background-color: #f2f2f2; border-radius: 2px; padding: 0 2px; }
  samp:empty { display:none; }
  ol.toc { padding-left: 20px; line-height: 1.1; }
  .autonum *:target { background: hsl(60, 73%, 93%);}
  cite { display:block; text-align: right; font-size: 80%; }
  figcaption span:after { content: attr(data-count) ; }

  .tocchap, .tocnum { cursor: default; }
  .tocchap { color: hsl(0, 0%, 60%); margin-bottom: 0; margin-top: 30px; }
  .tocchap + * { margin-top: 5px; }
  h2, h3, h4, h5 { position: relative; }
  .tocnum { position: absolute; left: -56px; width: 50px; text-align: right; font-size: 70%; top: 3px;
    color: hsl(0, 0%, 80%);
    -webkit-transition: all 0.3s ease-out;
       -moz-transition: all 0.3s ease-out;
        -ms-transition: all 0.3s ease-out;
         -o-transition: all 0.3s ease-out;
            transition: all 0.3s ease-out;
  }
  h2:hover .tocnum, h3:hover .tocnum, h4:hover .tocnum, h5:hover .tocnum { color: hsl(0, 0%, 20%); }
  .preface + hr + .tocchap { visibility: hidden;  }
  aside.bio  { border: 3px double hsl(0, 0%, 80%); padding: 10px; }
  aside.bio img { width: 70px; margin: 0 10px 0 0; border: 1px solid hsl(0, 0%, 50%); }
  aside.bio p { margin: 0; }
</style>
<script >
  [].forEach.call( document.querySelectorAll('header .date a'), function(elem, i) {
    elem.textContent += ' (' + ['author','editor'][i] + ')';
  });
</script>

<div class="preface">
<h2>Предисловие</h2>
<p>
  Это подробное руководство по внутренним механизмам работы систем WebKit и Gecko стало результатом обширных исследований, проведенных израильской веб-программисткой Тали Гарсиэль. Она в течение нескольких лет отслеживала всю публикуемую информацию о том, как устроены браузеры <small>(см. раздел <a href="#Resources">Ресурсы</a>)</small>, и посвятила много времени анализу их исходного кода. Вот что пишет сама Тали:

  <blockquote>
    Когда на 90% компьютеров был установлен IE, приходилось мириться с тем, что это загадочный "черный ящик", однако теперь, когда <a href="http://techcrunch.com/2011/08/01/open-web-browsers/">более половины пользователей</a> выбирает браузеры с открытым исходным кодом, пришло время разобраться, что скрывается у них внутри, в миллионах строк программного кода на C++...
  </blockquote>
  Тали опубликовала результаты исследования на <a href="http://taligarsiel.com/">своем сайте</a>, однако мы считаем, что они заслуживают внимания более широкой аудитории, поэтому размещаем их здесь с некоторыми сокращениями.

<p>
  <strong>Веб-разработчик, знакомый с внутренним механизмом работы браузеров, принимает более квалифицированные решения и понимает, почему следует выбрать те или иные средства</strong>. Это достаточно объемный документ, однако мы рекомендуем читать его как можно внимательнее и гарантируем, что вы не пожалеете об этом.

  <cite>Пол Айриш, Chrome Developer Relations</cite>


</div>

<hr>

<h2 id="Introduction">Введение</h2>
<p>
Веб-браузеры, пожалуй, являются самыми распространенными приложениями. В этом учебнике я объясняю, как они работают. Мы подробно рассмотрим, что происходит с момента, когда вы набираете в адресной строке <code>google.ru</code>, до появления страницы Google на экране.
</p>

<h3>Содержание</h3>

<ol class="toc">
<li><a href="#Introduction">Введение</a>
<ol>
  <li><a href="#The_browsers_we_will_talk_about">Какие браузеры мы рассмотрим</a></li>
  <li><a href="#The_browser_main_functionality">Основные функции браузера</a></li>
  <li><a href="#The_browser_high_level_structure">Структура верхнего уровня</a></li>
</ol>
</li>
<li><a href="#The_rendering_engine">Модуль отображения</a>
<ol>
  <li><a href="#Rendering_engines">Модули отображения</a></li>
  <li><a href="#The_main_flow">Основная схема работы</a></li>
  <li><a href="#Main_flow_examples">Примеры работы</a></li>
</ol>
</li>
<li><a href="#Parsing_general">Синтаксический анализ и построение дерева DOM</a>
<ol>
  <li><a href="#Parsing_general">Синтаксический анализ: общие сведения</a>
  <ol>
      <li><a href="#Grammars">Грамматика</a></li>
      <li><a href="#Parser_Lexer_combination">Синтаксический и лексический анализаторы</a></li>
      <li><a href="#Translation">Перевод</a></li>
      <li><a href="#Parsing_example">Пример синтаксического анализа</a></li>
      <li><a href="#Formal_definitions_for_vocabulary_and_syntax">Формальное определение словаря и синтаксиса</a></li>
      <li><a href="#Types_of_parsers">Типы синтаксических анализаторов</a></li>
    <li><a href="#Generating_parsers_automatically">Автоматическое создание синтаксических анализаторов</a></li>
  </ol>
  </li>
  <li><a href="#HTML_Parser">Синтаксический анализатор HTML</a>
  <ol>
      <li><a href="#The_HTML_grammar_definition">Определение грамматики HTML</a></li>
      <li><a href="#Not_a_context_free_grammar">Контекстная грамматика</a></li>
      <li><a href="#HTML_DTD">DTD в HTML</a></li>
    <li><a href="#DOM">DOM</a></li>
      <li><a href="#The_parsing_algorithm">Алгоритм синтаксического анализа</a></li>
      <li><a href="#The_tokenization_algorithm">Алгоритм лексического анализа</a></li>
    <li><a href="#Tree_construction_algorithm">Алгоритм построения дерева</a></li>
      <li><a href="#Actions_when_the_parsing_is_finished">Действия после синтаксического анализа</a></li>
      <li><a href="#Browsers_error_tolerance">Обработка ошибок браузерами</a></li>
  </ol>
  </li>
  <li><a href="#CSS_parsing">Синтаксический анализ CSS</a>
  <ol>
    <li><a href="#Webkit_CSS_parser">Синтаксический анализатор CSS в WebKit</a></li>
  </ol>
  </li>
  <li><a href="#The_order_of_processing_scripts_and_style_sheets">Порядок обработки скриптов и таблиц стилей</a>
  <ol>
      <li><a href="#Scripts">Скрипты</a></li>
      <li><a href="#Speculative_parsing">Ориентировочный синтаксический анализ</a></li>
      <li><a href="#Style_sheets">Таблицы стилей</a></li>
  </ol>
  </li>
</ol>
</li>
<li><a href="#Render_tree_construction">Построение дерева отображения</a>
<ol>
  <li><a href="#The_render_tree_relation_to_the_DOM_tree">Как дерево отображения связано с деревом DOM</a></li>
  <li><a href="#The_flow_of_constructing_the_tree">Процесс построения дерева</a></li>
  <li><a href="#Style_Computation">Вычисление стилей</a>
<ol>
    <li><a href="#Sharing_style_data">Совместное использование информации о стилях</a></li>
    <li><a href="#Firefox_rule_tree">Дерево правил Firefox</a>
<ol>
      <li><a href="#Division_into_structs">Разделение на структуры</a></li>
      <li><a href="#Computing_the_style_contexts_using_the_rule_tree">Расчет контекстов стилей с помощью дерева правил</a></li>
    </ol>
</li>
    <li><a href="#Manipulating_the_rules_for_an_easy_match">Классификация правил для упрощения сопоставления</a></li>
<li><a href="#Applying_the_rules_in_the_correct_cascade_order">Применение правил в порядке приоритета</a>
<ol>
    <li><a href="#Style_sheet_cascade_order">Порядок приоритета таблиц стилей</a></li>
<li><a href="#Specificity">Специфичность</a></li>
<li><a href="#Sorting_the_rules">Сортировка правил</a></li>
</ol>
</li>
</ol>
</li>
<li><a href="#Gradual_process">Последовательное применение</a></li>
</ol>
</li>
<li><a href="#Layout">Компоновка</a>
  <ol>
    <li><a href="#Dirty_bit_system">Система "грязных битов"</a></li>
    <li><a href="#Global_and_incremental_layout">Глобальная и инкрементная компоновка</a></li>
    <li><a href="#Asynchronous_and_Synchronous_layout">Синхронная и асинхронная компоновка</a></li>
    <li><a href="#Optimizations">Оптимизация</a></li>
<li><a href="#The_layout_process">Процесс компоновки</a></li>
    <li><a href="#Width_calculation">Расчет ширины</a></li>
    <li><a href="#Line_Breaking">Перенос строк</a></li>
  </ol>
 </li>
<li><a href="#Painting">Отрисовка</a>
  <ol>
    <li><a href="#Global_and_Incremental">Глобальная и инкрементная отрисовка</a></li>
    <li><a href="#The_painting_order">Порядок отрисовки</a></li>
    <li><a href="#Firefox_display_list">Список отображения Firefox</a></li>
    <li><a href="#Webkit_rectangle_storage">Хранилище прямоугольников в WebKit</a></li>
  </ol>
 </li>
<li><a href="#Dynamic_changes">Динамические изменения</a></li>
<li><a href="#The_rendering_engines_threads">Потоки модуля отображения</a>
<ol>
    <li><a href="#Event_loop">Цикл событий</a></li>
  </ol>
</li>
<li><a href="#css">Визуальная модель CSS2</a>
  <ol>
    <li><a href="#The_canvas">Холст</a></li>
    <li><a href="#CSS_Box_model">Модель окна в CSS</a></li>
    <li><a href="#Positioning_scheme">Схема позиционирования</a></li>
    <li><a href="#Box_types">Типы окон</a></li>
<li><a href="#Positioning">Позиционирование</a>
<ol>
      <li><a href="#Relative">Относительное позиционирование</a></li>
      <li><a href="#Floats">Плавающие элементы</a></li>
  <li><a href="#Absolute_and_fixed">Абсолютное и фиксированное позиционирование</a></li>
</ol>
</li>
<li><a href="#Layered_representation">Многослойное представление</a></li>
  </ol>
 </li>
<li><a href="#Resources">Ресурсы</a></li>
</ol>



<div>

<h3 id="The_browsers_we_will_talk_about">Какие браузеры мы рассмотрим</h3>
<p>
На сегодняшний день существует пять основных браузеров: Internet Explorer, Firefox, Safari, Chrome и Opera. В примерах используются браузеры с открытым исходным кодом: Firefox, Chrome и Safari (код открыт частично). Согласно <a href="http://gs.statcounter.com/">статистике использования браузеров на сайте StatCounter</a>, на август 2011 года браузеры Firefox, Safari и Chrome были установлены в общей сложности на 60% устройств. Таким образом, браузеры с открытым исходным кодом имеют на сегодняшний день весьма сильные позиции.
</p>

<h3 id="The_browser_main_functionality">Основные функции браузера</h3>
<p>
Основное предназначение браузера – отображать веб-ресурсы. Для этого на сервер отправляется запрос, а результат выводится в окне браузера. Под ресурсами в основном подразумеваются HTML-документы, однако это также может быть PDF-файл, картинка или иное содержание. Расположение ресурса определяется с помощью URI (унифицированного идентификатора ресурсов).
</p>
<p>
То, каким образом браузер обрабатывает и отображает HTML-файлы, определено спецификациями HTML и CSS. Они разрабатываются Консорциумом <a id="w3c">W3C</a>, который внедряет стандарты для Интернета.
<br>
<!-- The current version of HTML is 4 (<a href="http://www.w3.org/TR/html401/">http://www.w3.org/TR/html401/</a>). Version 5 is in progress.
The current CSS version is 2 (<a href="http://www.w3.org/TR/CSS2/">http://www.w3.org/TR/CSS2/</a>) and version 3 is in progress.
<br> -->
Многие годы браузеры отвечали лишь части спецификаций, и для них создавались отдельные расширения. Для веб-разработчиков это означало серьезные проблемы с совместимостью. Сегодня большинство браузеров в большей или меньшей степени отвечает всем спецификациям.
</p>
<p>
Пользовательские интерфейсы разных браузеров имеют много общего. Основные элементы интерфейса браузера перечислены ниже.
<ul>
<li>Адресная строка для ввода URI</li>
<li>Кнопки навигации "Назад" и "Вперед"</li>
<li>Закладки</li>
<li>Кнопки обновления и остановки загрузки страницы</li>
<li>Кнопка "Домой" для перехода на главную страницу</li>
</ul>

<p>
Как ни странно, спецификации, которая бы определяла стандарты пользовательского интерфейса браузера, не существует. Современные интерфейсы являются результатом многолетней эволюции, а также того, что разработчики частично копируют друг друга. В спецификации HTML5 не указано, что именно должен содержать интерфейс браузера, однако перечислены некоторые основные элементы. К ним относится адресная строка, строка состояния и панель инструментов. Разумеется, существуют и специфические функции, такие как менеджер загрузок в Firefox.
</p>
<h3 id="The_browser_high_level_structure">Структура верхнего уровня</h3>
<p>
Ниже перечислены основные компоненты браузера (<a href="#1_1">1.1</a>).
</p>

<ol>

  <li><strong>Пользовательский интерфейс</strong> – включает адресную строку, кнопки "Назад" и "Вперед", меню закладок и т. д. К нему относятся все элементы, кроме окна, в котором отображается запрашиваемая страница.</li>
  <li><strong>Механизм браузера</strong> – управляет взаимодействием интерфейса и модуля отображения.</li>
  <li><strong>Модуль отображения</strong> – отвечает за вывод запрошенного содержания на экран. Например, если запрашивается HTML-документ, модуль отображения выполняет синтаксический анализ кода HTML и CSS и выводит результат на экран.</li>
  <li><strong>Сетевые компоненты</strong> – предназначены для выполнения сетевых вызовов, таких как HTTP-запросы. Их интерфейс не зависит от типа платформы, для каждого из которых есть собственные реализации.</li>
  <li><strong>Исполнительная часть пользовательского интерфейса</strong> – используется для отрисовки основных виджетов, таких как окна и поля со списками. Ее универсальный интерфейс также не зависит от типа платформы. Исполнительная часть всегда применяет методы пользовательского интерфейса конкретной операционной системы.</li>
  <li><strong>Интерпретатор JavaScript</strong> – используется для синтаксического анализа и выполнения кода JavaScript.</li>
  <li><strong>Хранилище данных</strong> – необходимо для сохраняемости процессов. Браузер сохраняет на жесткий диск данные различных типов, например файлы cookie. В новой спецификации HTML (HTML5) имеется определение термина "веб-база данных": это полноценная (хотя и облегченная) браузерная база данных.</li>

</ol>


<figure>
  <img src="layers.png" width="500" height="339" alt="" title="" />
  <figcaption><span>Рисунок </span>. Основные компоненты браузера.</figcaption>
</figure>


<p>
Следует отметить, что Chrome, в отличие от большинства браузеров, использует несколько экземпляров модуля отображения, по одному в каждой вкладке, которые представляют собой отдельные процессы.
</p>

<h2 id="The_rendering_engine">Модуль отображения</h2>
<p>
Как можно догадаться по названию, модуль отображения отвечает за вывод запрошенного содержания на экране браузера.
</p>
<p>
По умолчанию он способен отображать HTML- и XML-документы, а также картинки. Специальные подключаемые модули (расширения для браузеров) делают возможным отображение другого содержания, например PDF-файлов. Однако эта глава посвящена основным функциям: отображению HTML-документов и картинок, отформатированных с помощью стилей CSS.</p>

<h3 id="Rendering_engines">Модули отображения</h3>
<p>
В интересующих нас браузерах (Firefox, Chrome и Safari) используются два модуля отображения. В Firefox применяется Gecko – собственная разработка Mozilla, а в Safari и Chrome используется WebKit.
</p>
<p>
WebKit представляет собой модуль отображения с открытым исходным кодом, который был изначально разработан для платформы Linux и адаптирован компанией Apple для Mac OS и Windows. Подробные сведения можно найти на сайте <a href="http://webkit.org/">webkit.org</a>.
</p>

<h3 id="The_main_flow">Основная схема работы</h3>
<p>
Модуль отображения получает содержание запрошенного документа по протоколу сетевого уровня, обычно фрагментами по 8 КБ.
</p>
<p>
Схема дальнейшей работы модуля отображения выглядит приведенным ниже образом.

</p>

<figure>
  <img src="flow.png" width="600" height="66" alt="" title=""   />
  <figcaption><span>Рисунок </span>. Схема работы модуля отображения.</figcaption>
</figure>


<p>
Модуль отображения выполняет синтаксический анализ HTML-документа и переводит теги в узлы <a href="#DOM">DOM</a> в дереве содержания. Информация о стилях извлекается как из внешних CSS-файлов, так и из элементов style. Эта информация и инструкции по отображению в HTML-файле используются для создания еще одного дерева – <a href="#Render_tree_construction">дерева отображения</a>.
</p>
<p>
Оно содержит прямоугольники с визуальными атрибутами, такими как цвет и размер. Прямоугольники располагаются в том порядке, в каком они должны быть выведены на экран.
</p>
<p>
После создания дерева отображения начинается <a href="#layout">компоновка</a> элементов, в ходе которой каждому узлу присваиваются координаты точки на экране, где он должен появиться. Затем выполняется <a href="#Painting">отрисовка</a>, при которой узлы дерева отображения последовательно отрисовываются с помощью исполнительной части пользовательского интерфейса.
</p>
<p>
Важно понимать, что это последовательный процесс. Для удобства пользователя модуль отображения старается вывести содержание на экран как можно скорее, поэтому создание дерева отображения и компоновка могут начаться еще до завершения синтаксического анализа кода HTML. Одни части документа анализируются и выводятся на экран, в то время как другие только передаются по сети.
</p>

<h4 id="Main_flow_examples">Примеры работы</h4>

  <figure>
    <img src="webkitflow.png" width="624" height="289" alt=""  />
    <figcaption><span>Рисунок </span>. Схема работы модуля отображения WebKit.</figcaption>
  </figure>


  <figure>
    <img src="image008.jpg" width="624" height="290" alt="" />
    <figcaption><span>Рисунок </span>. Схема работы модуля отображения Mozilla Gecko (<a href="#3_6">3.6</a>).</figcaption>
  </figure>


<p>
Как видно из рисунков 3 и 4, в WebKit и Gecko используется разная терминология, однако схемы их работы практически идентичны.
<p>
В Gecko дерево визуально отформатированных элементов называется деревом фреймов (frame tree), в котором каждый элемент является фреймом. В WebKit используется дерево отображения (render tree), состоящие из объектов отображения (render objects). Размещение элементов в WebKit называется компоновкой, или версткой (layout), а в Gecko – обтеканием (reflow). Объединение узлов DOM и визуальных атрибутов для создания дерева отображения называется в WebKit совмещением (attachment). Небольшое отличие Gecko, не имеющее отношения к семантике, состоит в том, что между HTML-файлом и деревом DOM находится еще один уровень. Он называется буфером содержания (content sink) и служит для формирования элементов DOM. Теперь поговорим о каждом этапе работы подробнее.
<p>
<h3 id="Parsing_general">Синтаксический анализ: общие сведения</h3>
<p>
Так как синтаксический анализ является важным этапом работы модуля отображения, рассмотрим его подробнее. Начнем с краткого введения.
</p>
<p>
Под синтаксическим анализом документа подразумевается его преобразование в пригодную для чтения и выполнения структуру. Результатом синтаксического анализа, как правило, является дерево узлов, представляющих структуру документа. Оно называется деревом синтаксического анализа, или просто синтаксическим деревом.
</p>

<p>
Например, в результате синтаксического анализа выражения <samp>2 + 3 – 1</samp> может получиться такое дерево:

</p>



<figure>
  <img src="image009.png" width="400" height="155" />
  <figcaption> <span>Рисунок </span>. Узел дерева для математического выражения.</figcaption>
</figure>

<h4 id="Grammars">Грамматика</h4>
<p>
Синтаксический анализ работает на основе определенных правил, которые определяются языком (форматом) документа. Для каждого формата существуют грамматические правила, состоящие из словаря и синтаксиса. Они образуют т. н. <a href="#context_free_grammar">бесконтекстную грамматику</a>. Естественные языки не подчиняются правилам бесконтекстной грамматики, поэтому стандартные техники синтаксического анализа для них не годятся.
</p>
<h4 id="Parser_Lexer_combination">Синтаксический и лексический анализаторы</h4>
<p>
Вместе с синтаксическим применяется лексический анализ.
</p>
<p>
Лексический анализ представляет собой разделение информации на токены, или лексемы. Токены образуют словарь того или иного языка и являются конструктивными элементами для создания документов. В естественном языке токенами бы были все слова, которые можно найти в словарях.
</p>
<p>
Смысл синтаксического анализа состоит в применении синтаксических правил языка.
</p>
<p>
Анализ документа обычно выполняется двумя компонентами: <b>лексическим анализатором</b>, разбирающим входную последовательность символов на действительные токены, и <b>синтаксическим анализатором</b>, анализирующим структуру документа согласно синтаксическим правилам данного языка и формирующим синтаксическое дерево. Анализатор игнорирует неинформативные символы, такие как пробелы и переносы строк.
</p>

<figure>
  <img src="image011.png" width="101" height="300" />
  <figcaption>  <span>Рисунок </span>. Переход от исходного документа к синтаксическому дереву.</figcaption>
</figure>

<p>
Синтаксический анализ является итеративным процессом. Синтаксический анализатор обычно запрашивает у лексического новый токен и проверяет его на предмет соответствия какому-либо из синтаксических правил. Если удается установить соответствие, для токена создается новый узел в синтаксическом дереве, а анализатор запрашивает следующий токен.
<p>
Если токен не соответствует ни одному правилу, синтаксический анализатор откладывает его и запрашивает следующие токены. Так продолжается до тех пор, пока не будет найдено правило, которому бы отвечали все отложенные токены. Если найти такое правило не удается, анализатор создает исключение. Это означает, что документ содержит синтаксические ошибки и не может быть обработан полностью.
</p>
<h4 id="Translation">Перевод</h4>
<p>
Синтаксическое дерево не всегда бывает окончательным результатом. Синтаксический анализ часто используется в процессе перевода входного документа в нужный формат. Примером может служить компиляция. Компилятор, который переводит исходный код в машинный, сначала разбирает его и формирует синтаксическое дерево, а лишь потом создает на основе этого дерева документ с машинным кодом.
</p>


<figure>
  <img src="image013.png" width="104" height="400" />
  <figcaption><span>Рисунок </span>. Этапы компиляции.</figcaption>
</figure>


<h4 id="Parsing_example">Пример синтаксического анализа</h4>
<p>
На рисунке 5 показано синтаксическое дерево, построенное на основе математического выражения. Определим элементарный математический язык и рассмотрим процесс синтаксического анализа.
<p>
<p>
Словарь: наш язык может содержать целые числа, знаки "плюс" и "минус".
</p>
<p>
Синтаксис
<ol>
<li> Структурными элементами языка являются выражения, операнды и операторы.
<li> Язык может содержать любое количество выражений.</li>
<li> Выражение – это последовательность, состоящая из операнда, оператора и еще одного операнда.</li>
<li> Оператор – это токен "плюс" или "минус".</li>
<li> Операнд – это токен целого числа или выражение.</li>
</ol>
</p>
<p>
  Рассмотрим входную последовательность символов <samp>2 + 3 – 1</samp>.
  <br>
  Первый элемент, отвечающий правилу, – <samp>2</samp> (согласно правилу №5, это операнд). Второй такой элемент – <samp>2 + 3</samp> (последовательность, состоящая из операнда, оператора и еще одного операнда, определена правилом №3). Следующее соответствие мы найдем в самом конце: последовательность <samp>2 + 3 – 1</samp> является выражением. Так как <samp>2+3</samp> – это операнд, мы получаем последовательность, состоящую из операнда, оператора и еще одного операнда, что соответствует определению выражения. Строка <samp>2 + + </samp> не содержит соответствий правилам, поэтому была бы расценена как недействительная.
</p>
<h4 id="Formal_definitions_for_vocabulary_and_syntax">Формальное определение словаря и синтаксиса</h4>
<p>
Словарь обычно состоит из <a href="http://www.regular-expressions.info/">регулярных выражений</a>.
</p>
<p>
Язык из примера выше можно было бы определить так:
<pre class="prettyprint">
INTEGER :0|[1-9][0-9]*
PLUS : +
MINUS: -
</pre>
Как видите, целые числа определены регулярным выражением.
</p>
<p>
Синтаксис обычно описывается в формате <a href="http://ru.wikipedia.org/wiki/%D0%A4%D0%BE%D1%80%D0%BC%D0%B0_%D0%91%D1%8D%D0%BA%D1%83%D1%81%D0%B0_%E2%80%94_%D0%9D%D0%B0%D1%83%D1%80%D0%B0">BNF</a>. Язык из примера выше можно описать так:
<pre class="prettyprint">
expression :=  term  operation  term
operation :=  PLUS | MINUS
term := INTEGER | expression
</pre>
</p>
<p>
Как уже говорилось, язык можно обрабатывать с помощью стандартных синтаксических анализаторов, если его грамматика <a id="context_free_grammar">бесконтекстна</a>, то есть может быть полностью выражена в формате BNF. Формальное определение бесконтекстной грамматики можно найти в <a href="http://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BD%D1%82%D0%B5%D0%BA%D1%81%D1%82%D0%BD%D0%BE-%D1%81%D0%B2%D0%BE%D0%B1%D0%BE%D0%B4%D0%BD%D0%B0%D1%8F_%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0">этой статье Википедии</a>.
<h4 id="Types_of_parsers">Типы синтаксических анализаторов</h4>
<p>
Синтаксические анализаторы бывают двух типов: нисходящие и восходящие. Первые выполняют анализ сверху вниз, а вторые – снизу вверх. Нисходящие анализаторы разбирают структуру верхнего уровня и ищут соответствия синтаксическим правилам. Восходящие анализаторы сначала обрабатывают входную последовательность символов и постепенно выявляют в ней синтаксические правила, начиная с правил нижнего и заканчивая правилами верхнего уровня.
</p>
<p>
Теперь посмотрим, как эти два типа анализаторов справились бы с нашим примером.
</p>
<p>
Нисходящий анализатор начал бы с правила верхнего уровня и определил бы, что <samp>2 + 3</samp> –·это выражение. Затем он определил бы, что <samp>2 + 3 – 1</samp> также является выражением (в процессе определения выражений выявляются и соответствия другим правилам, однако первым всегда рассматривается правило верхнего уровня).
</p>
<p>
Восходящий анализатор обрабатывал бы последовательность символов, пока не нашел бы подходящее правило, которым можно заменить обнаруженный фрагмент, и так до конца последовательности. Выражения с частичным соответствием при этом помещаются в стек анализатора.
<table id="stack">
  <tr><th>Стек</th>                <th>Входные символы</th></tr>
  <tr><td>&nbsp;</td>               <td><samp>2 + 3 – 1 </samp></td></tr>
  <tr><td>операнд</td>                 <td><samp> + 3 – 1 </samp></td></tr>
  <tr><td>оператор с операндом</td>       <td><samp> 3 – 1 </samp></td></tr>
  <tr><td>выражение</td>           <td><samp>– 1 </samp></td></tr>
  <tr><td>оператор с выражением</td> <td><samp>1 </samp></td></tr>
  <tr><td>выражение</td>           <td><samp>&nbsp; </samp></td></tr>
</table>
При работе такого анализатора входная последовательность символов сдвигается вправо (представьте курсор, который помещен в начало последовательности и в ходе анализа сдвигается вправо) и постепенно сводится к синтаксическим правилам.
</p>
<h4 id="Generating_parsers_automatically">Автоматическое создание синтаксических анализаторов</h4>
<p>
Существуют специальные приложения для создания синтаксических анализаторов, которые называются генераторами. Достаточно загрузить в генератор грамматику языка (словарный запас и синтаксические правила), и он автоматически создаст анализатор. Для создания синтаксического анализатора необходимо глубокое понимание принципов его работы, и сделать это вручную не так-то просто, поэтому генераторы бывают весьма полезны.
</p>
<p>
В <a id="parser_generators">WebKit</a> используется два известных генератора: <a href="http://ru.wikipedia.org/wiki/Flex_%28%D0%B3%D0%B5%D0%BD%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80_%D0%BB%D0%B5%D0%BA%D1%81%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D1%85_%D0%B0%D0%BD%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%82%D0%BE%D1%80%D0%BE%D0%B2%29">Flex</a> для создания лексического и <a href="http://www.gnu.org/software/bison/">Bison</a> для создания синтаксического анализатора (они также встречаются под названиями Lex и Yacc). Во Flex загружается файл с определениями токенов в регулярных выражениях, а в Bison – синтаксические правила языка в формате BNF.
</p>
<h3 id="HTML_Parser">Синтаксический анализатор HTML</h3>
<p>
Задача синтаксического анализатора HTML – переводить информацию из кода HTML в синтаксическое дерево.
</p>
<h4 id="The_HTML_grammar_definition">Определение грамматики HTML</h4>
<p>
Словарь и синтаксис HTML определены в <a href="#w3c">спецификациях W3C</a>. Действующей версией является HTML4, версия HTML5 находится в разработке.
</p>
<h4 id="Not_a_context_free_grammar">Контекстная грамматика</h4>
<p>
Как говорилось выше, синтаксические правила языка можно формально определить, например, в формате BNF.
</p><p>
К сожалению, ни один из описанных выше стандартных анализаторов не подходит для языка HTML (но я включила их в этот документ не просто так – они еще пригодятся, когда мы дойдем до CSS и JavaScript). HTML невозможно определить с помощью бесконтекстной грамматики, с которой работают синтаксические анализаторы.
</p><p>
Существует формальный стандарт определения HTML – формат DTD (Document Type Definition), однако его грамматика не является бесконтекстной.
</p><p>
На первый взгляд это кажется странным, ведь язык HTML не так уж далек от XML, а для XML имеется множество синтаксических анализаторов. Существует даже версия HTML на базе XML (XHTML), так в чем же разница?
</p><p>
Разница в том, что в HTML используется менее строгий подход: если пропущены некоторые теги (например, открывающие или закрывающие), они подставляются автоматически. Такой "мягкий" синтаксис отличается от строгого синтаксиса XML.
</p><p>
Это отличие кажется незначительным только на первый взгляд. С одной стороны, это основная причина популярности HTML: способность языка "прощать" ошибки ощутимо облегчает жизнь разработчику. С другой стороны, из-за этого становится сложно формально определить грамматику. Итак, грамматика HTML не является бесконтекстной, поэтому его анализ нельзя выполнить ни с помощью стандартных анализаторов, ни с помощью анализаторов XML.
</p>
<h4 id="HTML_DTD">DTD в HTML </h4>
<p>
Определение HTML задается в формате DTD. Он используется для формализации языков семейства <a href="http://ru.wikipedia.org/wiki/SGML">SGML</a>. Этот формат содержит определения всех допустимых элементов, их атрибутов и иерархии. Как уже упоминалось, в DTD не задается бесконтекстная грамматика.
</p>
<p>
Существует несколько версий DTD. Строгий формат в точности отвечает спецификации, а остальные также поддерживают разметку, которая использовалась браузерами в прошлом. Это необходимо для обратной совместимости с более старым содержанием. Текущую строгую версию DTD можно загрузить по адресу <a href="http://www.w3.org/TR/html4/strict.dtd">www.w3.org/TR/html4/strict.dtd</a>.
</p>
<h4 id="DOM">DOM</h4>
<p>
Полученное синтаксическое дерево состоит из элементов DOM и узлов атрибутов. DOM – объектная модель документа (Document Object Model) – служит для представления HTML-документа и интерфейса элементов HTML таким внешним объектам, как код JavaScript.
<br>
В корне дерева находится объект <a  href="http://www.w3.org/TR/1998/REC-DOM-Level-1-19981001/level-one-core.html#i-Document">Document</a>.
</p>
<p>
Модель DOM практически идентична разметке. Рассмотрим пример разметки:
<pre class="prettyprint">
&lt;html&gt;
  &lt;body&gt;
    &lt;p&gt;
      Hello World
    &lt;/p&gt;
    &lt;div&gt; &lt;img src="example.png"/&gt;&lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>
Дерево DOM для этой разметки выглядит так:

</p>

<figure>
  <img src="image015.png" width="400" height="219"  />
  <figcaption>  <span>Рисунок </span>. Дерево DOM для разметки из примера.</figcaption>
</figure>

<p>
Как и в случае HTML, спецификации DOM разрабатывает Консорциум W3C (см. документ <a href="http://www.w3.org/DOM/DOMTR">www.w3.org/DOM/DOMTR</a>). Это универсальная спецификация для работы с документами. В специальном модуле описаны элементы, характерные для HTML. Определения HTML можно найти здесь: <a href="http://www.w3.org/TR/2003/REC-DOM-Level-2-HTML-20030109/idl-definitions.html">www.w3.org/TR/2003/REC-DOM-Level-2-HTML-20030109/idl-definitions.html</a>.
</p>
<p>
Под словами "дерево содержит узлы DOM" подразумевается, что дерево состоит из элементов, которые реализуют один из интерфейсов DOM. В браузерах применяются специфические реализации, обладающие дополнительными атрибутами для внутреннего использования.
</p>
<h4 id="The_parsing_algorithm">Алгоритм синтаксического анализа</h4>
<p>
Как уже говорилось в предыдущих разделах, синтаксический анализ кода HTML невозможно выполнить с помощью стандартных нисходящих или восходящих анализаторов.
</p>
<p>
Ниже перечислены причины этого.
<ol>
<li>Язык имеет "щадящий" характер.</li>
<li>В браузерах заложены механизмы обработки некоторых частых ошибок в коде HTML.</li>
<li>Цикл синтаксического анализа характеризуется возможностью повторного вхождения. Исходный документ обычно не меняется в процессе анализа, однако в случае HTML теги скрипта, содержащие <code>document.write</code>, могут добавлять новые токены, поэтому исходный код может меняться.</li>
</ol>
<p>
Так как стандартные анализаторы не подходят для HTML, браузеры создают собственные анализаторы.
</p>
<p>
Алгоритм синтаксического анализа подробно описан в <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/parsing.html">спецификации HTML5</a>. Он состоит из двух этапов: лексического анализа и построения дерева.
<p>
В ходе лексического анализа входная последовательность символов разбивается на токены. К токенам HTML относятся открывающие и закрывающие теги, а также названия и значения атрибутов.
</p>
<p>
Лексический анализатор обнаруживает токен, передает его конструктору деревьев и переходит к следующему символу в поиске дальнейших токенов, и так до окончания входной последовательности.
</p>

<figure>
  <img src="image017.png" width="308" height="400" />
  <figcaption><span>Рисунок </span>. Этапы синтаксического анализа кода HTML (источник: спецификация HTML5).</figcaption>
</figure>

<h4 id="The_tokenization_algorithm">Алгоритм лексического анализа</h4>
<p>
Результатом работы алгоритма является токен HTML. Алгоритм выражен в виде автомата с конечным числом состояний. В каждом состоянии обрабатывается один или несколько символов входной последовательности, на основе которых определяется следующее состояние. Оно зависит от этапа лексического анализа и этапа формирования дерева, то есть обработка одного и того же символа может привести к разным результатам (разным состояниям) в зависимости от текущего состояния. Алгоритм достаточно сложен, чтобы подробно описывать его здесь, поэтому рассмотрим упрощенный пример, который поможет нам лучше понять принцип его работы.

</p><p>

Выполним лексический анализ простого кода HTML:

</p>

<pre class="prettyprint">
&lt;html&gt;
  &lt;body&gt;
    Hello world
  &lt;/body&gt;
&lt;/html&gt;
</pre>

<p>

Исходное состояние – "данные". Когда анализатор обнаруживает символ <code>&lt;</code>, состояние меняется на <b>"открытый тег"</b>. Если далее обнаруживается буква (<code>a–z</code>), создается токен открывающего тега, а состояние меняется на <b>"название тега"</b>. Оно сохраняется, пока не будет обнаружен символ <code>&gt;</code>. Символы по одному добавляются к названию нового токена. В нашем случае получается токен <code>html</code>.

</p><p>

При обнаружении символа <code>&gt;</code> токен считается готовым и анализатор возвращается в состояние <b>"данные"</b>. Тег <code>&lt;body&gt;</code> обрабатывается точно так же. Таким образом, анализатор уже сгенерировал теги <code>html</code> и <code>body</code> и вернулся в состояние <b>"данные"</b>. Обнаружение буквы <code>H</code> во фразе <code>Hello world</code> ведет к генерации токена символа. То же происходит с остальными буквами, пока анализатор не дойдет до символа <code>&lt;</code> в теге <code>&lt;/body&gt;</code>. Для каждого символа фразы <code>Hello world</code> создается свой токен.

</p><p>

Затем анализатор снова возвращается в состояние <b>"открытый тег"</b>. Обнаружение символа <code>/</code> ведет к созданию <code>токена закрывающего тега</code> и переходу в состояние <b>"название тега"</b>. Оно сохраняется, пока не будет обнаружен символ <code>&gt;</code>. В этот момент генерируется токен нового тега, а анализатор снова возвращается в состояние <b>"данные"</b>. Последовательность символов <code>&lt;/html&gt;</code> обрабатывается, как описано выше.

</p>

<figure>
  <img src="image019.png" width="627" height="387" >
  <figcaption><span>Рисунок </span>. Лексический анализ входной последовательности символов.</figcaption>
</figure>

<h4 id="Tree_construction_algorithm">Алгоритм построения дерева</h4>
<p>
При создании синтаксического анализатора формируется объект Document. На этапе построения дерево DOM, в корне которого находится этот объект, изменяется и к нему добавляются новые элементы. Каждый узел, генерируемый лексическим анализатором, обрабатывается конструктором деревьев. Для каждого токена создается свой элемент DOM, определенный спецификацией. Элементы добавляются не только в дерево DOM, но и в стек открытых элементов, который служит для исправления неправильно вложенных или незакрытых тегов. Алгоритм также выражается в виде автомата с конечным числом состояний, которые называются "способами включения" (insertion mode). 
</p>

<p>
Рассмотрим этапы создания дерева для следующего фрагмента кода:
</p>


<pre class="prettyprint">
&lt;html&gt;
  &lt;body&gt;
    Hello world
  &lt;/body&gt;
&lt;/html&gt;
</pre>

<p>
В начале этапа построения дерева у нас есть последовательность токенов, полученная в результате лексического анализа. Первое состояние называется <b>исходным</b>. При получении токена html состояние меняется на <b>"до html"</b>, после чего происходит повторная обработка токена в этом состоянии. В результате создается элемент HTMLHtmlElement, который добавляется к корневому объекту Document.

</p><p>

Состояние меняется на <b>"до head"</b>. Анализатор обнаруживает токен body. Хотя в нашем коде нет тега head, элемент HTMLHeadElement будет автоматически создан и добавлен в дерево.

</p><p>

Состояние меняется на <b>"внутри head"</b>, затем на <b>"после head"</b>. Токен body обрабатывается еще раз, создается элемент HTMLBodyElement, который добавляется в дерево, и состояние меняется на <b>"внутри body"</b>.

</p><p>

Теперь пришла очередь токенов строки Hello world. Обнаружение первого из них ведет к созданию и вставке узла Text, к которому затем добавляются остальные символы.

</p><p>

При получении закрывающего токена body состояние меняется на <b>"после body"</b>. Когда анализатор доходит до закрывающего тега html, состояние меняется на <b>"после после body"</b>. При получении токена конца файла анализ завершается.
</p>

<figure>
  <img src="image022.gif" width="532" height="769" />
  <figcaption><span>Рисунок </span>. Построение дерева для кода HTML из примера.</figcaption>
</figure>


<h4 id="Actions_when_the_parsing_is_finished">Действия после синтаксического анализа</h4>
<p>
На этом этапе браузер помечает документ как интерактивный и начинает анализ отложенных скриптов, которые необходимо выполнить после завершения анализа документа. Состояние документа затем меняется на "готово", и вызывается событие load.
</p>

<p>
В <a href="http://www.w3.org/TR/html5/syntax.html#html-parser">спецификации HTML5</a> подробно описаны алгоритмы лексического анализа и построения деревьев.
</p>

<h4 id="Browsers_error_tolerance">Обработка ошибок браузерами</h4>
<p>
На странице HTML вы никогда не увидите ошибку "Недопустимый синтаксис". Браузеры умеют корректировать ошибки содержания, не прерывая работу.

</p><p>
Рассмотрим вот такой код HTML:

</p>

<pre class="prettyprint">
&lt;html&gt;
  &lt;mytag&gt;
  &lt;/mytag&gt;
  &lt;div&gt;
  &lt;p&gt;
  &lt;/div&gt;
    Really lousy HTML
  &lt;/p&gt;
&lt;/html&gt;
</pre>

<p>

В этом коротком фрагменте я нарушила множество правил (mytag не является стандартным тегом, теги p и div вложены неверно и т. д.), однако браузер не испытывает никаких проблем и отображает содержание корректно. Большая часть кода синтаксического анализатора служит для исправления ошибок разработчиков.

</p><p>

В браузерах используются очень похожие механизмы обработки ошибок, но, как ни странно, они не описаны в текущей спецификации HTML. Как и закладки или кнопки навигации, они просто появились в результате многолетней эволюции браузеров. Существуют недопустимые конструкции HTML, которые довольно часто встречаются на сайтах, и разные браузеры исправляют их похожими способами.

</p><p>

В спецификации HTML5 определены некоторые требования к этому механизму. В WebKit они указаны в комментарии к классу parser.

</p>

<blockquote>
<p>Синтаксический анализатор обрабатывает входящие токены и создает дерево документа. Если документ написан без ошибок, выполняется его стандартный анализ.</p>

<p>К сожалению, многие документы HTML содержат ошибки, и синтаксический анализатор должен быть к ним готов.</p>

<p>Он должен уметь обрабатывать как минимум перечисленные ниже типы ошибок.</p>

<ol>
  <li>Использование добавляемого элемента явно запрещено одним из внешних тегов. В этом случае необходимо закрыть все теги, кроме того, который запрещает использование данного элемента, и добавить этот элемент в самом конце.
  <li>Элемент нельзя добавить напрямую. Возможно, автор документа забыл вставить тег между элементами (или такой тег необязателен). Это касается тегов HTML, HEAD, BODY, TBODY, TR, TD, LI (надеюсь, я ничего не забыла).
  <li>Блочный элемент добавлен внутрь строчного. Необходимо закрыть все строчные элементы вплоть до следующего в иерархии блочного элемента.
  <li>Если это не помогает, необходимо закрывать элементы, пока не появится возможность добавить нужный элемент или проигнорировать тег.
</ol>

</blockquote>

<p>
Рассмотрим примеры того, как WebKit обрабатывает некоторые ошибки.
</p>
<h5>Тег &lt;/br&gt; вместо &lt;br&gt;</h5>
<p>
На некоторых сайтах можно встретить тег &lt;/br&gt; там, где должен быть &lt;br&gt;. Чтобы отобразить содержание в браузерах IE и Firefox, WebKit обрабатывает этот тег как &lt;br&gt;.
<br>
Код:
<pre class="prettyprint">
if (t->isCloseTag(brTag) && m_document->inCompatMode()) {
     reportError(MalformedBRError);
     t->beginTag = true;
}
</pre>
Обратите внимание: механизм обработки ошибок является встроенным, пользователь его не видит.
</p>
<h5>"Заблудившаяся" таблица</h5>
<p>
"Заблудившейся" называется таблица, которая находится внутри другой таблицы, но не внутри одной из ее ячеек.
<br>
Пример кода:
<pre class="prettyprint">
&lt;table&gt;
    &lt;table&gt;
        &lt;tr&gt;&lt;td&gt;inner table&lt;/td&gt;&lt;/tr&gt;
    &lt;/table&gt;
    &lt;tr&gt;&lt;td&gt;outer table&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
</pre>
WebKit меняет иерархию, превращая таблицы в элементы одного уровня:
<pre class="prettyprint">
&lt;table&gt;
    &lt;tr&gt;&lt;td&gt;outer table&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
&lt;table&gt;
    &lt;tr&gt;&lt;td&gt;inner table&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
</pre>
Код:
<pre class="prettyprint">
if (m_inStrayTableContent && localName == tableTag)
        popBlock(tableTag);
</pre>
В системе отображения WebKit используется стек для хранения текущих элементов, который выводит внутреннюю таблицу из стека внешней. Теперь таблицы находятся на одном уровне иерархии.
</p>
<h5>Вложенные формы</h5>
<p>
Если автор поместит один элемент form внутрь другого такого элемента, последний будет игнорироваться.
<br>
Код:
<pre class="prettyprint">
if (!m_currentFormElement) {
        m_currentFormElement = new HTMLFormElement(formTag,    m_document);
}
</pre>
</p>
<h5>Слишком много вложенных тегов</h5>
<p>
Комментарий ниже говорит сам за себя.
<br>
<div class="comment">
<blockquote>
На сайте www.liceo.edu.mx иерархия тегов имеет около 1500 уровней, и все это теги &lt;b&gt;. Разрешено использовать не более 20 вложенных тегов одного типа, в противном случае все они будут игнорироваться.
</blockquote>
</div>
<pre class="prettyprint">
bool HTMLParser::allowNestedRedundantTag(const AtomicString& tagName)
{

unsigned i = 0;
for (HTMLStackElem* curr = m_blockStack;
         i &lt; cMaxRedundantTagDepth && curr && curr->tagName == tagName;
     curr = curr->next, i++) { }
return i != cMaxRedundantTagDepth;
}
</pre>
</p>
<h5>Неправильное размещение закрывающих тегов html или body</h5>
<p>
И снова комментарий говорит сам за себя.

<blockquote>
Поддержка по-настоящему неграмотных документов HTML: никогда не закрываем тег body, так как некоторые особо талантливые разработчики пытаются закрыть его раньше, чем кончается документ. Чтобы закрыть теги, используем метод end().
</blockquote>

<pre class="prettyprint">
if (t->tagName == htmlTag || t->tagName == bodyTag )
        return;

</pre>
Веб-разработчикам на заметку: если вы не хотите прославиться в подобных комментариях к механизму обработки ошибок WebKit, пишите качественный код HTML.
</p>
<p>

<h3 id="CSS_parsing">Синтаксический анализ CSS</h3>
<p>
Помните, как в начале учебника мы рассматривали подходы к синтаксическому анализу? В отличие от HTML, в CSS используется бесконтекстная грамматика, поэтому для анализа подходят стандартные средства, о которых мы уже говорили. Кроме того, лексические и синтаксические правила CSS определены в <a href="http://www.w3.org/TR/CSS2/grammar.html">спецификации CSS</a>.
</p>
<p>
Рассмотрим несколько примеров.
<br>
Лексическая грамматика (словарь) определяется регулярными выражениями для каждого токена:
<pre>
comment   \/\*[^*]*\*+([^/*][^*]*\*+)*\/
num   [0-9]+|[0-9]*"."[0-9]+
nonascii  [\200-\377]
nmstart   [_a-z]|{nonascii}|{escape}
nmchar    [_a-z0-9-]|{nonascii}|{escape}
name    {nmchar}+
ident   {nmstart}{nmchar}*
</pre>
<p>
Ident – это идентификатор, который используется как название класса. Name – это элемент id, для ссылки на него используется символ решетки (#).
</p>
<p>
Синтаксические правила описаны в формате BNF.
<pre class="prettyprint lang-css">
ruleset
  : selector [ ',' S* selector ]*
    '{' S* declaration [ ';' S* declaration ]* '}' S*
  ;
selector
  : simple_selector [ combinator selector | S+ [ combinator? selector ]? ]?
  ;
simple_selector
  : element_name [ HASH | class | attrib | pseudo ]*
  | [ HASH | class | attrib | pseudo ]+
  ;
class
  : '.' IDENT
  ;
element_name
  : IDENT | '*'
  ;
attrib
  : '[' S* IDENT S* [ [ '=' | INCLUDES | DASHMATCH ] S*
    [ IDENT | STRING ] S* ] ']'
  ;
pseudo
  : ':' [ IDENT | FUNCTION S* [IDENT S*] ')' ]
  ;
</pre>
Набор правил (ruleset) представляет собой описанную ниже структуру.
<pre class="prettyprint lang-css">
div.error , a.error {
  color:red;
  font-weight:bold;
}
</pre>
Элементы div.error и a.error – это селекторы. Действующие правила данного набора заключены в фигурные скобки. Формально эта структура определяется так:
<pre class="prettyprint lang-css">
ruleset
  : selector [ ',' S* selector ]*
    '{' S* declaration [ ';' S* declaration ]* '}' S*
  ;
</pre>
Это означает, что набор правил действует как селектор или как несколько селекторов, разделенных запятыми и пробелами (S означает пробел). Набор правил содержит одно или несколько объявлений, разделенных точкой с запятой. Они заключены в фигурные скобки. Определения понятий "объявление" и "селектор" будут даны ниже.
</p>
<h4 id="Webkit_CSS_parser">Синтаксический анализатор CSS в WebKit</h4>
<p>
В WebKit для автоматического создания синтаксических анализаторов CSS используются генераторы <a href="#parser_generators">Flex и Bison</a>. Как уже говорилось, Bison служит для создания восходящих анализаторов, при работе которых входная последовательность символов сдвигается вправо. В Firefox используется нисходящий анализатор, разработанный организацией Mozilla. В обоих случаях файл CSS разбирается на объекты StyleSheet, содержащие правила CSS. Объект правил CSS содержит селектор и объявление, а также другие объекты, характерные для грамматики CSS.
</p>

<figure>
  <img src="image023.png" width="500" height="393" alt="" title="" border="0" align=""  />
  <figcaption><span>Рисунок </span>. Синтаксический анализ CSS.</figcaption>
</figure>


<h3 id="The_order_of_processing_scripts_and_style_sheets">Порядок обработки скриптов и таблиц стилей</h3>
<h4 id="Scripts">Скрипты</h4>
<p>
Веб-документы придерживаются синхронной модели. Предполагается, что скрипты будут анализироваться и исполняться сразу же, как только анализатор обнаружит тег &lt;script&gt;. Синтаксический анализ документа откладывается до завершения выполнения скрипта. Если речь идет о внешнем скрипте, сначала необходимо запросить сетевые ресурсы. Это также делается синхронно, а анализ откладывается до получения ресурсов. Такая модель использовалась много лет и даже занесена в спецификации HTML 4 и 5. Разработчик мог пометить скрипт тегом defer, чтобы синтаксический анализ документа можно было выполнять до завершения выполнения скрипта. В HTML5 появилась возможность пометить скрипт как асинхронный (asynchronous), чтобы он анализировался и выполнялся в другом потоке.
</p>
<h4 id="Speculative_parsing">Ориентировочный синтаксический анализ</h4>
<p>
Этот механизм оптимизации используется и в WebKit, и в Firefox. При выполнении скриптов остальные части документа анализируются в другом потоке, чтобы оценить необходимые ресурсы и загрузить их из сети. Таким образом, ресурсы загружаются в параллельных потоках, что повышает общую скорость обработки. Обратите внимание: ориентировочный анализатор не изменяет дерево DOM (это работа основного анализатора), а лишь обрабатывает ссылки на внешние ресурсы, такие как внешние скрипты, таблицы стилей и картинки.
</p>
<h4 id="Style_sheets">Таблицы стилей</h4>
<p>
Таблицы стилей основаны на другой модели. Так как они не вносят изменений в дерево DOM, теоретически останавливать анализ документа, чтобы дождаться их обработки, бессмысленно. Однако скрипты могут запрашивать данные о стилях на этапе синтаксического анализа документа. Если стиль еще не загружен и не проанализирован, скрипт может получить неверную информацию. Разумеется, это повлекло бы за собой целый ряд проблем. Если Firefox обнаруживает таблицу стилей, которая еще не загружена и не проанализирована, то все скрипты останавливаются. В WebKit они останавливаются только в случае, если пытаются извлечь свойства стилей, которые могут быть определены в незагруженных таблицах.
</p>
<h3 id="Render_tree_construction">Построение дерева отображения</h3>
<p>
Во время построения дерева DOM браузер создает еще одну структуру – дерево отображения. В нем визуальные элементы размещаются в том порядке, в каком их необходимо вывести на экран. Это визуальное представление документа. Дерево отображения служит для того, чтобы отрисовка содержания выполнялась в правильном порядке.
</p>
<p>
В Firefox элемент дерева отображения называется "фреймом" (frame). В WebKit используется термин "объект отображения" (render object).
<br>
Каждый объект отображения располагает данными об отрисовке самого себя и своих дочерних элементов.
<br>
Класс RenderObject – основной класс объектов отображения в WebKit – определен следующим образом:
<pre class="prettyprint">
class RenderObject{
  virtual void layout();
  virtual void paint(PaintInfo);
  virtual void rect repaintRect();
  Node* node;  //the DOM node
  RenderStyle* style;  // the computed style
  RenderLayer* containgLayer; //the containing z-index layer
}
</pre>
</p>
<p>
Каждый объект отображения представляет собой прямоугольную область, соответствующую окну CSS узла, как описано в спецификации CSS2. Он содержит геометрические данные, такие как ширина, высота и положение.
<br>
Тип окна зависит от атрибута display объекта style, назначенного данному узлу (см. раздел <a href="#style_computation">Вычисление стилей</a>). Ниже представлен код, который используется в WebKit, чтобы определить, какой тип объекта отображения необходимо создать для узла DOM, на основе атрибута свойства display.
<pre class="prettyprint">
RenderObject* RenderObject::createObject(Node* node, RenderStyle* style)
{
    Document* doc = node->document();
    RenderArena* arena = doc->renderArena();
    ...
    RenderObject* o = 0;

    switch (style->display()) {
        case NONE:
            break;
        case INLINE:
            o = new (arena) RenderInline(node);
            break;
        case BLOCK:
            o = new (arena) RenderBlock(node);
            break;
        case INLINE_BLOCK:
            o = new (arena) RenderBlock(node);
            break;
        case LIST_ITEM:
            o = new (arena) RenderListItem(node);
            break;
       ...
    }

    return o;
}
</pre>
Учитывается и тип элемента: например, для элементов управления формами и таблиц используются специальные фреймы.
<br>
В WebKit, если элемент пытается создать специальный объект отображения, метод <code>createRenderer</code> будет переопределен. Объекты отображения указывают на объекты style, содержащие негеометрическую информацию.
</p>
<h5 id="The_render_tree_relation_to_the_DOM_tree">Как дерево отображения связано с деревом DOM</h5>
Объекты обработки соответствуют элементам DOM, но не идентичны им. Невизуальные элементы DOM не включаются в дерево отображения (примером может служить элемент head). Кроме того, в дерево не включаются элементы, у которых для свойства display задан атрибут none (элементы с атрибутом hidden включаются).
</p>
<p>
Существуют и такие элементы DOM, которым соответствует сразу несколько визуальных объектов. Обычно это элементы со сложной структурой, которые невозможно описать одним-единственным прямоугольником. Например, элементу select соответствуют три визуальных объекта: один для области отображения, другой для раскрывающегося списка, третий для кнопки. Кроме того, если текст не вмещается на одну строку и разбивается на фрагменты, новые строки добавляются как самостоятельные объекты отображения.
<br>
Еще одним примером, где используется несколько объектов отображения, является некорректно написанный код HTML. Согласно спецификации CSS, строчный элемент может содержать либо только блочные, либо только строчные элементы. Если же содержание смешанное, то в качестве оболочки для строчных объектов создаются анонимные блочные объекты.
</p>
<p>
Некоторым объектам отображения соответствует узел DOM, но их положения в дереве не совпадают. Плавающие элементы и элементы с абсолютными координатами исключаются из общего процесса, помещаются в отдельную часть дерева и затем отображаются в стандартном фрейме, хотя на самом деле должны отображаться во фрейме-заполнителе. 
</p>

<a id="rendertree"></a>

  <figure>
      <img src="image025.png" width="731" height="396" >
    <figcaption><span>Рисунок </span>. Дерево отображения и соответствующее ему дерево DOM (<a href="#3_1">3.1</a>). Viewport (область просмотра) – это главный контейнер. В WebKit он представлен объектом RenderView.</figcaption>
  </figure>



<h5 id="The_flow_of_constructing_the_tree">Процесс построения дерева</h5>
<p>
В Firefox визуальное представление регистрируется как слушатель обновлений DOM. Создание фреймов делегируется конструктору <code>FrameConstructor</code>, который определяет стили (см. <a href="#style">Вычисление стилей</a>) и создает фрейм.
</p>
<p>
В WebKit процесс определения стиля и создания объекта отображения называется совмещением (attachment). Каждый узел DOM имеет метод attach. Совмещение выполняется синхронно; при добавлении нового узла в дерево DOM для него вызывается метод attach.
<p>
В результате обработки тегов html и body создается корневой объект дерева отображения. В спецификации CSS он называется контейнером – блоком верхнего уровня, в котором содержатся все остальные блоки. Его размеры формируют область просмотра, то есть часть окна браузера, в которой будет показано содержание. В Firefox она называется <code>ViewPortFrame</code>, а в WebKit – <code>RenderView</code>. Это объект отображения, на который указывает документ. Остальное дерево строится посредством добавления в него узлов DOM.
</p>
<p>
Подробные сведения о модели обработки приведены в <a href="http://www.w3.org/TR/CSS21/intro.html#processing-model">спецификации CSS2</a>.
</p>


<h4 id="Style_Computation">Вычисление стилей</h4>
<p>
Чтобы построить дерево отображения, необходимо рассчитать визуальные свойства каждого объекта. Для этого вычисляются свойства стиля каждого элемента.
</p>
<p>
Стиль определяется различными таблицами стилей, строчными элементами style и визуальными свойствами в документе HTML (такими как bgcolor). Последние переводятся в свойства CSS.
</p>
<p>
Таблицы стилей могут быть предоставлены браузером, разработчиком веб-страницы или пользователем, который может выбрать в браузере предпочитаемый стиль (например, в Firefox это можно сделать, поместив таблицу стилей в папку Firefox Profile).
</p>
<p>
С вычислением стилей связан ряд сложностей.
<ol>
<li><a id="issue1">Данные стилей</a> содержат множество свойств и бывают очень объемны, что может вести к проблемам с памятью.</li>
<li>
<p><a id="issue2">Поиск</a> подходящих правил для каждого элемента может замедлить работу, если код не оптимизирован. Если подставлять к каждому элементу все правила по очереди, это заметно отразится на производительности. Селекторы могут иметь сложную структуру, поэтому даже если определенная последовательность правил сначала покажется подходящей, в ходе анализа может оказаться, что это не так, и придется пробовать другой вариант.
</p>
<p>Вот пример сложного селектора:</p>

<pre class="prettyprint">
div div div div{
  ...
}
</pre>
В данном случае правила необходимо применить к элементу <code>&lt;div&gt;</code>, являющемуся потомком трех других элементов div. Предположим, нам требуется проверить, подходит ли определенное правило для данного элемента <code>&lt;div&gt;</code>. Мы выбираем в дереве некую последовательность правил для проверки. Может оказаться, что мы проверим почти целое дерево, а в итоге обнаружим, что элементов div всего два и, следовательно, правило не применимо. Придется пробовать другую последовательность.
</li>
<li><a id="issue3">Применение</a> правил подразумевает определение иерархии для достаточно сложных перекрывающихся правил.</li>
</ol>
Как браузеры справляются с этой задачей?

<h5 id="Sharing_style_data">Совместное использование информации о стилях</h5>
<p>
Узлы в WebKit соответствуют объектам RenderStyle, которые в ряде случаев могут одновременно использоваться и другими узлами. Это возможно, если узлы расположены на одном уровне и соблюдены все перечисленные ниже условия.
<ol>
<li>Все элементы отвечают одному состоянию мыши (например, :hover).</li>
<li> Ни для одного из элементов не прописано свойство id.</li>
<li> Названия тегов одинаковы.</li>
<li> Атрибуты классов одинаковы.</li>
<li> Отображаемые атрибуты одинаковы.</li>
<li> Состояния ссылок одинаковы.</li>
<li> Состояния фокуса ввода одинаковы.</li>
<li> Ни для каких элементов селекторы не совпадают таким образом, чтобы использовался селектор атрибута, находящийся в любом месте внутри селектора.</li>
<li> Для элементов не заданы атрибуты строчных объектов style.</li>
<li>Отсутствуют селекторы того же уровня. WebCore при обнаружении селектора того же уровня вызывает оператор switch и запрещает совместное использование стилей во всем документе. Это относится к селекторам +, :first-child и :last-child.</li>
</ol>

<h5 id="Firefox_rule_tree">Дерево правил Firefox</h5>
<p>
Чтобы упростить вычисление стилей, в Firefox используются две дополнительных структуры: дерево правил и дерево контекстов стилей. В WebKit также есть объекты стилей, однако они не сохраняются в специальном дереве. Вместо этого узлы DOM указывают на соответствующие стили.

</p>

<figure>
  <img src="image035.png" width="640" height="407" />
  <figcaption><span>Рисунок </span>. Дерево контекстов стилей Firefox (<a href="#2_2">2.2</a>).</figcaption>
</figure>


<p>
В контекстах стилей содержатся их конечные значения. Они вычисляются путем применения всех соответствующих правил в нужном порядке и перевода логических значений в абсолютные. Например, если логическое значение задано в процентах от ширины экрана, оно будет переведено в абсолютные единицы. Благодаря дереву правил узлы могут совместно использовать уже рассчитанные значения, а не вычислять их снова. Кроме того, это экономит место.
</p>

<p>
Все подходящие правила сохраняются в дереве. Узлы, расположенные в нижней части последовательности, имеют более высокий приоритет. Дерево содержит все обнаруженные последовательности подходящих правил. Их сохранение не требует особых ресурсов. Дерево не рассчитывается для каждого узла. Вместо этого, если требуется вычислить данные о стиле узла, к дереву добавляются уже обработанные последовательности.
</p>
<p>
Последовательности правил в дереве напоминают слова лексикона. Предположим, мы уже рассчитали вот такое дерево правил:

<figure>
  <img src="tree.png" width="400" height="261" alt="" title="" border="0" align=""  />
</figure>

Далее представим, что нам требуется подобрать правила для другого элемента в дереве контента и применить их в порядке B – E – I. Эта последовательность уже присутствует в дереве, так как ранее мы рассчитывали последовательность A – B – E – I – L. Это значительно упрощает нашу текущую задачу.
</p>
<p>
Рассмотрим подробнее, за счет чего это происходит.
</p>
<h5 id="Division_into_structs">Разделение на структуры</h5>
<p>
Контексты стилей делятся на структуры. Структуры содержат информацию о стилях для той или иной категории (например, для цвета или рамки). Свойства структуры могут быть наследуемыми или ненаследуемыми. Наследуемыми называются свойства, полученные от родительского элемента (кроме случаев, когда они определены элементом самостоятельно). Ненаследуемые свойства используют значения по умолчанию (если они не определены).
</p>
<p>
В дереве сохраняются целые структуры (включая уже вычисленные конечные значения). Смысл в том, что если узел нижнего уровня не определяет структуру, можно воспользоваться кэшированной структурой, сохраненной в одном из узлов верхних уровней.
</p>
<h5 id="Computing_the_style_contexts_using_the_rule_tree">Расчет контекстов стилей с помощью дерева правил</h5>
<p>
Прежде чем вычислять контексты стилей для отдельных элементов, необходимо рассчитать в дереве правил новую последовательность (или воспользоваться одной из существующих). После этого можно применить правила из последовательности, чтобы заполнить структуры в новом контексте стиля. Начнем с нижнего узла, так как он имеет самый высокий приоритет (обычно это наиболее специфичный селектор), и будем двигаться по дереву вверх, пока не заполним структуру. Если этот узел не позволяет определить структуру, у нас есть возможность оптимизировать задачу. Мы будем двигаться по дереву вверх, пока не найдем узел, который полностью определяет ее, и установим ссылку на него. Это идеальное решение: так узлы могут совместно использовать всю структуру целиком, а нам не нужно выделять память для повторного расчета конечных значений.
<br>
Если мы обнаружим частичное определение, то будем двигаться по дереву вверх, пока не заполним всю структуру.
</p>
<p>
Если определение для структуры найти не удалось, существует два варианта. Если структура наследуемая, мы установим ссылку на структуру родительского элемента в <b>дереве контекстов стилей</b>. В этом случае речь также идет о совместном использовании структур. Если же структура ненаследуемая, используются значения по умолчанию.
</p>
<p>
Если самый специфичный узел содержит какие-либо значения, выполним некоторые дополнительные вычисления, чтобы получить абсолютные единицы. Результат затем сохраняется в узле дерева, чтобы его могли использовать дочерние элементы.
</p>
<p>
Если имеется элемент того же уровня, указывающий на этот узел, контекст стиля может быть предоставлен ему <b>целиком</b>.
</p>
<p>
Рассмотрим следующий код HTML:


<pre class="prettyprint">
&lt;html&gt;
  &lt;body&gt;
    &lt;div class="err" id="div1"&gt;
      &lt;p&gt;
        this is a &lt;span class="big"&gt; big error &lt;/span&gt;
        this is also a
        &lt;span class="big"&gt; very  big  error&lt;/span&gt; error
      &lt;/p&gt;
    &lt;/div&gt;
    &lt;div class="err" id="div2"&gt;another error&lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>

Определим следующие правила:
<pre class="prettyprint lang-css linenums">
div {margin:5px;color:black}
.err {color:red}
.big {margin-top:3px}
div span {margin-bottom:4px}
#div1 {color:blue}
#div2 {color:green}
</pre>
<p>
Чтобы не усложнять задачу, предположим, что нам требуется заполнить только две структуры: цвета (color) и поля (margin). Структура color содержит только один член – цвет, а структура margin содержит четыре стороны.
<br>
Полученное дерево выглядит так (надписи на узлах состоят из названия узла и номера правила, на которое они указывают):



<figure>
  <img src="image027.png" width="500" height="294" />
  <figcaption><span>Рисунок </span>. Дерево правил.</figcaption>
</figure>


<br>
Дерево контекстов стилей выглядит так (надписи на узлах состоят из названия узла и номера правила, на которое они указывают):


<figure>
  <img src="image029.png" width="400" height="305" >
  <figcaption> <span>Рисунок </span>. Дерево контекстов стилей.</figcaption>
</figure>



<p>
Предположим, мы выполняем синтаксический анализ кода HTML и добрались до второго тега &lt;div&gt;. Нам требуется создать контекст стиля для этого узла и заполнить его структуры.
<br>
Путем сопоставления правил мы обнаружим, что для тега &lt;div&gt; подходят правила 1, 2 и 6. Это означает, что в дереве уже присутствует последовательность, которую можно использовать, а нам остается лишь добавить еще один узел для правила 6 (узел F в дереве правил).
<br>
Так мы создали контекст стиля и поместили его в дерево. Новый контекст указывает на узел F в дереве правил.
</p>
<p>
Теперь заполним стилевые структуры. Начнем со структуры margin. Так как последний узел (F) не определяет ее значение, мы будем двигаться по дереву вверх, пока не обнаружим кэшированную структуру, рассчитанную при добавлении предыдущего узла. Нужная структура расположена в узле B: это узел самого верхнего уровня, в котором определяются правила отрисовки полей.
</p>
<p>
У нас уже есть определение для структуры color, поэтому мы не можем использовать кэшированную структуру. Так как структура color имеет всего один атрибут, нам не требуется искать остальные на верхних уровнях дерева. Мы вычислим конечное значение (переведем строку в формат RGB и т. д.) и сохраним рассчитанную структуру в этом узле.
</p>
<p>
Работать со вторым элементом &lt;span&gt; еще проще. Мы сопоставим его с правилами и обнаружим, что он указывает на правило G, как и предыдущий элемент span. Так как два элемента одинакового уровня указывают на один и тот же узел, они могут одновременно использовать целый контекст стиля: достаточно установить ссылку на контекст предыдущего элемента span.
</p>
<p>
Если структура содержит правила, унаследованные от родительского элемента, в дереве контекстов выполняется кэширование (свойство color является наследуемым, однако Firefox обрабатывает его как ненаследуемое и сохраняет в дереве правил).
<br>
Добавим в абзац правила отображения шрифтов:
<pre class="prettyprint">
p {font-family:Verdana;font size:10px;font-weight:bold}
</pre>
Элемент p, являющийся дочерним по отношению к div в дереве контекстов, может использовать для определения шрифтов соответствующую структуру своего родителя, если для этого элемента p не заданы собственные правила отображения шрифтов.
</p>
<p>
В WebKit, где нет дерева правил, совпадающие объявления обрабатываются четыре раза. Сначала применяются свойства с высоким приоритетом без пометки !important (те, которые необходимо применить в начале, так как от них зависят остальные свойства, такие как display), затем свойства с высоким приоритетом и с пометкой !important, затем свойства с обычным приоритетом без пометки !important, и, наконец, свойства с обычным приоритетом и с пометкой !important. Таким образом, если свойство вычисляется несколько раз, конечный результат выбирается согласно приоритету. Последняя группа имеет наивысший приоритет.
<br>
</p>
<p>
Итак, возможность совместного использования объектов style (целиком или только отдельных структур) решает проблемы <a href="#issue1">№1</a> и <a href="#issue3">№3</a>. Дерево правил Firefox также позволяет применять свойства в нужном порядке.
</p>
<h5 id="Manipulating_the_rules_for_an_easy_match">Классификация правил для упрощения сопоставления</h5>
<p>
Правила стилей извлекаются из нескольких источников.
<ul>
<li>Правила CSS, определенные во внешних таблицах стилей или в элементах style:
<pre class="prettyprint">
p {color:blue}
</pre>
</li>
<li>Атрибуты строчных объектов style:
<pre class="prettyprint">
&lt;p style="color:blue" /&gt;
</pre>
</li>
<li>Визуальные атрибуты HTML (сопоставляются с подходящими правилами стилей):
<pre class="prettyprint">
&lt;p bgcolor="blue" /&gt;
</pre>
</li>
</ul>
<p>
Последние два источника легко сопоставить с элементом, так как он содержит атрибуты объекта style и при сопоставлении атрибутов HTML может служить ключом.
</p>
<p>
Как уже упоминалось (см. <a href="#issue2">проблему №2</a>), сопоставление правил CSS не так однозначно. Чтобы упростить задачу, правила классифицируются.
</p><p>
После синтаксического анализа таблицы стилей каждое правило добавляется в одну или в несколько хэш-карт в зависимости от селектора. Существуют карты, организованные по идентификатору, названию класса или тега, а также общие карты для всех остальных случаев. Если селектором является идентификатор, правило добавляется в карту идентификаторов, если класс, то в карту классов и т. д.
<br>
Такая классификация упрощает поиск подходящих правил. Нам не приходится проверять все объявления: достаточно извлечь из карты подходящие правила. Такая классификации позволяет сразу отбросить более 95% правил, что ускоряет и упрощает процесс сопоставления (<a href="#4_1">4.1</a>).
</p>
<p>
Рассмотрим пример со следующими правилами стилей:
<pre class="prettyprint">
p.error {color:red}
#messageDiv {height:50px}
div {margin:5px}
</pre>
Первое правило будет помещено в карту классов, второе – в карту идентификаторов, а третье – в карту тегов.
<br>
Рассмотрим следующий код HTML:
<pre class="prettyprint">
&lt;p class="error">an error occurred &lt;/p>
&lt;div id=" messageDiv">this is a message&lt;/div&gt;
</pre>
</p>
<p>
Сначала найдем правила для элемента p. В карте классов содержится ключ error, по которому находим правило p.error. Правила, соответствующие элементу div, содержатся в карте идентификаторов (по ключу id) и в карте тегов. Осталось только определить, какие из правил, найденных по ключам, являются подходящими.
<br>
Предположим, правило для элемента div таково:
<pre class="prettyprint">
table div {margin:5px}
</pre>
Мы в любом случае извлекли бы его из карты тегов, так как ключом является крайний правый селектор, однако оно не подошло бы для этого элемента div, потому что для него не существует родительской таблицы.
</P>
<P>
Такая оптимизация используется и в WebKit, и в Firefox.
</p>
<h5 id="Applying_the_rules_in_the_correct_cascade_order">Применение правил в порядке приоритета</h5>
<p>
Свойства объекта style отвечают всем визуальным атрибутам (всем атрибутам CSS, но на более универсальном уровне). Если свойство не определяется ни одним из подходящих правил, в некоторых случаях оно может быть унаследовано от родительского объекта style. В других случаях используется значение по умолчанию.
</p>
<p>
Сложности начинаются, если существует более одного определения, и тогда, чтобы разрешить конфликт, требуется установить порядок приоритета.
<h5 id="Style_sheet_cascade_order">Порядок приоритета таблиц стилей</h5>
Объявление свойства объекта style может содержаться сразу в нескольких таблицах стилей, иногда по нескольку раз в одной таблице. В таком случае очень важно установить верный порядок применения правил. Такой порядок называется каскадным. В спецификации CSS2 указан следующий порядок приоритета (по возрастанию).
<ol>
  <li>Объявления браузера</li>
  <li>Обычные объявления пользователя</li>
  <li>Обычные объявления автора</li>
  <li>Важные объявления автора</li>
  <li>Важные объявления пользователя</li>
</ol>
</p>
<p>
Объявления браузера имеют самый низкий приоритет, а объявления пользователя важнее объявлений автора, только если имеют пометку !important. Объявления с одинаковым приоритетом сортируются по <a href="#Specificity">степени специфичности</a>, а затем по порядку, в котором были определены. Визуальные атрибуты HTML переводятся в соответствующие объявления CSS и обрабатываются как правила автора с низким приоритетом.
</p>
<h5 id="Specificity">Специфичность</h5>
<p>
Специфичность селектора определена в <a href="http://www.w3.org/TR/CSS2/cascade.html#specificity">спецификации CSS2</a> описанным ниже образом.
<ul>
    <li>Если объявление содержится в атрибуте style, а не в правиле с селектором, выбирается значение 1, в противном случае – 0 (= a).</li>
    <li>Количество атрибутов ID внутри селектора (= b). </li>
    <li>Количество других атрибутов и псевдоклассов внутри селектора (= c). </li>
    <li>Количество названий элементов и псевдоэлементов внутри селектора (= d). </li>
</ul>
Объединение этих значений в последовательность a-b-c-d (в системе счисления с большим основанием) и определяет специфичность.
</p>
<p>
Основание системы счисления определяется самым большим числом в любой из категорий.
<br>
Например, если a=14, можно использовать шестнадцатеричную систему. Если a=17 (что маловероятно), потребуется система счисления по основанию 17. Такая ситуация может возникнуть, если имеется селектор такого типа: html body div div p... Но вряд ли внутри селектора будет 17 тегов.
</p>
<p>
Ниже приведено несколько примеров.
<pre class="prettyprint">
 *             {}  /* a=0 b=0 c=0 d=0 -> specificity = 0,0,0,0 */
 li            {}  /* a=0 b=0 c=0 d=1 -> specificity = 0,0,0,1 */
 li:first-line {}  /* a=0 b=0 c=0 d=2 -> specificity = 0,0,0,2 */
 ul li         {}  /* a=0 b=0 c=0 d=2 -> specificity = 0,0,0,2 */
 ul ol+li      {}  /* a=0 b=0 c=0 d=3 -> specificity = 0,0,0,3 */
 h1 + *[rel=up]{}  /* a=0 b=0 c=1 d=1 -> specificity = 0,0,1,1 */
 ul ol li.red  {}  /* a=0 b=0 c=1 d=3 -> specificity = 0,0,1,3 */
 li.red.level  {}  /* a=0 b=0 c=2 d=1 -> specificity = 0,0,2,1 */
 #x34y         {}  /* a=0 b=1 c=0 d=0 -> specificity = 0,1,0,0 */
 style=""          /* a=1 b=0 c=0 d=0 -> specificity = 1,0,0,0 */
</pre>
</p>
<h5 id="Sorting_the_rules">Сортировка правил</h5>
<p>
После сопоставления правил они сортируются согласно приоритету. В WebKit для коротких списков используется сортировка простыми обменами, а для длинных – сортировка слиянием. При сортировке WebKit переопределяет для правил оператор &gt;:
<pre class="prettyprint">
static bool operator >(CSSRuleData& r1, CSSRuleData& r2)
{
    int spec1 = r1.selector()->specificity();
    int spec2 = r2.selector()->specificity();
    return (spec1 == spec2) : r1.position() > r2.position() : spec1 > spec2;
}
</pre>
</p>
<h4 id="Gradual_process">Многоэтапное применение правил</h4>
<p>
В WebKit используется специальный флаг, который указывает, загружены ли все таблицы стилей верхнего уровня (включая @imports). Если совмещение уже началось, а таблица стилей еще не загружена целиком, используются заполнители, а в документе появляются соответствующие пометки. После завершения загрузки таблицы заполнители пересчитываются.
</p>


<h3 id="Layout">Компоновка</h3>
<p>
Когда только что созданный объект отображения включается в дерево, он не имеет ни размера, ни положения. Расчет этих значений называется компоновкой (layout или reflow).
</p>
<p>
В HTML используется поточная модель компоновки, то есть в большинстве случае геометрические данные можно рассчитать за один проход. Элементы, встречающиеся в потоке позднее, не влияют на геометрию уже обработанных элементов, поэтому компоновку можно выполнять слева направо и сверху вниз. Существуют исключения: например, для компоновки таблиц HTML может потребоваться более одного цикла (<a href="#3_5">3.5</a>).
</p>
<p>
Система координат рассчитывается на основе корневого фрейма. Используются верхняя и левая координаты.
</p>
<p>
Компоновка выполняется в несколько циклов. Она начинается с корневого объекта отображения, соответствующего элементу <code>&lt;html></code> в HTML-документе. Затем обрабатывается иерархия фреймов (или отдельные ее части), и геометрическая информация рассчитывается для объектов отображения, которым она необходима.
</p>
Корневой объект отображения имеет координаты (0; 0), а его размеры соответствуют области просмотра (видимой части окна браузера).
<p>
Любой объект отображения может при необходимости вызвать метод layout или reflow для своих дочерних элементов.
</p>
<h4 id="Dirty_bit_system">Система "грязных битов"</h4>
<p>
Чтобы не выполнять перекомпоновку при каждом изменении, браузеры используют так называемую систему "грязных битов". Измененный объект отображения и его дочерние элементы помечаются как "грязные", то есть требующие перекомпоновки. 
</p>
<p>
Используется два флага: dirty и children are dirty. Флаг children are dirty означает, что перекомпоновка требуется не самому объекту отображения, а одному или нескольким из его дочерних объектов.
</p>
<h4 id="Global_and_incremental_layout">Глобальная и инкрементная компоновка</h4>
<p>
Если компоновка выполняется для всего дерева отображения, она называется глобальной. Ее могут вызывать перечисленные ниже события.
<ol>
<li>Глобальное изменение стиля, который используется во всех объектах отображения, например изменение шрифта.</li>
<li>Изменение размеров экрана.</li>
</ol>
</p>
<p>
При инкрементной компоновке изменяются только "грязные" объекты отображения (при этом может потребоваться перекомпоновка некоторых других объектов).
<br>
Инкрементная компоновка выполняется асинхронно и начинается при обнаружении "грязных" объектов отображения. Пример: после получения содержания из сети и его добавления в дерево DOM в дереве отображения появляется новый объект. 
</p>


<figure>
  <img src="reflow.png" width="326" height="341" />
  <figcaption> <span>Рисунок </span>. Инкрементная компоновка, при которой обрабатываются только "грязные" объекты отображения и их дочерние элементы (<a href="#3_6">3.6</a>).</figcaption>
</figure>

<h4 id="Asynchronous_and_Synchronous_layout">Синхронная и асинхронная компоновка</h4>
Инкрементная компоновка выполняется асинхронно. В Firefox команды инкрементной компоновки помещаются в очередь, а затем планировщик вызывает их все вместе. В WebKit выполнение инкрементной компоновки также откладывается, чтобы обработать целое дерево за один цикл и перекомпоновать все "грязные" объекты отображения.
<br>
Скрипты, запрашивающие данные о стилях, такие как offsetHeight, могут привести к синхронному выполнению инкрементной компоновки.
<br>
Глобальная компоновка обычно выполняется синхронно.
<br>
Иногда компоновка выполняется в обратном вызове после исходной компоновки, потому что меняются значения некоторых атрибутов, таких как положение прокрутки.
<h4 id="Optimizations">Оптимизация</h4>
Если компоновка вызвана событием resize или изменением положения (но не размера) объекта отображения, размеры объекта извлекаются из кэша и не рассчитываются заново.
<br>
Если меняется только часть дерева, перекомпоновка всего дерева не выполняется. Это происходит, если изменение носит локальный характер и не влияет на окружающие объекты, например при вводе текста в текстовые поля (в остальных случаях ввод каждого символа вызывает перекомпоновку всего дерева).
</p>
<h4 id="The_layout_process">Процесс компоновки</h4>
<p>
Компоновка обычно выполняется по описанной ниже схеме.
<ol>
<li>Родительский объект отображения определяет собственную ширину.
<li>Родительский объект отображения обрабатывает дочерние элементы:
  <ol>
    <li>определяет положение дочернего объекта отображения (задает его координаты x и y);</li>
    <li>вызывает компоновку дочернего элемента (если он помечен как "грязный", если выполняется глобальная перекомпоновка и т. д.), в результате чего рассчитывается его высота.</li>
  </ol>
</li>
<li>На основе суммарной высоты дочерних элементов, а также высоты полей и отступов рассчитывается высота родительского объекта отображения: она требуется его собственному родительскому объекту.</li>
<li>Биты больше не помечаются как "грязные".</li>
</ol>
</p>
<p>
В Firefox в качестве параметра компоновки используется объект nsHTMLReflowState. Помимо прочих значений, он определяет ширину родительского элемента.
<br>
В результате компоновки в Firefox создается объект nsHTMLReflowMetrics, содержащий значение высоты объекта отображения.
</p>
<h4 id="Width_calculation">Расчет ширины</h4>
<p>
Ширина объекта отображения рассчитывается на основе ширины контейнера, свойства width объекта отображения, размеров полей и рамок.
<br>
Рассмотрим, как вычисляется ширина следующего элемента div:
<pre class="prettyprint">
&lt;div style="width:30%"/&gt;
</pre>
В WebKit она будет рассчитана так (метод calcWidth класса RenderBox).
<ul>
<li>Ширина контейнера представляет собой большее из значений availableWidth и 0. В данном случае значение свойства availableWidth равно значению contentWidth, которое рассчитывается следующим образом:
<pre class="prettyprint">
clientWidth() - paddingLeft() - paddingRight()
</pre>
Значения свойств clientWidth и clientHeight соответствуют внутренним размерам объекта, исключая рамку и полосу прокрутки.
</li>
<li>Ширина элементов определяется атрибутом width объекта style. Ее абсолютное значение рассчитывается на основе процентной доли от ширины контейнера.
</li>
<li>Добавляются горизонтальные рамки и отступы.</li>
</ul>
До этого момента мы занимались расчетом предпочтительной ширины. Теперь рассчитаем ее минимальное и максимальное значение.
<br>
Если предпочтительная ширина превышает максимальную, то используется значение максимальной, а если она меньше минимальной (самого маленького неделимого объекта) – значение минимальной ширины. 
</p>
<p>
Эти данные хранятся в кэше на случай, если потребуется перекомпоновка без изменения ширины.
</p>
<p>
<h4 id="Line_Breaking">Перенос строк</h4>
<p>
Если в процессе компоновки объект отображения обнаруживает, что необходим перенос строки, компоновка останавливается, а родительскому элементу передается запрос на перенос строки. Родительский элемент создает дополнительные объекты отображения и выполняет их компоновку.
</p>
<h3 id="Painting">Отрисовка</h3>
<p>
На этапе отрисовки для каждого объекта отображения по очереди вызывается метод paint и их содержание выводится на экран. Для отрисовки используется компонент инфраструктуры пользовательского интерфейса.
<h4 id="Global_and_Incremental">Глобальная и инкрементная отрисовка</h4>
При глобальной отрисовке все дерево отрисовывается целиком, а при инкрементной – только отдельные объекты отображения, не влияющие на остальные части дерева. Измененный объект отображения помечает свой прямоугольник как недействительный. Операционная система расценивает его как "грязную" область и вызывает событие paint. Области при этом объединяются, чтобы отрисовку можно было выполнить сразу для всех. В браузере Chrome отрисовка выполняется несколько сложнее, так как объект отображения находится вне главного процесса: Chrome в некоторой степени имитирует поведение операционной системы. Компонент визуального представления прослушивает эти события и делегирует сообщение корневому объекту отображения. Все объекты дерева по очереди проверяются, пока не будет найден нужный. Затем выполняется отрисовка его самого и, как правило, его дочерних элементов.
<h4 id="The_painting_order">Порядок отрисовки</h4>
Порядок отрисовки определен в <a href="http://www.w3.org/TR/CSS21/zindex.html">спецификации CSS2</a>. Фактически он соответствует порядку помещения элементов в <a href="#stackingcontext">контексты стеков</a>. Порядок отрисовки играет важную роль, так как стеки отрисовываются задом наперед. Порядок добавления блочных объектов в стек таков:
<ol>
<li>Цвет фона</li>
<li>Фоновое изображение</li>
<li>Рамка</li>
<li>Дочерние объекты</li>
<li>Внешние границы</li>
</ol>
</p>
<h4 id="Firefox_display_list">Список отображения Firefox</h4>
В Firefox на основе анализа дерева отображения создается список отображения для отрисовываемого прямоугольника. В нем содержатся объекты отображения этого прямоугольника, расположенные в нужном порядке (сначала фон, потом рамки и т. д.). Благодаря этому для повторной отрисовки фона, фоновых изображений, рамок и т. д. достаточно пройти дерево все один раз.

<p>
В Firefox процесс оптимизирован за счет того, что элементы, которые будут скрыты (например, под непрозрачными элементами), не добавляются.
</p>
<h4 id="Webkit_rectangle_storage">Хранилище прямоугольников в WebKit</h4>
Перед повторной отрисовкой старый прямоугольник сохраняется в WebKit как растровое изображение, а затем отрисовываются только различия между старым и новым прямоугольником.

<br>

<h3 id="Dynamic_changes">Динамические изменения</h3>
При наступлении изменений браузеры стараются не выполнять лишних операций. Например, при изменении цвета одного элемента остальные не отрисовываются заново. При изменении положения элемента выполняется повторная компоновка и отрисовка его самого, его дочерних элементов и, возможно, других объектов того же уровня. При добавлении узла DOM выполняется его повторная компоновка и отрисовка. Серьезные изменения, такие как увеличение размера шрифта элемента html, ведут к очистке кэша и повторной компоновке и отрисовке целого дерева.


<h3 id="The_rendering_engines_threads">Потоки модуля отображения</h3>
Модуль отображения работает с одним потоком: в нем выполняется почти все, кроме сетевых операций. В Firefox и Safari это основной поток браузера, в Chrome – основной процесс вкладки.
<br>
Сетевые операции могут выполняться в нескольких параллельных потоках. Количество параллельных соединений ограничено и обычно составляет от 2 до 6 (например, в Firefox 3 их используется 6).
<h4 id="Event_loop">Цикл событий</h4>
Основной поток браузера представляет собой цикл событий – бесконечный цикл, который поддерживает рабочие процессы. Он ожидает отправки событий (таких как layout и paint), чтобы их обработать. Так выглядит код Firefox для основного цикла событий:
<pre class="prettyprint">
while (!mExiting)
    NS_ProcessNextEvent(thread);
</pre>


<h3 id="css">Визуальная модель CSS2</h3>
<h4 id="The_canvas">Холст</h4>
<p>
Согласно <a href="http://www.w3.org/TR/CSS21/intro.html#processing-model">спецификации CSS2</a>, под холстом (canvas) подразумевается пространство, где отображается отформатированная структура, то есть область, в которой браузер отрисовывает содержание. Сам по себе холст бесконечен, однако браузеры обычно определяют для него ширину исходя из размеров области просмотра.
</p>
<p>
Согласно <a href="http://www.w3.org/TR/CSS2/zindex.html">приложению к спецификации</a>, если холст находится внутри другого холста, то он прозрачен, а в остальных случаях окрашен в определенный браузером цвет.
</p>
<h4 id="CSS_Box_model">Модель окна в CSS</h4>
<p>
<a href="http://www.w3.org/TR/CSS2/box.html">Модель окна в CSS</a> описывает прямоугольные окна, которые создаются для элементов, содержащихся в дереве документа, и компонуются согласно модели визуального форматирования.
<br>
В каждом окне есть область для содержания (текста, картинок и т. д.) и место для необязательных отступов, рамок и полей. 


<figure>
  <img src="image046.jpg" width="509" height="348" >
  <figcaption> <span>Рисунок </span>. Модель окна в CSS2.</figcaption>
</figure>


<p>
В каждом узле создается от 0 до n таких окон.
<br>
У всех элементов есть свойство display, определяющее тип окна, которое необходимо создать. Примеры:

<pre class="prettyprint">
block  - generates a block box.
inline - generates one or more inline boxes.
none - no box is generated.
</pre>
По умолчанию окна являются строчными элементами, однако в таблицах стилей браузера могут быть заданы иные значения по умолчанию. Например, элемент div по умолчанию является блочным.
<br>
Пример таблицы стилей со значениями по умолчанию можно найти здесь: <a href="http://www.w3.org/TR/CSS2/sample.html">www.w3.org/TR/CSS2/sample.html</a>.
</p>

<h4 id="Positioning_scheme">Схема позиционирования</h4>
<p>
Существует три схемы позиционирования.
<ol>
<li>Стандартная: объект размещается в документе согласно своему положению в дереве отображения и в дереве DOM, а также своему типу и размерам окна.</li>
<li>Плавающая: объект сначала компонуется по стандартной схеме, затем смещается в крайнее правое или крайнее левое положение. </li>
<li>Абсолютная: положение объекта в дереве отображения отличается от его положения в дереве DOM.</li>
</ol>
</p>
<p>
Схема позиционирования определяется свойством position и атрибутом float.
<ul>
<li>Значения static и relative соответствуют стандартной схеме.</li>
<li>Значения absolute и fixed соответствуют абсолютной схеме.</li>
</ul>
<br>
При выборе значения static положение не задается: используется значение по умолчанию. В остальных схемах автор может указать положение с помощью значений top, bottom, left и right.
</p>
<p>
Способ компоновки окна определяется следующими факторами:
<ul>
<li>Тип окна</li>
<li>Размеры окна</li>
<li>Схема позиционирования</li>
<li>Внешняя информация (размеры изображения, размер экрана)</li>
</ul>
</p>
<h4 id="Box_types">Типы окон</h4>
<p>
Блочное окно создает собственный блок прямо в окне браузера.
</p>


<figure>
  <img src="image057.png" width="150" height="127"  />
  <figcaption> <span>Рисунок </span>. Блочное окно.</figcaption>
</figure>

<p>
Строчное окно не имеет собственного блока и помещается внутрь контейнера.
</p>


<figure>
  <img src="image059.png" width="300" height="233" />
  <figcaption><span>Рисунок </span>. Строчные окна.</figcaption>
</figure>



<p>
При форматировании блочные окна размещаются друг под другом, а строчные – друг рядом с другом.
</p>


<figure>
  <img src="image061.png" width="350" height="324" />
  <figcaption><span>Рисунок </span>. Форматирование блочных и строчных окон.</figcaption>
</figure>


<p>
Строчные окна объединяются в строки. Высота строки должна быть больше или равна высоте самого высокого окна, когда окна выровнены по нижнему краю. Если ширина контейнера недостаточна, чтобы вместить все строчные окна, они переносятся на следующие строки. Типичным примером является абзац.

</p>


<figure>
  <img src="image063.png" width="400" height="277" >
  <figcaption><span>Рисунок </span>. Строки.</figcaption>
</figure>

<h3 id="Positioning">Позиционирование</h3>
<h4 id="Relative">Относительное позиционирование</h4>
<p>
Относительное позиционирование означает, что объект размещается стандартным способом, а затем смещается на нужное расстояние.
</p>

<figure>
  <img src="image065.png" width="500" height="261" />
  <figcaption><span>Рисунок </span>. Относительное позиционирование.</figcaption>
</figure>

<h4 id="Floats">Плавающие элементы</h4>
<p>
Плавающее окно смещается вправо или влево в пределах строки. Что интересно, остальное содержание обтекает его. Рассмотрим код HTML:
<pre class="prettyprint">
&lt;p&gt;
  &lt;img style="float:right" src="images/image.gif" width="100" height="100"&gt;
  Lorem ipsum dolor sit amet, consectetuer...
&lt;/p&gt;
</pre>
На веб-странице он будет выглядеть так:
</p>


<figure>
  <img src="image067.png" width="444" height="203" />
  <figcaption><span>Рисунок </span>. Плавающие элементы.</figcaption>
</figure>


<h4 id="Absolute_and_fixed">Абсолютное и фиксированное позиционирование</h4>
<p>
Компоновка элемента определена вне зависимости от стандартной схемы: элемент просто исключается из нее. Его размеры зависят от размеров контейнера. В случае фиксированного позиционирования контейнером служит область просмотра.

<figure>
  <img src="image069.png" width="500" height="343" />
  <figcaption><span>Рисунок </span>. Фиксированное позиционирование.</figcaption>
</figure>


<br>
Обратите внимание: фиксированное окно остается на месте даже при прокрутке документа!
</p>
<h3 id="Layered_representation">Многослойное представление</h3>
<p>
Эта возможность реализуется свойством z-index в CSS. Оно соответствует третьему измерению, или оси z.
</p>
<p>
Окна делятся на <a id="stackingcontext">стеки</a> (стековые контексты). В каждом стеке сначала отрисовываются элементы на заднем плане, а затем на переднем (расположенные ближе к пользователю). Если они перекрываются, элементы на заднем плане не будут видны.
<br>
Порядок стеков определяется свойством z-index. Окна со свойством z-index формируют локальный стек, а область просмотра представляет собой внешний стек.

<p>Пример:</p>

<pre class="prettyprint">
&lt;style type="text/css"&gt;
      div {
        position: absolute;
        left: 2in;
        top: 2in;
      }
&lt;/style&gt;

&lt;p&gt;
    &lt;div
         style="z-index: 3;background-color:red; width: 1in; height: 1in; "&gt;
    &lt;/div&gt;
    &lt;div
         style="z-index: 1;background-color:green;width: 2in; height: 2in;"&gt;
    &lt;/div&gt;
 &lt;/p&gt;
</pre>
На веб-странице это будет выглядеть так:
</p>


<figure>
  <img src="image071.png" width="254" height="227" />
  <figcaption><span>Рисунок </span>. Фиксированное позиционирование.</figcaption>
</figure>

<p>
Красный элемент div определен в коде раньше зеленого и в стандартной схеме был бы отрисован первым, однако значение его свойства z-index выше, поэтому он находится в стеке, который ближе к пользователю.
</p>




<h3 id="Resources">Ресурсы</h3>
<div class="autonum">
  <ol>
      <li id="1">Архитектура браузеров
          <ol>
              <li id="1_1">Grosskurth, Alan. <a href="http://grosskurth.ca/papers/browser-refarch.pdf">A Reference Architecture for Web Browsers (pdf)</a>
              <li id="1_2">Gupta, Vineet. <a href="http://www.vineetgupta.com/2010/11/how-browsers-work-part-1-architecture/">How Browsers Work - Part 1 - Architecture</a>
          </ol>

      <li id="2">Синтаксический анализ
          <ol>
              <li id="2_1">Alfred Aho, Ravi Sethi, Jeffrey Ullman. Compilers: Principles, Techniques, and Tools ("Dragon book"), Addison-Wesley, 1986
              <li id="2_2"> Rick Jelliffe. <a href="http://broadcast.oreilly.com/2009/05/the-bold-and-the-beautiful-two.html">The Bold and the Beautiful: two new drafts for HTML 5.</a>
          </ol>

      <li id="3">Firefox
          <ol>
              <li id="3_1">L. David Baron, <a href="http://dbaron.org/talks/2008-11-12-faster-html-and-css/slide-6.xhtml">Faster HTML and CSS: Layout Engine Internals for Web Developers.</a>
              <li id="3_2">L. David Baron, <a href="http://www.youtube.com/watch?v=a2_6bGNZ7bA">Faster HTML and CSS: Layout Engine Internals for Web Developers (видеозапись технической презентации в Google)</a>
              <li id="3_3">L. David Baron, <a href="http://www.mozilla.org/newlayout/doc/layout-2006-07-12/slide-6.xhtml">Mozilla's Layout Engine</a>
              <li id="3_4">L. David Baron, <a href="http://www.mozilla.org/newlayout/doc/style-system.html">Mozilla Style System Documentation</a>
              <li id="3_5">Chris Waterson, <a href="http://www.mozilla.org/newlayout/doc/reflow.html">Notes on HTML Reflow</a>
              <li id="3_6">Chris Waterson, <a href="http://www.mozilla.org/newlayout/doc/gecko-overview.htm">Gecko Overview</a>
              <li id="3_7">Alexander Larsson, <a href="https://developer.mozilla.org/en/The_life_of_an_HTML_HTTP_request">The life of an HTML HTTP request</a>
          </ol>

      <li id="4">WebKit
          <ol>
              <li id="4_1">David Hyatt, <a href="http://weblogs.mozillazine.org/hyatt/archives/cat_safari.html">Implementing CSS(part 1)</a>
              <li id="4_2">David Hyatt, <a href="http://weblogs.mozillazine.org/hyatt/WebCore/chapter2.html">An Overview of WebCore</a>
              <li id="4_3">David Hyatt, <a href="http://webkit.org/blog/114/">WebCore Rendering</a>
              <li id="4_5">David Hyatt, <a href="http://webkit.org/blog/66/the-fouc-problem/">The FOUC Problem</a>
          </ol>

      <li id="5">Спецификации W3C
          <ol>
              <li id="5_1"> <a href="http://www.w3.org/TR/html4/">Спецификации HTML 4.01</a>
              <li id="5_2"> <a href="http://dev.w3.org/html5/spec/Overview.html">Спецификации HTML5</a>
              <li id="5_3"> <a href="http://www.w3.org/TR/CSS2/">Cascading Style Sheets Level 2 Revision 1 (CSS 2.1) Specification</a>
          </ol>

      <li>Инструкции по сборке браузеров
          <ol>
              <li>Firefox. <a href="https://developer.mozilla.org/en/Build_Documentation">https://developer.mozilla.org/en/Build_Documentation</a>
              <li>WebKit. <a href="http://webkit.org/building/build.html">http://webkit.org/building/build.html</a>
          </ol>

  </ol>

  <!--  -->

</div>


</div>

<aside class="bio">

  <img align=left src="/static/images/profiles/taligarsiel.png">
  <p><a href="http://taligarsiel.com/">Тали Гарсиэль</a> работает программистом в Израиле. Она начала карьеру в 2000 году, когда познакомилась с "неудобной" уровневой моделью Netscape. Как и Ричард Фейнман, она живо интересуется, что и как работает, поэтому начала изучать внутреннее устройство браузеров и записывать результаты. Тали также опубликовала краткое <a href="http://taligarsiel.com/ClientSidePerformance.html">руководство по обработке кода на стороне клиента</a>. </p>

</aside>


<h4>Другие языки</h4>
<p>Эта страница переведена на японский. Дважды! <a href="http://cou929.nu/docs/how-browsers-work/">How Browsers Work - Behind the Scenes of Modern Web Browsers (на японском)</a>, автор <a href="https://twitter.com/#!/_kosei_">@_kosei_</a> и <a href="http://shanon-tech.blogspot.com/2011/09/web.html">ブラウザってどうやって動いてるの？（モダンWEBブラウザシーンの裏側</a>, авторы <a href="https://twitter.com/#!/ikeike443">@ikeike443</a> и <a href="https://twitter.com/#!/kiyoto01">@kiyoto01</a>. Спасибо всем!</p>

<script>
var toc = $('ol.toc');

function getReffedElem(elem){
  return $($(elem).attr('href'));
}

$(function(){

toc
  .find(' > li > a').each(function(i, elem) {
    // top level chapters get a preceding line
    $('<h5 class="tocchap"></h5>')
      .text('Chapter ' + (i + 1))
      .insertBefore(getReffedElem(elem));

    $(elem).parent().find(' > ol > li > a').each(function(j, elem2) {
      $('<span class="tocnum"></span>')
        .text( (i + 1) + '.' + (j + 1) + ' ')
        .prependTo(getReffedElem(elem2));

      $(elem2).parent().find(' > ol > li > a').each(function(k, elem3) {
        $('<span class="tocnum"></span>')
          .text( (i + 1) + '.' + (j + 1) + '.' + (k + 1) + ' ')
          .prependTo(getReffedElem(elem3));
      });
    });
  });
});


$('figcaption span').each(function(i, elem) {
  elem.setAttribute('data-count', i + 1);
});
  //console.log(elem, $(elem).attr('href'),  $('a[name="' +  )
</script>


{% endblock %}