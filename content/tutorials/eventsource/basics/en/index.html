{% extends "tutorial.html" %}

{% block headauthor %}Eric Bidelman <e.bidelman@chromium.org>{% endblock %}

{% block headtitle %}Stream Updates with Server-Sent Events{% endblock %}
{% block pagetitle %}Stream Updates with Server-Sent Events{% endblock %}
{% block pagebreadcrumb %}Server-Sent Events{% endblock %}
{% block head %}
<style>
</style>
{% endblock %}
{% block date %}November 30, 2010{% endblock %}
{% block updated %}June 16, 2011{% endblock %}

{% block browsersupport %}
<span class="browser opera supported"><span class="browser_name">Opera</span><span class="support">supported</span></span>
<span class="browser ie"><span class="browser_name">Internet Explorer</span><span class="support">unsupported</span></span>
<span class="browser safari supported"><span class="browser_name">Safari</span><span class="support">supported</span></span>
<span class="browser ff supported"><span class="browser_name">Firefox</span><span class="support">supported</span></span>
<span class="browser chrome supported"><span class="browser_name">Chrome</span><span class="support">supported</span></span>
{% endblock %}

{% block html5badge %}
<img src="/static/images/identity/html5-badge-h-connectivity.png" width="133" height="64" alt="This article is powered by HTML5 Connectivity / Realtime" title="This article is powered by HTML5 Connectivity / Realtime" />
{% endblock %}

{% block iscompatible %}
  return !!window.EventSource;
{% endblock %}

{% block content %}
  <h2 id="toc-introduction">Introduction</h2>
  <p>I wouldn't be surprised if you've stumbled on this article wondering, "What the heck are
  <a href="http://dev.w3.org/html5/eventsource/">Server-Sent Events</a> (<abbr title="Server-Sent Events">SSE</abbr>s)?" Many people
  have never heard of them, and rightfully so. Over the years, the specification has seen significant
  changes, and the API has taken somewhat of a backseat to newer, sexier communication
  protocols such as the <a href="/tutorials/#websockets">WebSocket API</a>. The idea behind
  <abbr title="Server-Sent Events">SSE</abbr>s may be familiar: a web app "subscribes" to a
  stream of updates generated by a server and, whenever a new event occurs, a notification is sent to
  the client. But to really understand Server-Sent Events, we need to understand the limitations
  of its AJAX predecessors, which includes:</p>

  <p><strong>Polling</strong> is a traditional technique used by the vast majority of AJAX applications.
  The basic idea is that the application repeatedly polls a server for data.
  If you're familiar with the HTTP protocol, you know that fetching data revolves around a request/response format.
  The client makes a request and waits for the server to respond with data. If none is available, an empty response
  is returned. So what's the big deal with polling? Extra polling creates greater HTTP overhead.</p>

  <p><strong>Long polling (Hanging GET / COMET)</strong> is a slight variation on polling.
  In long polling, if the server does not have data available, the server holds the request
  open until new data is made available. Hence, this technique is often referred to as a "Hanging GET".
  When information becomes available, the server responds, closes the connection, and the process is repeated.
  The effect is that the server is constantly responding with new data as it becomes available.
  The shortcoming is that the implementation of such a procedure typically involves hacks such
  as appending script tags to an 'infinite' iframe. We can do better than hacks!</p>

  <p>Server-Sent Events on the other hand, have been designed from the ground up to be efficient.
  When communicating using <abbr title="Server-Sent Events">SSE</abbr>s, a server can push data to your
  app whenever it wants, without the need to make an initial request. In other words,
  updates can be streamed from server to client as they happen. <abbr title="Server-Sent Events">SSE</abbr>s
  open a single unidirectional channel between server and client.</p>

  <p>The main difference between Server-Sent Events and long-polling is that <abbr title="Server-Sent Events">SSE</abbr>s
  are handled directly by the browser and the user simply has to listen for messages.</p>

  <h2 id="toc-introduction-differences">Server-Sent Events vs. WebSockets</h2>

  <p>Why would you choose Server-Sent Events over WebSockets? Good question.</p>

  <p>One reason <abbr title="Server-Sent Events">SSE</abbr>s have been kept in the shadow is because
  later APIs like <a href="/tutorials/#websockets">WebSockets</a> provide a richer protocol to perform bi-directional,
  full-duplex communication. Having a two-way channel is more attractive for things like games, messaging apps, and for
  cases where you need near real-time updates in both
  directions. However, in some scenarios <i>data doesn't need to be sent from the client</i>. You simply
  need updates from some server action. A few examples would be friends' status updates, stock tickers,
  news feeds, or other automated data push mechanisms (e.g. updating a client-side
  Web SQL Database or IndexedDB object store). If you'll need to send data to a server,
  <code>XMLHttpRequest</code> is always a friend.</p>

  <p><abbr title="Server-Sent Events">SSE</abbr>s are sent over traditional HTTP. That means they <i>do not require a special protocol or server
  implementation</i> to get working. WebSockets on the other hand, require full-duplex connections
  and new Web Socket servers to handle the protocol. In addition, Server-Sent Events  have a variety
  of features that WebSockets lack by design such as <i>automatic reconnection</i>, <i>event IDs</i>,
  and the ability to <i>send arbitrary events</i>.</p>

  <h2 id="toc-js-api">JavaScript API</h2>

  <p>To subscribe to an event stream, create an <code>EventSource</code> object and pass it the
  URL of your stream:</p>

  <pre class="prettyprint">
if (!!window.EventSource) {
  var source = new EventSource('stream.php');
} else {
  // Result to xhr polling :(
}
</pre>

  <p><strong>Note:</strong> If the URL passed to the <code>EventSource</code> constructor
  is an absolute URL, its origin (scheme, domain, port) must match that of the calling page.</p>

  <p>Next, set up a handler for the <code>message</code> event. You can optionally
  listen for <code>open</code> and <code>error</code>:</p>

  <pre class="prettyprint">
source.addEventListener('message', function(e) {
  console.log(e.data);
}, false);

source.addEventListener('open', function(e) {
  // Connection was opened.
}, false);

source.addEventListener('error', function(e) {
  if (e.readyState == EventSource.CLOSED) {
    // Connection was closed.
  }
}, false);
</pre>

  <p>When updates are pushed from the server, the <code>onmessage</code> handler fires
  and new data is be available in its <code>e.data</code> property. The magical part is
  that whenever the connection is closed, the browser will automatically reconnect to the
  source after ~3 seconds. Your server implementation can even have control over
  this reconnection timeout. See <a href="#toc-reconnection-timeout">Controlling the reconnection-timeout</a>
  in the next section.</p>

  <p>That's it. Your client is now ready to process events from <code>stream.php</code>.</p>

  <h2 id="toc-event-stream-format">Event Stream Format</h2>

  <p>Sending an event stream from the source is a matter of constructing a
  plaintext response, served with a <code>text/event-stream</code> Content-Type,
  that follows the <abbr title="Server-Sent Events">SSE</abbr> format.
  In its basic form, the response should contain a "<code>data:</code>" line, followed by your message, followed by
  two "\n" characters to end the stream:</p>

  <pre class="prettyprint">data: My message\n\n</pre>

  <h3 id="toc-multiline-data">Multiline Data</h3>

  <p>If your message is longer, you can break it up by using multiple "<code>data:</code>" lines. Two
  or more consecutive lines beginning with "<code>data:</code>" will be treated as a
  single piece of data, meaning only one <code>message</code> event will be fired.
  Each line should end in a single "\n" (except for the last, which should end with two).
  The result passed to your <code>message</code> handler is a single string concatenated by newline characters. For example:</p>

  <pre class="prettyprint">
data: first line\n
data: second line\n\n</pre>

  <p>will produce "first line\nsecond line" in <code>e.data</code>. One could then use <code>e.data.split('\n').join('')</code>
  to reconstruct the message sans "\n" characters.</p>

  <h3 id="toc-json-data">Send JSON Data</h3>

  <p>Using multiple lines makes it easy to send JSON without breaking syntax:</p>

    <pre class="prettyprint">
data: {\n
data: "msg": "hello world",\n
data: "id": 12345\n
data: }\n\n</pre>

    <p>and possible client-side code to handle that stream:</p>

    <pre class="prettyprint">
source.addEventListener('message', function(e) {
  var data = JSON.parse(e.data);
  console.log(data.id, data.msg);
}, false);
</pre>

    <h3 id="toc-lastevent-id">Associating an ID with an Event</h3>

    <p>You can send a unique id with an stream event by including a line starting with "<code>id:</code>":</p>

    <pre class="prettyprint">
id: 12345\n
data: GOOG\n
data: 556\n\n</pre>

    <p>Setting an ID lets the browser keep track of the last event fired so that if, the
    connection to the server is dropped, a special HTTP header (<code>Last-Event-ID</code>) is
    set with the new request. This lets the browser determine which event is appropriate to fire.
    The <code>message</code> event contains a <code>e.lastEventId</code> property.</p>

    <h3 id="toc-reconnection-timeout">Controlling the Reconnection-timeout</h3>

    <p>The browser attempts to reconnect to the source roughly 3 seconds
    after each connection is closed. You can change that timeout by including a
    line beginning with "<code>retry:</code>", followed by the number of milliseconds
    to wait before trying to reconnect.</p>

    <p>The following example attempts a reconnect after 10 seconds:</p>

    <pre class="prettyprint">
retry: 10000\n
data: hello world\n\n</pre>

   <h3 id="toc-eventname">Specifying an event name</h3>

   <p>A single event source can generate different types events by including an
   event name. If a line beginning with "<code>event:</code>" is present,
   followed by a unique name for the event, the event is associated with that name.
   On the client, an event listener can be setup to listen to that particular event. </p>

   <p>For example, the following server output sends three types of events,
    a generic 'message' event, 'userlogon', and 'update' event:</p>

   <pre class="prettyprint">
data: {"msg": "First message"}\n\n
event: userlogon\n
data: {"username": "John123"}\n\n
event: update\n
data: {"username": "John123", "emotion": "happy"}\n\n
</pre>

    <p>With event listeners setup on the client:</p>

    <pre class="prettyprint">
source.addEventListener('message', function(e) {
  var data = JSON.parse(e.data);
  console.log(data.msg);
}, false);

source.addEventListener('userlogon', function(e) {
  var data = JSON.parse(e.data);
  console.log('User login:' + data.username);
}, false);

source.addEventListener('update', function(e) {
  var data = JSON.parse(e.data);
  console.log(data.username + ' is now ' + data.emotion);
}, false);
</pre>

  <h2 id="toc-server-code">Server Examples</h2>

  <p>A simple server implementation in PHP:</p>

<pre class="prettyprint">
&lt;?php
header('Content-Type: text/event-stream');
header('Cache-Control: no-cache'); // recommended to prevent caching of event data.

/**
 * Constructs the SSE data format and flushes that data to the client.
 *
 * @param string $id Timestamp/id of this connection.
 * @param string $msg Line of text that should be transmitted.
 */
function sendMsg($id, $msg) {
  echo "id: $id" . PHP_EOL;
  echo "data: $msg" . PHP_EOL;
  echo PHP_EOL;
  ob_flush();
  flush();
}

$serverTime = time();

sendMsg($serverTime, 'server time: ' . date("h:i:s", time()));
</pre>

  <p><a href="demo/sse.php">Download the code</a></p>

  <p>Here's a similiar implementation using <a href="http://nodejs.org">Node JS</a>:</p>

  <pre class="prettyprint">
var http = require('http');
var sys = require('sys');
var fs = require('fs');

http.createServer(function(req, res) {
  //debugHeaders(req);

  if (req.headers.accept && req.headers.accept == 'text/event-stream') {
    if (req.url == '/events') {
      sendSSE(req, res);
    } else {
      res.writeHead(404);
      res.end();
    }
  } else {
    res.writeHead(200, {'Content-Type': 'text/html'});
    res.write(fs.readFileSync(__dirname + '/sse-node.html'));
    res.end();
  }
}).listen(8000);

function sendSSE(req, res) {
  res.writeHead(200, {
    'Content-Type': 'text/event-stream',
    'Cache-Control': 'no-cache',
    'Connection': 'keep-alive'
  });

  var id = (new Date()).toLocaleTimeString();

  // Sends a SSE every 5 seconds on a single connection.
  setInterval(function() {
    constructSSE(res, id, (new Date()).toLocaleTimeString());
  }, 5000);

  constructSSE(res, id, (new Date()).toLocaleTimeString());
}

function constructSSE(res, id, data) {
  res.write('id: ' + id + '\n');
  res.write("data: " + data + '\n\n');
}

function debugHeaders(req) {
  sys.puts('URL: ' + req.url);
  for (var key in req.headers) {
    sys.puts(key + ': ' + req.headers[key]);
  }
  sys.puts('\n\n');
}
</pre>

  <p><a href="demo/node-sse.js">Download the code</a></p>

  <h4>sse-node.html:</h4>
  <pre class="prettyprint">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot; /&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;script&gt;
    var source = new EventSource('/events');
    source.onmessage = function(e) {
      document.body.innerHTML += e.data + '&lt;br&gt;';
    };
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>

  <h2 id="toc-canceling">Cancel an Event Stream</h2>

  <p>Normally, the browser auto-reconnects to the event source when the connection
  is closed, but that behavior can be canceled from either the client or server.</p>

  <p>To cancel a stream from the client, simply call:</p>

  <pre class="prettyprint">source.close();</pre>

  <p>To cancel a stream from the server, respond with a non "<code>text/event-stream</code>"
  <code>Content-Type</code> or return an HTTP status other than <code>200 OK</code>
  (e.g. <code>404 Not Found</code>).</p>

  <p>Both methods will prevent the browser from re-establishing the connection.</p>

  <h2 id="toc-security">A Word on Security</h2>

  <p>From the WHATWG's section on <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#authors">Cross-document messaging security</a>:</p>

  <blockquote><q><i>Authors should check the origin attribute to ensure that messages are only accepted from domains that
  they expect to receive messages from. Otherwise, bugs in the author's message handling code could
  be exploited by hostile sites.</i></q></blockquote>

  <p>So, as an extra level of precaution, be sure to verify <code>e.origin</code> in
  your <code>message</code> handler matches your app's origin:</p>

  <pre class="prettyprint">
source.addEventListener('message', function(e) {
  if (e.origin != 'http://example.com') {
    alert('Origin was not http://example.com');
    return;
  }
  ...
}, false);
</pre>

  <p>Another good idea is to check the integrity of the data you receive:</p>

  <blockquote><q><i>Furthermore, even after checking the origin attribute, authors should also check that the data in
  question is of the expected format....
  </i></q></blockquote>

  <h2 id="toc-demo">Demo</h2>
  
  <p>I've written a <a href="https://github.com/html5rocks/www.html5rocks.com/tree/master/content/tutorials/eventsource/basics/static/demo">demo app</a> in PHP that keeps a clock up to date form the server.</p>

  <h2 id="toc-references">References</h2>
  <ul>
    <li><a href="http://dev.w3.org/html5/eventsource/">Server-Sent Events specification</a></li>
    <li><a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#authors">Cross-document messaging security</a></li>
  </ul>
{% endblock %}
