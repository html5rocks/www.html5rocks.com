{% extends "tutorial.html" %}
{% load mixin from templatefilters %}

{% block pagebreadcrumb %}{{ tut.title }}{% endblock %}

{% block head %}
<link href='/tutorials/doodles/lem/styles.css' rel='stylesheet'>
<style type="text/css">
  .rollit-full {
    width: 100%;
  }

  .button-download::before {
    content: url('/static/images/tutorials/casestudies/roll-it/ball-icon.png');
    position: absolute;
    top: 50%;
    margin-top: -8px;
    left: 10px;
  }

  #physijs-scene {
    height: 400px;
    background-color: #eee;
    position: relative;
    cursor: pointer;
  }
  #physijs-scene.no-webgl {
    height: auto;
    cursor: default;
  }

  #antialiasing {
    height: 600px;
    background-color: #eee;
    position: relative;
  }
  #antialiasing.no-webgl {
    height: auto;
  }

  #scene {
    transition: background-color 0.4s;
    -webkit-transition: background-color 0.4s;
    height: 200px;
    background-color: #eee;
    position: relative;
  }
  #scene.no-accel {
    height: auto;
  }
  #scene.roll {
    background-color: #ffcf49;
  }
  #divider {
    position: absolute;
    height: 4px;
    background: #222;
    top: 50%;
    margin-top: -2px;
    width: 100%;
  }
  #swing-up {
    position: absolute;
    background: #15b05d;
    width: 100px;
    margin-left: -50px;
    height: 0;
    bottom: 50%;
    left: 50%;
    overflow: hidden;
  }
  #swing-up span {
    position: absolute;
    top: 6px;
    display: block;
    width: 100%;
    text-align: center;
    font-weight: bold;
    color: #fff;
  }
  #swing-down {
    position: absolute;
    background: #be3d28;
    width: 100px;
    margin-left: -50px;
    height: 0;
    top: 50%;
    left: 50%;
    overflow: hidden;
  }
  #swing-down span {
    position: absolute;
    bottom: 6px;
    display: block;
    width: 100%;
    text-align: center;
    font-weight: bold;
    color: #fff;
  }

  #roll-menu {
    height: 200px;
    background-color: #eee;
    position: relative;
  }
  #ball-track {
    position: absolute;
    bottom: 0;
    left: 50%;
    margin-left: -39px;
  }
  #ball {
    position: absolute;
    bottom: 0;
    display: block;
    width: 77px;
    height: 77px;
  }
  #floor {
    position: absolute;
    background-color: #000;
    height: 5px;
    width: 100%;
    bottom: -5px;
  }


</style>
<script type="text/javascript" src="/static/demos/roll-it/js/three.min.js"></script>
<script type="text/javascript" src="/static/demos/roll-it/js/physijs/physi.js"></script>
<script type="text/javascript" src="/static/demos/roll-it/js/three-post/CopyShader.js"></script>
<script type="text/javascript" src="/static/demos/roll-it/js/three-post/EffectComposer.js"></script>
<script type="text/javascript" src="/static/demos/roll-it/js/three-post/FXAAShader.js"></script>
<script type="text/javascript" src="/static/demos/roll-it/js/three-post/RenderPass.js"></script>
<script type="text/javascript" src="/static/demos/roll-it/js/three-post/ShaderPass.js"></script>

{% endblock %}

{% block iscompatible %}

{% endblock %}

{% block html5badge %}
<!-- Your HTML5 badge (tech class icons used in the article) goes here -->
{% endblock %}

{% block share_image %}
<!--<meta itemprop="image" content="images/your_social_sharing_img.png">-->
{% endblock %}


{% block content %}

<!-- Uncomment if this is a bleeding edge feature
  <p>{% include "warning.html" %}</p>
-->
<h2 id="toc-creating-roll-it">Creating Roll It</h2>

<p><a href="http://g.co/rollit" >Roll It</a> is a <a href="http://www.chromeexperiments.com/" >Chrome Experiment</a> that reimagines a classic boardwalk game using only the browser on your phone and computer. The browser on your phone lets you aim and roll the ball with a flick of your wrist, while the browser on your computer renders the real time graphics of the Roll It alley with WebGL and Canvas. The two devices communicate via Websockets. No apps. No downloads. No tokens. All you need is a modern browser.</p>

<p>With Google Creative Lab's direction, <a href="http://www.legworkstudio.com/" >Legwork</a> developed the user experience, interfaces and game environment, then teamed up with development partner, <a href="http://modeset.com/" >Mode Set</a>, to build Roll It. Over the duration of the project there were a number of unique challenges. This article walks through some of the techniques we used, tricks we discovered and lessons we learned while bringing Roll It to fruition.</p>

<h2 id="toc-3d-workflow">3D Workflow</h2>

<p>One of the struggles in the beginning was figuring out the best way to bring 3D models from our software to a web ready file format. After creating the assets inside <a href="http://en.wikipedia.org/wiki/Cinema_4D" >Cinema 4D</a>, the models were simplified and converted to low-polygon meshes. Each mesh was given certain polygon selection tags to differentiate between parts of the object for coloring and texturing. We were then able to export as a Collada 1.5 (.dae) file and import into <a href="http://www.blender.org/" >Blender</a>, an open source 3D program, in order to make compatible files for three.js. Once we ensured our models were imported correctly, we exported the mesh as a .json file and the lighting was applied using code. Here's a more detailed look at the steps we took:</p>

<p>
<figure>
<img src="/static/images/tutorials/casestudies/roll-it/01_C4D_model.jpg" class="rollit-full">
<figcaption>Model the object inside C4D. Make sure the mesh normals are facing outwards. </figcaption>
</figure>
</p>

<p>
<figure>
<img src="/static/images/tutorials/casestudies/roll-it/02_C4D_texture.jpg" class="rollit-full">
<figcaption>Using the polygon selection tool, create selection tags of the specific areas you wish to texture. Apply materials to each of the selection tags. </figcaption>
</figure>
</p>

<p>
<figure>
<img src="/static/images/tutorials/casestudies/roll-it/03_Collada_export.jpg">
<figcaption>Export your mesh as a COLLADA 1.5 .dae file.</figcaption>
</figure>
</p>

<p>
<figure>
<img src="/static/images/tutorials/casestudies/roll-it/04_Collada_export_dialog_box.jpg">
<figcaption>Make sure "export 2D geometry" is checked. Exporting triangles is generally more widely supported across 3D environments on the code side, but has the downside of doubling your polygon count. The higher the polygon count, the more taxing the model will be on the computer's processor. So leave this checked off if you see slow performance.</figcaption>
</figure>
</p>

<p>
<figure>
<img src="/static/images/tutorials/casestudies/roll-it/05_Blender_import.jpg">
<figcaption>Import the Collada file into Blender.</figcaption>
</figure>
</p>

<p>
<figure>
<img src="/static/images/tutorials/casestudies/roll-it/06_blender_file.jpg" class="rollit-full">
<figcaption>Once imported into blender, you will see that your materials and selection tags have carried over as well.</figcaption>
</figure>
</p>

<p>
<figure>
<img src="/static/images/tutorials/casestudies/roll-it/07_Blender_materials.jpg">
<figcaption>Select your object, and adjust the materials of the object to what you prefer.</figcaption>
</figure>
</p>

<p>
<figure>
<img src="/static/images/tutorials/casestudies/roll-it/08_Blender_export.jpg">
<figcaption><a href="https://github.com/mrdoob/three.js/tree/master/utils/exporters/blender">Export the file as a three.js file</a> for webGL compatibility.</figcaption>
</figure>
</p>

<p>Here are some demo 3d files for you to play around with:</p>

<a href="/static/demos/roll-it/roll-it-3d-model-demos.zip" target="_blank" class="button-download">Download the 3D model demos</a>

<h2 id="toc-writing-the-code">Writing the code</h2>

<p>Roll It was developed with open source libraries and runs natively in modern browsers. With technologies like WebGL and WebSockets, the web is closing in on console-quality gaming and multimedia experiences. The ease and comfort in which developers can build these experiences has been taking leaps forward as more modern tools have become available for HTML development. </p>

<h3 id="toc-the-development-environment">The development environment</h3>

<p>Most of Roll It's original code was written with <a href="http://coffeescript.org/" >CoffeeScript</a> - a clean and concise language that transcompiles to well-formed and <a href="http://www.javascriptlint.com/" >linted</a> JavaScript. CoffeeScript shines for OOP development with its great inheritance model and cleaner scope handling. The CSS was written with the <a href="http://sass-lang.com/" >SASS</a> framework, which gives the developer a number of great tools to enhance and manage a project's stylesheets. Adding these systems to the build process takes a little bit of time to set up, but the payoff is definitely worth it, especially for a larger project like Roll It. We set up a simple <a href="http://rubyonrails.org/" >Ruby on Rails</a> server to auto-compile our assets during development, so all of these compilation steps became transparent.</p>

<p>Beyond creating a streamlined and comfortable coding environment, we manually optimized assets to minimize requests in order to load the site faster. We ran every image through a couple of compression programs - <a href="http://imageoptim.com/" >ImageOptim</a> and <a href="http://pngmini.com/" >ImageAlpha</a>. Each program optimizes images in their own way - lossless and lossy, respectively. With the right combination of settings, they can significantly cut down an image's file size. This not only saves bandwidth when loading external images, but once optimized, your images will translate into a much smaller base64 encoded strings for inline embedding in HTML, CSS and JavaScript. While on the subject of base64 encoding, we also embedded our <a href="http://www.google.com/fonts/specimen/Open+Sans" >Open Sans</a> .woff and .svg font files directly into the CSS using this technique, which resulted in even fewer total requests.</p>

<h3 id="toc-physics-enabled-3d-scene">The physics-enabled 3D scene</h3>

<p><a href="http://threejs.org/" >THREE.js</a> is the ubiquitous 3D JavaScript library for the web. It wraps up low-level 3D math and hardware-based WebGL optimizations that enable mere mortals to easily create well-lit and beautiful interactive 3D scenes without having to write custom shaders or perform manual matrix transformations. <a href="https://github.com/chandlerprall/Physijs" >Physijs</a> is a THREE.js-specific wrapper for a popular C++ physics library that has been translated to JavaScript. We took advantage of this library to simulate the ball rolling, jumping, and bouncing towards its destination in 3D.</p>

<p>From the start, we set out to not only make the physical experience of rolling the ball feel realistic, but also to make sure that the objects in the game felt real. This required many iterations of adjusting the overall gravity of the Physijs scene, the speed of the ball as it rolls from the player's throw, the slope of the lane's jump, and the friction and restitution (bounciness) properties of the ball and lane materials. The combination of more gravity and more speed resulted in a more realistic gaming experience.</p>

<p>The following demo explains some of the setup and interaction with a Physijs-enabled scene. If you're familiar with setting up a THREE.js scene, there are only a couple of extra steps to add physics behavior to the objects, launch the ball, and create shapes that build the game board. Make sure WebGL is enabled if you're viewing with Safari and be sure to <a href="/static/demos/roll-it/roll-it-code-demos.zip">download the code examples</a> for these demos.</p></p>

<p>
<div id="physijs-scene"></div>
</p>

<script>
  // requestAnimationFrame polyfill -----------------------------------------------------------------
  var vendors = ['webkit', 'moz'];
  for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
      window.requestAnimationFrame = window[vendors[x]+'RequestAnimationFrame'];
      window.cancelAnimationFrame = window[vendors[x]+'CancelAnimationFrame'] || window[vendors[x]+'CancelRequestAnimationFrame'];
  }


  (function(){
    // scene container element ------------------------------------------------------------------------
    var container = document.getElementById('physijs-scene');

    // THREE objects  ---------------------------------------------------------------------------------
    var camera, scene, renderer;
    var sceneW, sceneH;
    var physicsMaterial;

    // initialize the physics demo --------------------------------------------------------------------
    function init() {
      // store scene dimensions
      sceneW = container.offsetWidth;
      sceneH = container.offsetHeight;

      // build the 3d world
      buildPhysicsScene();
      buildRenderer();
      buildCamera();
      buildGround();
      buildPhysicsMaterial();
      buildCircles();
      buildBall();
      buildLights();
    }

    // build the WebGL renderer -----------------------------------------------------------------------
    var buildRenderer = function() {
      renderer = new THREE.WebGLRenderer( { antialias: true } );
      renderer.setSize( sceneW, sceneH );
      renderer.setClearColorHex(0xeeeeee);
      renderer.shadowMapEnabled = true;
      renderer.shadowMapSoft = true;
      renderer.shadowMapType = THREE.PCFShadowMap;
      renderer.shadowMapAutoUpdate = true;

      container.appendChild( renderer.domElement );
    };

    // add an ambient light and a spot light for shadowing --------------------------------------------
    var buildLights = function() {
      scene.add( new THREE.AmbientLight( 0x666666) );

      var light = new THREE.SpotLight(0xcccccc);
      light.position.set(0, 1000, 0);
      light.target.position.copy(scene.position);
      light.shadowCameraTop = -700;
      light.shadowCameraLeft = -700;
      light.shadowCameraRight = 700;
      light.shadowCameraBottom = 700;
      light.shadowCameraNear = 20;
      light.shadowCameraFar = 1400;
      light.shadowBias = -.0001;
      light.shadowMapWidth = light.shadowMapHeight = 1024;
      light.shadowDarkness = .25;
      light.castShadow = true;
      light.shadowCameraVisible = false;
      scene.add(light);
    };

    // build the THREE camera -------------------------------------------------------------------------
    var buildCamera = function() {
      camera = new THREE.PerspectiveCamera( 50, sceneW / sceneH, 1, 10000 );
      // move camera up and back, and point it down at the center of the 3d scene
      camera.position.z = 900;
      camera.position.y = 400;
      camera.lookAt(new THREE.Vector3(0,0,0));
    };

    // build the Physijs scene, which takes the place of a THREE scene --------------------------------
    var buildPhysicsScene = function() {
      // lean about Physi.js basic setup here: https://github.com/chandlerprall/Physijs/wiki/Basic-Setup
      // set the path of the web worker javascripts
      Physijs.scripts.worker = '/static/demos/roll-it/js/physijs/physijs_worker.js';
      Physijs.scripts.ammo = 'ammo.js'; // must be relative to physijs_worker.js

      // init the scene
      scene = new Physijs.Scene({reportsize: 50, fixedTimeStep: 1 / 60});
      scene.setGravity(new THREE.Vector3( 0, -800, 0 ));
    };

    // build the ground plane and rotate it to be flat ------------------------------------------------
    var buildGround = function() {
      var groundGeometry = new THREE.PlaneGeometry(1000, 1000, 10, 10);
      groundGeometry.computeFaceNormals();
      groundGeometry.computeVertexNormals();

      var groundMaterial = Physijs.createMaterial( 
        new THREE.MeshPhongMaterial({ 
          color: 0x999999, 
          wireframe: false,
          shininess: 10,
          color: 0xdddddd,
          emissive: 0x111111
        }),
        .8, // high friction
        .8 // high restitution
      );

      var ground = new Physijs.HeightfieldMesh(groundGeometry, groundMaterial, 0);
      ground.rotation.x = -Math.PI / 2;
      ground.receiveShadow = true;
      ground.castShadow = true;

      scene.add( ground );
    };

    // create a material to share between segments of the physics walls -------------------------------
    var buildPhysicsMaterial = function() {
      physicsMaterial = Physijs.createMaterial(
        new THREE.MeshLambertMaterial({
          color: 0xdddddd,
          emissive: 0x007844,
          ambient: 0x000000,
          shininess: 100,
          specular: 0xcccccc,
          shading: THREE.SmoothShading
        }), 
        .8, // high friction
        .8 // high restitution
      );
    };

    // create a physics wall of a certain size, at a certain location ---------------------------------
    var buildPhysicsWall = function(width, height, depth, x, y, z) {
      var physicsMesh, wallGeometry;
      wallGeometry = new THREE.CubeGeometry(width, height, depth);
      wallGeometry.computeFaceNormals();
      wallGeometry.computeVertexNormals();
      physicsMesh = new Physijs.BoxMesh(wallGeometry, physicsMaterial, 0);
      physicsMesh.castShadow = true;
      physicsMesh.receiveShadow = true;
      physicsMesh.position.set(x, y, z);
      return physicsMesh;
    };

    // build a cup at a specific radius, location and height ------------------------------------------
    var buildCircleWall = function(radius, arc, circleSegments, x, z, wallH) {
      var curRadians, i, segmentRadians, startRadians, wall, wallW;
      // calculate the size and circle position of each wall segment
      segmentRadians = (arc * (Math.PI * 2)) / circleSegments;
      startRadians = -Math.PI / 2;
      wallW = radius * segmentRadians;
      i = 0;
      // build the circle of walls by looping around the circle path
      while (i < circleSegments) {
        wall = buildPhysicsWall(wallW, wallH, 0.3, 0, wallH/2, 0);
        curRadians = startRadians + i * segmentRadians;
        wall.position.x = x + radius * Math.sin(curRadians);
        wall.position.z = z + radius * Math.cos(curRadians);
        wall.rotation.y = curRadians;
        scene.add(wall);
        i++;
      }
    };

    // build the circles in the 3d scene. smiley face has a partial circle ----------------------------
    var buildCircles = function() {
      buildCircleWall(60, 1, 30, -88, -20, 20);
      buildCircleWall(60, 1, 30, 88, -20, 20);
      buildCircleWall(200, 0.5, 40, 0, 80, 20);
      buildCircleWall(400, 1, 40, 0, 0, 70);
    };

    // build the ball and draw its texture with a 2d canvas -------------------------------------------
    var buildBall = function() {
      // create a canvas to draw the ball's texture
      var ballCanvas = document.createElement('canvas');
      ballCanvas.width = 64;
      ballCanvas.height = 64;
      var ballContext = ballCanvas.getContext('2d');

      // draw 2 colored halves of the 2d canvas 
      ballContext.fillStyle = "#f8ae44";
      ballContext.fillRect(0, 0, ballCanvas.width, ballCanvas.height/2);
      ballContext.fillStyle = "#ffda4e";
      ballContext.fillRect(0, ballCanvas.height/2, ballCanvas.width, ballCanvas.height/2);

      // create the THREE texture object with our canvas
      var ballTexture = new THREE.Texture( ballCanvas );
      ballTexture.needsUpdate = true;

      // create the physijs-enabled material with some decent friction & bounce properties
      var ballMaterial = Physijs.createMaterial(
        new THREE.MeshLambertMaterial({
          map: ballTexture,
          shininess: 10,
          color: 0xdddddd,
          emissive: 0x111111,
          side: THREE.FrontSide
        }), 
        .6, // mid friction
        .5 // mid restitution
      );
      ballMaterial.map.wrapS = ballMaterial.map.wrapT = THREE.RepeatWrapping;
      ballMaterial.map.repeat.set( 1, 1 );

      // create the physics-enabled sphere mesh, and start it up in the air
      ball = new Physijs.SphereMesh(
        new THREE.SphereGeometry( 30, 32, 32 ),
        ballMaterial, 
        100
      );
      ball.position.y = 500;
      ball.receiveShadow = true;
      ball.castShadow = true;
      scene.add( ball );
    };

    // update the physics engine and render every frame -----------------------------------------------
    var animate = function() {
      scene.simulate(); // run physics
      renderer.render( scene, camera); // render the scene

      // continue animating
      requestAnimationFrame( animate );
    }

    // randomly toss the ball on mouse click ----------------------------------------------------------
    var tossBall = function() {
      var xSpeed = Math.random() * 600 - 300;
      var zSpeed = Math.random() * 600 - 300;
      ball.setLinearVelocity( new THREE.Vector3(xSpeed,300,zSpeed) );
    };
    container.addEventListener('click', tossBall, false);

    // update THREE objects when window resizes -------------------------------------------------------
    var onWindowResize = function() {
      // store scene dimensions
      sceneW = container.offsetWidth;
      sceneH = container.offsetHeight;
      // update camera
      camera.aspect = sceneW / sceneH;
      camera.updateProjectionMatrix();

      // set renderer size
      renderer.setSize( sceneW, sceneH );
    }
    window.addEventListener( 'resize', onWindowResize, false );

    // kick it off ------------------------------------------------------------------------------------
    var hasWebGL = (function () { 
      // from Detector.js
      try { 
        return !! window.WebGLRenderingContext && !! document.createElement( 'canvas' ).getContext( 'experimental-webgl' ); 
      } catch( e ) { 
        return false; 
      } 
    })();

    if( hasWebGL ) {
      init();
      animate();
    } else {
      container.innerHTML = '<img src="/static/images/tutorials/casestudies/roll-it/need-computer.png" class="rollit-full">';
      container.classList.add('no-webgl');
    }
  })();
</script>

<h3 id="toc-smoothing-it-out">Smoothing it out</h3>

<p>Most modern browser and video card combinations should take advantage of native hardware-based anti-aliasing in the WebGL environment, but some won't play nice. In the case that anti-aliasing doesn't work natively, any hard and contrasted edges in the THREE.js scene will will be jagged and ugly (to our discerning eyes, at least). </p>

<p>Luckily there's a fix: through a snippet of code, we can detect whether the platform will natively support antialiasing. If it does, then we're good to go. If it doesn't, there are a series of post-processing shaders that come with THREE.js that can help us. Namely, the FXAA anti-aliasing filter. By redrawing the rendered scene every frame with this shader, we're generally left with a much smoother look to our lines and edges. See the demo below:</p>

<p>
<div id="antialiasing"></div>
</p>
<p id="anti-native">Antialiasing is working natively.</p>
<p id="anti-post">Antialiasing is <span id="en">en</span><span id="dis">dis</span>abled via the FXAA post-processing shader. <input id="post-check" type="checkbox" checked="checked" autocomplete="off"></input></p>

<script>
  (function(){
    // scene container element ------------------------------------------------------------------------
    var container = document.getElementById('antialiasing');

    // THREE objects for a basic scene ----------------------------------------------------------------
    var camera, scene, renderer;
    var geometry, material, boxSmall, boxLarge, plane;
    var sceneW, sceneH;

    // antialiasing support
    var renderScene, effectFXAA, composer, dpr;
    var nativeAntialiasSupport = false;
    var isNativeAntialiasing = false;
    var isPostProcessing = true;

    // build and animate the THREE scene --------------------------------------------------------------
    function init() {
      // store scene dimensions
      sceneW = container.offsetWidth;
      sceneH = container.offsetHeight;

      // build camera & scene
      camera = new THREE.PerspectiveCamera( 50, sceneW / sceneH, 1, 10000 );
      camera.position.z = 2000;
      scene = new THREE.Scene();

      // add a cube
      geometry = new THREE.CubeGeometry( 400, 400, 400 );
      material = new THREE.MeshBasicMaterial( { color: 0xff0000, wireframe: true, wireframeLinewidth: 2 } );
      boxSmall = new THREE.Mesh( geometry, material );
      scene.add( boxSmall );

      // add a cube
      geometry = new THREE.CubeGeometry( 800, 800, 800 );
      material = new THREE.MeshBasicMaterial( { color: 0x0000ff, wireframe: true, wireframeLinewidth: 2 } );
      boxLarge = new THREE.Mesh( geometry, material );
      scene.add( boxLarge );

      // add a plane to help with perspective
      geometry = new THREE.PlaneGeometry( 1600, 300 );
      material = new THREE.MeshBasicMaterial( { color: 0x000000, transparent: true, opacity: 0.75 } );
      plane = new THREE.Mesh( geometry, material );
      scene.add( plane );

      // build the WebGL renderer
      renderer = new THREE.WebGLRenderer( { antialias: true } );
      renderer.setSize( sceneW, sceneH );
      renderer.setClearColorHex(0xffffff)
      container.appendChild( renderer.domElement );
    }

    // check for native platform antialias support and add the FXAA post-processing shader if needed --
    function addAntiAliasing() {
      // check for native platform antialias support
      // http://codeflow.org/entries/2013/feb/22/how-to-write-portable-webgl/#antialiasing
      isNativeAntialiasing = renderer.context.getContextAttributes().antialias;
      nativeAntialiasSupport = (renderer.context.getParameter(renderer.context.SAMPLES) == 0) ? false : true;

      if( !nativeAntialiasSupport ) {
        // tell the user that they're using post-processing antialiasing
        var nativeMessage = document.getElementById('anti-native');
        nativeMessage.parentNode.removeChild( nativeMessage );

        // handle retina screens properly
        dpr = 1;
        if (window.devicePixelRatio !== undefined) dpr = window.devicePixelRatio;

        // set up post-processing chain
        renderScene = new THREE.RenderPass( scene, camera );

        effectFXAA = new THREE.ShaderPass( THREE.FXAAShader );
        effectFXAA.uniforms[ 'resolution' ].value.set( 1 / (sceneW * dpr), 1 / (sceneH * dpr) );
        effectFXAA.renderToScreen = true;

        composer = new THREE.EffectComposer( renderer );
        composer.setSize( window.innerWidth * dpr, window.innerHeight * dpr );
        composer.addPass( renderScene );
        composer.addPass( effectFXAA );
      } else {
        // tell the user that they're using native antialiasing
        var postMessage = document.getElementById('anti-post');
        postMessage.parentNode.removeChild( postMessage );
      }
    }

    // set up checkbox to toggle post-processing (and the related message) if needed ------------------
    var buildCheckbox = function() {
      if( !nativeAntialiasSupport ) {
        document.getElementById('dis').style.display = "none";
        var checkbox = document.getElementById('post-check');
        checkbox.addEventListener('click', function(){
          isPostProcessing = !isPostProcessing;
          if( isPostProcessing ) {
            document.getElementById('en').style.display = "";
            document.getElementById('dis').style.display = "none";
          } else {
            document.getElementById('en').style.display = "none";
            document.getElementById('dis').style.display = "";
          }
        }, false);
      }
    };

    // animate boxes and render the THREE scene, with post-processing if needed -----------------------
    var animate = function() {
      // rotate shapes
      boxSmall.rotation.y += 0.002;

      boxLarge.rotation.x = Math.sin(Date.now()/1000) / 20;
      boxLarge.rotation.y += 0.001;

      plane.rotation.z = Math.sin(Date.now()/1000) / 20;

      // render the antialias post-processing of the plain old THREE scene
      if( !nativeAntialiasSupport && isPostProcessing == true ) {
        composer.render();
      } else {
        renderer.render( scene, camera );
      }

      // continue animating
      requestAnimationFrame( animate );
    }

    // update THREE objects when window resizes -------------------------------------------------------
    var onWindowResize = function() {
      // store scene dimensions
      sceneW = container.offsetWidth;
      sceneH = container.offsetHeight;
      // update camera
      camera.aspect = sceneW / sceneH;
      camera.updateProjectionMatrix();

      // update post-processing/shader size
      if( !nativeAntialiasSupport ) {
        effectFXAA.uniforms[ 'resolution' ].value.set( 1 / (sceneW * dpr), 1 / (sceneH * dpr) );
        composer.setSize( sceneW * dpr, sceneH * dpr );
      }

      // set renderer size
      renderer.setSize( sceneW, sceneH );
    }
    window.addEventListener( 'resize', onWindowResize, false );

    // kick it off ------------------------------------------------------------------------------------
    var hasWebGL = (function () { 
      // from Detector.js
      try { 
        return !! window.WebGLRenderingContext && !! document.createElement( 'canvas' ).getContext( 'experimental-webgl' ); 
      } catch( e ) { 
        return false; 
      } 
    })();

    if( hasWebGL ) {
      init();
      addAntiAliasing();
      buildCheckbox();
      animate();
    } else {
      container.innerHTML = '<img src="/static/images/tutorials/casestudies/roll-it/need-computer.png" class="rollit-full">';
      container.classList.add('no-webgl');
      var nativeMessage = document.getElementById('anti-native');
      nativeMessage.parentNode.removeChild( nativeMessage );
      var postMessage = document.getElementById('anti-post');
      postMessage.parentNode.removeChild( postMessage );
    }
  })();
</script>

<pre class="prettyprint">
// check for native platform antialias support via the THREE renderer
// from: http://codeflow.org/entries/2013/feb/22/how-to-write-portable-webgl/#antialiasing
var nativeAntialiasSupport = (renderer.context.getParameter(renderer.context.SAMPLES) == 0) ? false : true;
</pre>

<p>Here are some visual examples of <a href="/static/images/tutorials/casestudies/roll-it/antialias-native.png" target="_blank">native antialiasing</a>, <a href="/static/images/tutorials/casestudies/roll-it/antialias-shader.png" target="_blank">antialiasing via the FXAA shader</a>, and <a href="/static/images/tutorials/casestudies/roll-it/antialias-none.png" target="_blank">no antialiasing</a>. Check out the <a href="/static/demos/roll-it/roll-it-code-demos.zip">code sample download</a> to view the demo source code.</p>

<h3 id="toc-accelerometer-based-game-controls">Accelerometer-based game controls</h3>

<p>Much of Roll It's magic comes from the ball-rolling gesture that the player performs with a phone. Mobile devices have had access to the accelerometer within the browser for some time now, but as an industry we're just starting to explore motion-based gesture recognition on the web. We're somewhat limited by the data that the phone's accelerometer provides, but with a little creativity we can come up with some great new experiences.</p>

<p>Detecting Roll It's main "roll" gesture starts with tracking the 10 most recent accelerometer updates that come from the window's ‘<a href="http://www.html5rocks.com/en/tutorials/device/orientation/" >deviceorientation</a>' event. By subtracting the previous tilt value from the current tilt value, we store the angle delta between events. Then, by constantly summing up the last ten angle deltas, we can detect continuous rotation as the phone moves through space. When the phone passes a threshold of sweeping angle change, we trigger a roll. Then, by finding the largest single tilt delta in that sweep, we can estimate a speed for the ball. In Roll It, this speed is normalized using timestamps that we attach to each accelerometer update. This helps smooth out the variable speed in which accelerometer updates stream into the browser on different devices.</p>

<p>
  <div id="scene">
    <div id="swing-up"><span></span></div>
    <div id="swing-down"><span></span></div>
    <div id="divider"></div>
  </div>
</p>

<script>
  (function(){
    // grab browser vendor prefix for cross-browser css transforms ------------------------------------
    var getVendorPrefix = function( propertySuffix ) {
      var vendors = ['Moz', 'Webkit', 'O', 'ms'];
      var element = document.getElementsByTagName('div')[0];
      for( var vendor in vendors ) {
        if( element.style[ vendors[vendor] + propertySuffix ] !== undefined ) {
          return vendors[vendor];
        }
      }
      return null;
    };
    var curVendor = getVendorPrefix( 'Transform' );
    var transformProp = curVendor + 'Transform';

    // buffer object to track recent values -----------------------------------------------------------
    function ValueBuffer( numSamples ) {
      this.numSamples = numSamples;
      this.initBuffer();
    };

    // create an array of values, defaulted to zero
    ValueBuffer.prototype.initBuffer = function() {
      this.sampleIndex = 0;
      this.buffer = [];
      for( var i=0; i < this.numSamples; i++) this.buffer.push(0);
    };

    // replace the oldest value in the buffer with the current value
    ValueBuffer.prototype.update = function( value ) {
      this.sampleIndex++;
      if(this.sampleIndex == this.numSamples) this.sampleIndex = 0;
      this.buffer[this.sampleIndex] = value;
    };

    // return a sum of the buffer's values
    ValueBuffer.prototype.sum = function() {
      var sum = 0;
      for( var i=0; i < this.numSamples; i++) {
        sum += this.buffer[i];
      }
      return sum;
    };

    // return a sum of the positive values
    ValueBuffer.prototype.sumPos = function() {
      var sum = 0;
      for( var i=0; i < this.numSamples; i++) {
        if(this.buffer[i] > 0) sum += this.buffer[i];
      }
      return sum;
    };

    // return the sum of the negative values
    ValueBuffer.prototype.sumNeg = function() {
      var sum = 0;
      for( var i=0; i < this.numSamples; i++) {
        if(this.buffer[i] < 0) sum += this.buffer[i];
      }
      return sum;
    };

    // add accelerometer event listener and store values as they come in ------------------------------
    // for more info: http://www.html5rocks.com/en/tutorials/device/orientation/
    var tiltZAxis = 0;
    var tiltXAxis = 0;
    var compass = 0;
    var updateOrientation = function( e ) {
      // store accelerometer values
      tiltZAxis = parseFloat( e.gamma );
      tiltXAxis = parseFloat( e.beta );
      compass = parseFloat( e.alpha );
      // update the gesture buffer
      updateRollGesture( tiltXAxis );
    };
    window.addEventListener('deviceorientation', updateOrientation, false);

    // let the user know if there's no accelerometer data available after 1 second of listening
    // (for desktops and non-capable mobile devices).
    // This would be a good place to conditionally fall back to touch-based controls
    setTimeout(function(){
      if( (isNaN(tiltZAxis) && isNaN(tiltXAxis)) || (tiltZAxis == 0 && tiltXAxis == 0) ) {
        scene.innerHTML = '<img src="/static/images/tutorials/casestudies/roll-it/need-phone.png" class="rollit-full">';
        scene.classList.add('no-accel');
      }
    },1000);

    // store visual meter elements
    var swingUp = document.getElementById('swing-up');
    var swingUpValue = swingUp.getElementsByTagName('span')[0];
    var swingDown = document.getElementById('swing-down');
    var swingDownValue = swingDown.getElementsByTagName('span')[0];
    var scene = document.getElementById('scene');

    // keep a buffer of the last ten values of tilt data
    var tiltBuffer = new ValueBuffer(10);
    var lastTiltValue = 0;

    // update the buffer with the new tilt data
    var updateRollGesture = function( tilt ) {
      // calculate and store the tilt delta after each accelerometer update
      var tiltDelta = tilt - lastTiltValue;
      tiltBuffer.update(tiltDelta);
      lastTiltValue = tilt;

      // update meters
      swingUp.style.height = tiltBuffer.sumPos()+'px';
      swingUpValue.innerHTML = Math.round(tiltBuffer.sumPos())+'&deg;';
      swingDown.style.height = -tiltBuffer.sumNeg()+'px';
      swingDownValue.innerHTML = Math.round(tiltBuffer.sumNeg())+'&deg;';

      // show a visual indication that the user has performed the gesture
      if( tiltBuffer.sumPos() >= 100 ) { 
        scene.classList.add('roll');
      } else {
        scene.classList.remove('roll');
      }
    };
  })();
</script>

<h3 id="toc-websockets-communication">WebSockets communication</h3>

<p>Once the player rolls the ball with their phone, a message is sent from the phone to the laptop telling it to launch the ball. This "roll" message is sent via a <a href="http://en.wikipedia.org/wiki/JSON" >JSON</a> data object through a <a href="http://en.wikipedia.org/wiki/WebSocket" >WebSocket</a> connection between the two machines. The JSON data is small, mainly consisting of a message type, throw speed, and aim direction. </p>

<pre class="prettyprint">
{type: "device:ball-thrown", speed: 0.5, aim: 0.1}
</pre>

<p>All of the communication between the laptop and phone happens via small JSON messages like this. Every time the game updates its state on the desktop, or the user tilts or taps a button on the phone, a WebSocket message is transmitted between the machines. In order to keep this communication simple and easy to manage, the WebSockets messages are broadcast using a single exit point from either browser. Conversely, there's a single entry point on the receiving browser, with one WebSocket object handling all incoming and outgoing messages on both ends. When a WebSocket message is received, the JSON data is rebroadcast within the JavaScript app using jQuery's trigger() method. At this point, the incoming data behaves just like any other custom DOM event, and can be picked up and processed by any other object in the application. </p>

<pre class="prettyprint">
var websocket = new WebSocket(serverIPAddress);

// rebroadcast incoming WebSocket messages with a global event via jQuery
websocket.onmessage = function(e) {
  if (e.data) {
    var obj = JSON.parse(e.data);
    $(document).trigger(data.type, obj);
  }
};

// broadcast outgoing WebSocket messages by passing in a native .js object
var broadcast = function(obj) {
  websocket.send(JSON.stringify(obj));
};
</pre>

<p>Roll It's WebSocket servers are created on-the-fly when two devices are synced with a game code. The backend for Roll It was built on the <a href="https://cloud.google.com/products/compute-engine" >Google Compute Engine</a> and <a href="https://developers.google.com/appengine/" >App Engine</a> platform using <a href="https://code.google.com/p/go/" >Go</a>.</p>

<h3 id="toc-tilting-menu-screens">Tilting menu screens</h3>

<p>Beyond the event-driven WebSocket messages used during gameplay, the menus in Roll It are controlled by tilting the phone and tapping a button to confirm a selection. This requires a more consistent stream of tilt data transmitting from the phone to the laptop. In order to reduce bandwidth and avoid sending unnecessary updates, these messages are only sent if the device's tilt has changed by more than a couple of degrees. There's no point in sending a stream of tilt data if the phone is lying flat on a table! The rate of transmission is also throttled - no more than 15 WebSockets messages are sent per second in Roll It, even if the device is actively being tilted. </p>

<p>Once the tilt values are picked up on the computer, they're interpolated over time using <a href="http://updates.html5rocks.com/2012/05/requestAnimationFrame-API-now-with-sub-millisecond-precision" >requestAnimationFrame</a> to keep a smooth feel. The end result is a rotating menu and a ball that rolls to help indicate the user's selection. As the phone sends tilt data, these DOM elements are updated in real time by recalculating a CSS transform inside of the requestAnimationFrame loop. The menu's container simply rotates, but the ball seems to roll along the floor. To achieve this effect, we implement some basic trigonometry to relate the balls x-coordinate to its rotation. The simple equation is: rotations = x / (diameter * π)</p>

<p>
  <div id="roll-menu">
    <div id="ball-track">
      <img id="ball" width="77" height="77" src="data:image/png;base64,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" />
    </div>
    <div id="floor"></div>
  </div>
</p>

<script>
  (function(){
    // grab browser vendor prefix for cross-browser css transforms ------------------------------------
    var getVendorPrefix = function( propertySuffix ) {
      var vendors = ['Moz', 'Webkit', 'O', 'ms'];
      var element = document.getElementsByTagName('div')[0];
      for( var vendor in vendors ) {
        if( element.style[ vendors[vendor] + propertySuffix ] !== undefined ) {
          return vendors[vendor];
        }
      }
      return null;
    };
    var curVendor = getVendorPrefix( 'Transform' );
    var transformProp = curVendor + 'Transform';

    // store elements ---------------------------------------------------------------------------------
    var ball = document.getElementById('ball');
    var scene = document.getElementById('roll-menu');

    // set up ball dimensions -------------------------------------------------------------------------
    var diameter = ball.width;
    var radius = diameter / 2;
    var circumference = Math.PI * diameter;

    // ...and transform rotations
    var sceneRotation = 0;
    var ballRotation = 0;
    var numRotations = 0;

    // mouse/touch tracking ---------------------------------------------------------------------------
    var mouseX = 0;
    function mouseMoved(e) {
      var x = (e.touches) ? e.touches[0].clientX : e.clientX;
      mouseX = x - Math.round(window.innerWidth / 2);
    }
    document.addEventListener( 'mousemove', mouseMoved, false );
    document.addEventListener( 'touchmove', mouseMoved, false );

    // mobile helpers ---------------------------------------------------------------------------------
    var lockTouchScreen = function( isLocked ) {
      ( isLocked == false ) ? document.ontouchmove = null : document.ontouchmove = function(e) { e.preventDefault(); };
    };

    // lock screen for scrolling on mouse/touch of interactive scene
    scene.addEventListener( 'touchstart', function(e){
      lockTouchScreen(true);
    }, false );

    document.addEventListener( 'touchend', function(e){
      lockTouchScreen(false);
    }, false );

    // prevent image dragging
    ball.onmousedown = function(e){ return false; };

    // frame loop with RAF ----------------------------------------------------------------------------
    var render = function() {
      // rotate the scene as a fraction of mouse/touch travel
      sceneRotation = mouseX / 40;
      // rotate the ball, based on its travel distance
      numRotations = (mouseX / circumference);
      ballRotation = 360 * numRotations;

      // set the transform css on the 2 elements
      ball.style[transformProp] = 'translate3d('+ mouseX +'px, 0, 0) rotate('+ ballRotation +'deg)';
      scene.style[transformProp] = 'rotate('+ sceneRotation +'deg)';

      // keep the rendering going
      requestAnimationFrame(render);
    };
    requestAnimationFrame(render);
  })();
</script>

<h2 id="toc-wrap-up">Wrap up</h2>

<p>Roll It is a sign of the times. Between the open source projects that powered its development, the processing power of the devices on our desks and in our pockets, and the state of the web as a platform, it's a truly exciting and transformative time to be connected on the open web. Just a few years ago, much of this technology only existed in proprietary systems, unavailable to freely use and distribute. Today, complex experiences can be realized with less work and more imagination as we create and share new pieces of the puzzle every day. So, what are you waiting for? Build something great and share it with the world!</p>

<p>
<figure>
<a href="http://g.co/rollit">
<img src="/static/images/tutorials/casestudies/roll-it/roll-it-logo.png">
</a>
</figure>
</p>

<h2 id="toc-downloads">Downloads</h2>

<a href="/static/demos/roll-it/roll-it-code-demos.zip" target="_blank" class="button-download">Download the code examples</a>


{% endblock %}
