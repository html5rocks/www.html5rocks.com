{% extends "tutorial.html" %}
{% load mixin from templatefilters %}

{% block pagebreadcrumb %}{{ tut.title }}{% endblock %}

{% block head %}
<style>
.talkinghead:before{ 
  background-image:url();
  background-position:0px 0px!important;
}
.talkinghead-everyone:before {
  background-image:url();
  background-position:0px 0px!important;
}
.talkinghead-pk:before {
  background-image:url(/static/images/profiles/paulkinlan.png);
  background-size: 60px 60px;
  background-position:0px 0px!important;
}
</style>


{% endblock %}

{% block iscompatible %}
  return !!Modernizr.___COMPAT_TEST___
{% endblock %}

{% block html5badge %}
<!-- Your HTML5 badge (tech class icons used in the article) goes here -->
{% endblock %}

{% block content %}

<h2 id="toc-introduction">Building a Full Screen Mobile Experience</h2>

<blockquote class="commentary talkinghead talkinghead-everyone">
One of the best thing about native apps is that they are full-screen” - lots of people, all the time.
</blockquote>


<blockquote class="commentary talkinghead talkinghead-pk" id="compressors">
It irks me somewhat that this common perception stands.  Yes, web pages aren’t full screen they have an address bar, often a back button and some other navigational controls, but a lot of modern browsers are pretty good at getting all their junk out of the way pretty quickly.
</blockquote>

<p>We have the ability to easily make immersive full screen web sites and applications, but like anything on the web there are a couple of ways to do it.  This is especially important now that more browsers are supporting an “installed web app” experience, which is not a Full Full Screen but still considered Full Screen because there are no standard browser chrome.</p>

<h2 id="toc-getting">Getting your app or site full screen</h2>

<p>There are several ways that a user or developer can get an web app full screen.</p>
<ul>
  <li>Fake it.</li>
  <li>Request the browser to go Full Screen via a user interaction.</li>
  <li>Install the app to the home screen</li>
</ul>

<h3 id="toc-faking">Auto-hiding the address bar</h3>

<pre class="prettyprint">window.scrollTo(0,1);</pre>

<blockquote class="commentary talkinghead talkinghead-pk">
I am telling you this as a friend.  It exists, it is a thing, but it is a hack. Please don't use it.
</blockquote>

<p>This is a pretty simple method, the page loads and the browser bar is told to get out of the way.  The problem is that it is not standardised and not well supported, you also have to work around a bunch of niggles.  One such niggle is that browsers often maintain the position the user on the page when they navigate back to it, your window.scrollTo overrides this annoys the user which means you have to cater for it storing last position in localStorage, which then means that you have to manage what happens if the user is on the page using multiple windows...
</p>

<h3 id="toc-request">Requesting Full Screen</h3>

<p><a href="http://caniuse.com/#feat=fullscreen">Not all platforms are equal</a>. We don't have a full screen API on iOS, but we do on Chrome and Firefox.</p>
<p>Most applications you build will use a combination of the JS API and the CSS selectors provided by the Full Screen specification.</p>
<p>The main JS API's that you need to care about when building an app or a site that uses full screen API are:</p>

<ul>
  <li><pre>[element].requestFullscreen()</pre> (currently prefixed for both Blink and Gecko) it will take the element and make it full screen.</li>
  <li><pre>document.cancelFullscreen()</pre> (currently prefixed for both Blink and Gecko) it will cancel full screen mode.</li>
  <li><pre>document.fullscreenElement</pre> (currently prefixed for both Blink and Gecko) is used to determine if any of the elements are in full screen mode.</li>
</ul>

<blockquote class="commentary talkinghead talkinghead-pk">
You will notice that in the prefixed versions there is a lot of inconsitency between the casing of the 'S' in screen.  This is awkward, but this is the problem with specs that are inflight.
</blockquote>

<p>When your app is full-screen you no longer have the browser chrome available to you.  This changes the way that users interact with your experience, they will not have the standard navigation controls such as forwards and backwards, nor will they have their escape hatch refresh button.  It is important to cater for this scenario.  You can use some CSS selectors to help you change the style and presentation of your site when the browser enters full screen mode.</p>

<pre class="prettyprint">&lt;button id="goFS">Go full screen&lt;button> 
&lt;script>
   var goFS = document.getElementById("goFS");
   goFS.addEventListener("click", function() {
      document.body.requestFullScreen();
   }, false);
&lt;/script></pre>

<p>The above example, is a little contrived and I have hid all the complexity around the use of vendor prefixes.</p>

<blockquote class="commentary talkinghead talkinghead-pk">
Damn you vendor prefixes!
</blockquote>

<p> What it currently looks like a lot more complex. <a href="https://developer.mozilla.org/en-US/docs/Web/Guide/API/DOM/Using_full_screen_mode">Mozilla has created</a> a very useful script that you can use to toggle full screen.  As you can see, due to the vendor prefix situation it is rather complex and cumbersome compared to the specified API.  Even with a slight smoother option, it is still complex. </p> 

<pre class="prettyprint">function toggleFullScreen() {
  var doc = window.document;
  var docEl = doc.documentElement;
      
  var requestFullScreen = docEl.requestFullscreen || docEl.mozRequestFullScreen || docEl.webkitRequestFullScreen;
  var cancelFullScreen = doc.exitFullscreen || doc.mozCancelFullScreen || doc.webkitExitFullscreen;
      
  if(!doc.fullscreenElement && !doc.mozFullScreenElement && !doc.webkitFullscreenElement) { 
    requestFullScreen.call(docEl);
  }
  else {
    cancelFullScreen.call(doc);  
  }
}</pre>

<p>We web developers hate complexity.  A nice high-level abstract API you can use is <a href="http://sindresorhus.com/screenfull.js"/>Sindre Sorhus'</a> "<a href="https://github.com/sindresorhus/screenfull.js">Screenfull.js</a>  module which unifies the two slightly different JS API's and vendor prefixes into one consistent API.</p>

<h3 id="toc-launch">Launching a page Full Screen</h3>

<p>Launching a full screen Web page when the user navigates to it is not possible.  Browser vendors are very aware that a full screen experience on every page load is a huge annoyance, therefore a user gesture is required to enter full screen.  Vendors do allow users to “install” apps though, and the act of installing is a signal to the Operating system that the user wants to launch as an app on the platform.</p>

<p>Across the major Mobile platforms it is pretty easy to implement using either meta tags, or manifest files as follows. </p>

<h4>iOS</h4>
<p>Ever since the launch of the iPhone, users have been able to install Web Apps to the home screen and have them launch as full-screen web apps.  </p>

<pre class="prettyprint">&lt;meta name="apple-mobile-web-app-capable" content="yes"></pre>

<p><a href="https://developer.apple.com/library/safari/documentation/AppleApplications/Reference/SafariHTMLRef/Articles/MetaTags.html">From Apple</a>:</p>
<blockquote>If content is set to yes, the web application runs in full-screen mode; otherwise, it does not. The default behavior is to use Safari to display web content.
You can determine whether a webpage is displayed in full-screen mode using the window.navigator.standalone read-only Boolean JavaScript property.
</blockquote>

<h4>Chrome for Android</h4>
<p>The Chrome team has recently implemented a feature that tells the browser to launch the page full-screen when the user has added it to the home screen.  It is similar to the iOS Safari model.</p>

<pre class="prettyprint">&lt;meta name="mobile-web-app-capable" content="yes"></pre>

<p><a href="https://developers.google.com/chrome/mobile/docs/installtohomescreen">From Chrome</a>:</p>
<blockquote>You can set up your web app to have an application shortcut icon added to a device's homescreen, and have the app launch in full-screen "app mode" using Chrome for Android’s "Add to homescreen" menu item.</blockquote>

<h4>Firefox OS</h4>
<p>Firefox OS has implemented a installable web app and packaged app model for developers to create apps for the user's phone.  This model is a little more complex, but it fits in to a wider strategy of installable apps.  The developer has to define a manifest for the app that Firefox OS will parse at install time.</p>

<p><a href="https://developer.mozilla.org/en-US/Apps/Developing/Manifest#fullscreen">From Mozilla</a>:</p>
<pre class="prettyprint">{
  "name": "My App",
  "description": "My elevator pitch goes here",
  "launch_path": "/",
  "icons": {
    "128": "/img/icon-128.png"
  },
  <b>"fullscreen": true</b>
}</pre>

<h2 id="toc-useful">Interaction Guidelines</h2>
<h3 id="toc-dontrely">Don't rely on navigation controls</h3>
<p>iOS and Firefox OS don't have a hardware back button, you must ensure that users can navigate to their previous state.  There is also no refresh gesture that is directly accessible.</p>

<p>You can detect if you are running in a full screen mode or an installed mode easily on all the major platforms.</p>

<h4>iOS</h4>
<pre class="prettyprint">if(window.navigator.standalone == true) {
  // My app is installed and therefore full screen
}</pre>

<h4>Chrome for Android</h4>
<p>When launching as an installed app, Chrome is not running in true full screen experience so `document.fullscreenElement` will return null and the CSS selectors will not work.  Chrome also does not have the a comparable API to iOS (navigator.standalone).</p>

<p>When the user requests Full Screen via your site, the standard full screen API's are available.</p>

<pre class="prettyprint">selector:-webkit-full-screen {
  display: block;
}</pre>

<h4>Firefox</h4>
<pre class="prettyprint">selector:-moz-full-screen {
  display: block;
}</pre>

<p>Using these patterns you can detect when full-screen is running and adapt your user interface appropriately:</p>

<ul>
  <li>Provide a link to get back to the start page</li>
  <li>Provide a mechanism to close dialogs or travel backwards in scenarios</li>
</ul>

<h3 id="toc-keepuserin">Keep the user in the full screen experience</h3>

<p>The full screen API can be a little finicky sometimes, browsers don't want to lock users in a full screen page so they will break out of full screen as soon as they possibly can.  This means you can't build a full screen website that spans multiple pages because:</p>

<ul>
  <li>Changing the URL programmatically by using window.location = "http://example.com" breaks out of full screen</li>
  <li>A user clicking on an external link inside your page will exit full screen</li>
  <li>Changing the URL via the navigator.pushState API will also break out of the full screen experience.</li>
</ul>

<p>You have two options:</p>

<ol>
  <li>Use the installable web app mechanisms to go full screen</li>
  <li>Manage your UI and app state using the # fragment.</li>
</ol>

<p>By using the #syntax to update the url (window.location = "#somestate"), and listening to the window.onhashchange event you can use the browser's own history stack to manage changes in the application state, allow the user to use their hardware back buttons, or offer a simple programmatic back button experience by using the history API - window.history.go(-1)</p>

<h3 id="toc-letuserchoose">Let the user choose when to go full screen</h3>
<p>There is nothing more annoying to the user on the web than doing what they don't expect.  When a user is navigating the your site don't try and trick them into fullscreen.</p>

<p>Don't intercept the first touch event and issue a requestFullScreen.</p>
<ol>
  <li>it is annoying</li>
  <li>Browsers may decided to prompt the user at some point in the future about allowing the app to take up the full screen.</li>
</ol>

<p>If you want to launch apps full screen do think about using the install experiences for each platform.</p>

<h3 id="toc-nospam">Don't spam the user to install your app to a homescreen</h3>
<p>If you plan on offering a full screen experience via the installed app mechanisms, then just because you have the ability to detect if a user's app is not running as an installed app does not mean the user wants to install your app all the time. </p> 

<h3 id="toc-documentfullscreen">Making the document full screen</h3>
<p>It is natural to think that you take the body element full screen, but if you are on a WebKit or Blink based rendering engine you will see it has an odd effect of shrinking the body width to the smallest possible size that will contain all the content (Mozilla Gecko is fine). This is more than likely is not what you want.  Instead use:</p>

<pre class="prettyprint">document.documentElement.requestFullScreen();</pre>

<h3 id="toc-videofullscreen">Making a video element full screen</h3>
<p>To make a video element fullscreen it is exactly the same as making any other element full screen.  You call the `requestFullScreen` method on the video element.</p>
<pre class="prettyprint">&lt;video id=videoElement>&lt;/video>
&lt;button id="goFS">Go Fullscreen&lt;/button> 
&lt;script>
   var goFS = document.getElementById("goFS");
   goFS.addEventListener("click", function() {
      var videoElement = document.getElementById("videoElement");
      videoElement.requestFullScreen();
   }, false);
&lt;/script></pre>

<p>If your &lt;video&gt; element does not have the controls attribute defined, there will be no way for the user to control the video once they are full screen.  The recommended way to do this is to have a basic container that wraps the video and the controls that you want the user to see.</p>

<pre class="prettyprint">&lt;div id="container">
  &lt;video>&lt;video>
  &lt;div>
    &lt;button>Play&lt;button>
    &lt;button>Stop&lt;button>
    &lt;button id="goFS">Go full screen&lt;button> 
  &lt;div>
&lt;div>
&lt;script>
   var goFS = document.getElementById("goFS");
   goFS.addEventListener("click", function() {
      var container = document.getElementById("container");
      container.requestFullScreen();
   }, false);
&lt;script></pre>

<p>This actually gives you a lot more flexibility because you can combine the container object with the CSS pseudo selector (for example to hide the "goFS" button.)</p>

<pre class="prettyprint">&lt;style>
#goFS::full-screen #goFS {
  display: none;
} 
#goFS::-webkit-full-screen #goFS {
  display: none;
} 
#goFS::-moz-full-screen #goFS {
  display: none;
} 
&lt;style></pre>

<h2 id="conslusions">Conclusions</h2>
<p>Whilst we don't have a full standardised and implemented API, using some of the guidance presented in this article you can easily build experiences that take advantage of the users entire screen irrespective of the client.</p>

<blockquote class="commentary talkinghead talkinghead-pk">If you know of any good patterns for full-screen, leave a comment and we can let the world know.  If you know of anti-patterns in full-screen let us know so we can update the article to save the frustrations of millions of users on the web. </blockquote>

{% endblock %}
