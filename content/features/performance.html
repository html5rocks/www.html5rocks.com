{% extends "feature.html" %}
{% load i18n %}
{% get_current_language as LANGUAGE_CODE %}

{% block headtitle %}{% trans "Performance" %}{% endblock %}
{% block h2title   %}{% trans "Performance" %}{% endblock %}
{% block tuttags   %}performance{% endblock %}
{% block updatesblockstyle %}two_columns{% endblock %}
{% block supportblockstyle %}none{% endblock %}

{% block header %}
  <section id="intro">
    <p class="intro">
      {% blocktrans %}
        Modern browsers can deliver sites and applications that rival the performance of native and across loads of device types and screens. This performance does not come for free, however, and as developers we need to use a variety of techniques and technologies to get the most out of the browser. Performance is a critical part of user experience, it's a constant theme across all aspects of your development and product.

      {% endblocktrans %}
    </p>
  </section>
{% endblock %}


{% block description %}
  <section id="description">
    <h3>{% trans "Performance Is a Feature" %}</h3>
    <p>
      {% blocktrans %}
       Modern web applications are complex bunches of interrelated code paths and resource requirements, which in order to deliver the best user experience, must all work in harmony.  To make sense of this dependency graph, we find it helpful to view web application performance from three pillars: Network, Compute, and Render. Each pillar has their own nuances, solutions and interdependencies with each other. Great performing Web Applications will ace all three to deliver the best user experience possible.

      {% endblocktrans %}
    </p>
  </section>
{% endblock %}


{% block tutorials %}
{% endblock %}


{% block content %}

  <section id="NetworkPerformance">
    <h3>Network Performance</h3>
   {% blocktrans %}
     High performance networking is a keystone of every performance strategy - after all, if the browser is blocked on the network, waiting for the resources to arrive, then there is not much else we can do or optimize! Fast page load times, and optimized delivery of resources, translate to higher user engagement, increased conversions, and lower bounce rates.
  {% endblocktrans %}
<h3>Key Issues</h3>
<ul class="definitions">
<li>
  <strong>{% trans "Every millisecond counts" %}</strong> 
  <span>{% trans "1000 ms delay == 7% loss in conversions (Aberdeen)" %}</span>
</li>
<li>
    <strong>{% trans "Unnecessary networks roundtrips" %}</strong> 
    <span>{% trans "Blocking resources delay the rendering of the page, causing unnecessary delays and wait times for the user." %}</span>
</li>
<li><strong>{% trans "Make sure that assets are compressed when transferred and cached on the client" %}</strong> 
</li>
<li><strong>{% trans "Minimize payload size: compress images, minify your CSS, JS and HTML" %}</strong> 
</li>
<li><strong>{% trans "Eliminate blocking resources" %}</strong> 
</li>
<li><strong>{% trans "Eliminate unnecessary redirects" %}</strong> 
</li>
<li><strong>{% trans "Optimize server response times (&gt;100ms)" %}</strong> 
</li>
<li><strong>{% trans "Automate performance best practices" %}</strong> 
</li>
<li>
  <strong>{% trans "You can hand-optimize your site (that’s cool!), or, consider PageSpeed optimization" %}</strong>
  <span>{% blocktrans %}Such as <a href="http://modpagespeed.com">mod_pagespeed</a> (apache), <a href="http://ngxpagespeed.com">ngx_pagespeed</a> (nginx), or <a href="https://developers.google.com/speed/pagespeed/service">PageSpeed Service</a>. And even use webpagetest.org/compare to run a side-by-side test!{% endblocktrans %}</span>
</li>
</ul>

<h3>Tools</h3>
<ul>
  <li>Install <a href="https://developers.google.com/speed/pagespeed/insights">PageSpeed Insights</a> extension: it’s a performance linter for your site. 
  <li>DevTools + remote debugging allows you to get real-world latency, cache, etc, performance from your mobile (and desktop) device.
</ul>


<h3>Further Reading</h3>
<ul>
  <li><a href="https://developers.google.com/speed/docs/best-practices/rules_intro">Web Performance Best Practices</a>
  <li><a href="https://developers.google.com/speed/articles/">Web Performance Tutorials</a>
  <li><a href="http://www.igvita.com/2013/01/15/faster-websites-crash-course-on-web-performance/">Faster Websites: Crash Course on Web Performance</a> (video)
  <li><a href="http://www.youtube.com/watch?v=uR5urTx8S4E">Automating Performance Best Practices with PageSpeed</a> (video)
</ul>

  </section>














 <section id="ComputePerformance">
    <h3>Compute Performance</h3>
   {% blocktrans %}Runtime performance is just as important to user perception as load times, so keeping users who’ve already loaded your site happy is just as important as acquiring new users. Most performance issues that come from the compute layer stem from Javascript computation; which gives you a few key things to focus on: algorithmic complexity, Memory usage patterns, and unoptimized code.{% endblocktrans %}

<h3>Key Issues</h3>
<ul class="definitions">
<li>
  <strong>{% trans "Memory Churn Kills Performance!" %}</strong> 
  <span>{% trans "Churn causes GCs, which eat away at your frame-time." %}</span>
</li>

<li>
  <strong>{% trans "Manipulate strings as little as possible." %}</strong> 
  <span>{% trans "String manipulation often has side-effects and leak memory without you knowing." %}</span>
</li>
<li>
  <strong>{% trans "JavaScript VMs like lots of small functions" %}</strong> 
  <span>{% trans "They can inline and fast-compute them." %}</span>
</li>

<li>
  <strong>{% blocktrans %}Be on the lookout for any <a href="http://youtu.be/VhpdsjBUS3g">code which may be un-optimized</a>{% endblocktrans %}</strong> 
  <span>{% trans "Unoptimized  code can cause a slew of problems, including memory issues, and slower code paths." %}</span>
</li>
</ul>


<h3>Tools</h3>
<ul>
  <li><a href="https://developers.google.com/chrome-developer-tools/docs/cpu-profiling">Devtools CPU Profile</a> can let you see what function is taking the bulk of your time.
  <li><a href="https://www.youtube.com/watch?feature=player_embedded&v=nxXkquTPng8">Chrome tracing</a> is great for getting structural, and sample based profiling inside of Google Chrome.
  <li>Get more data insight with the <a href="https://github.com/google/tracing-framework">Web Tracing Framework</a>
  <li>Need more info on what's under the hood? <a href="https://developers.google.com/v8/profiler_example">Chrome’s V8 profiling framework</a> will let you know how the VM is reacting to your code

    
</ul>


<h3>Further Reading</h3>
<ul>
  <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management?redirectlocale=en-US&redirectslug=JavaScript%2FMemory_Management">Javascript Memory Management</a></li>
  <li><a href="http://youtu.be/0UNWi7FA36M?t=27m46s">Compute Performance Checklist for the mobile web</a></li>
  <li><a href="http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/">Writing Fast, Memory-efficient Javascript</a></li>
  <li><a href="http://beej.us/blog/data/object-pool/">Using Object Pools to reduce memory churn</a></li>
  <li><a href="http://buildnewgames.com/garbage-collector-friendly-code/">High performance, garbage collector friendly code</a></li>
  <li><a href="http://mrale.ph/blog/2011/12/18/v8-optimization-checklist.html">I-Want-To-Optimize-my-JS-application-for-chrome checklist</a></li>
  <li><a href="http://www.youtube.com/watch?v=UJPdhx5zTaw">Breaking the javascript speed limit with v8</a></li>
  <li><a href="http://youtu.be/XAqIpGU8ZZk?t=8m19s">From Console to Chrome : Making fast javascript</a></li>
  <li><a href="http://allyoucanleet.com/post/52667781698/jsconf-us-13-screencast">Perf the web forward</a></li>


</ul>

  </section>







 <section id="RenderPerformance">
    <h3>Render Performance</h3>
   {% blocktrans %}How quickly data becomes pixels on the screen is critical to your app’s success. Users notice when the frame rate drops; it reduces engagement and costs you happy users. Whenever users scroll or interact with your site or application you want to give the browser the least amount of work possible to update the pixels on the screen. When dealing with rendering performance we’re looking to reduce both the size and complexity of painting operations.{% endblocktrans %}

<h3>Key Issues</h3>
<ul class="definitions">
<li>
  <strong>{% trans "Destroy all jank - target 60fps!" %}</strong> 
  <span>{% trans "1000 ms delay == 7% loss in conversions (Aberdeen)" %}</span>
</li>
<li>
    <strong>{% trans "Check your layout costs" %}</strong> 
    <span> {% blocktrans %}<ul><li>How much time is being spent calculating the positions and dimensions of your elements?
      <li>Are you invalidating more of the tree than you anticipated? Check the scope of your layout operations.
      <li>Are you causing layouts to happen multiple times within a single piece of JavaScript?</li></ul>{% endblocktrans %}
  </span>
</li>

<li>
    <strong>{% trans "Check your style recalculations" %}</strong> 
    <span> {% blocktrans %}
      <ul>
      <li>How expensive is it to figure out which styles apply to which elements?
      <li>Are you changing more styles than you anticipated? Check the scope of your style changes and keep them to a minimum!
    
      </ul>
      {% endblocktrans %}
  </span>
</li>

<li>
    <strong>{% trans "Check the paint areas" %}</strong> 
    <span> {% blocktrans %}
      <ul>
        <li>You want small paint areas
        <li>You really don’t want to see fullscreen paints
        <li>Make the most of GPU acceleration
      </ul>
      {% endblocktrans %}
  </span>
</li>

<li>
    <strong>{% trans "Check the paint complexity" %}</strong> 
    <span> {% blocktrans %}
      <ul>
        <li>You want to reduce the complexity. Check the styles and watch out for “death by a thousand cuts” problems e.g. semi-expensive styles applied to many elements
        <li>Take note of image decodes and resizes; they are potentially very expensive and will very easily cause you to miss your target frame rate
      </ul>
      {% endblocktrans %}
  </span>
</li>


</ul>

<h3>Tools</h3>
<ul>
  <li>Chrome DevTools timeline is your first port of call;Fire up frame mode and check scrolling and interactions!
  <li>Chrome tracing for advanced debugging
    <ul>
    <li>Take a trace. You are looking for more detail regarding image decodes, resizes and PaintContents calls.
  <li>Hopefully you will be able to do the majority of your debugging in DevTools, though!
</ul>
</ul>


<h3>Further Reading</h3>
<ul>
  <li><a href="http://www.html5rocks.com/tutorials/speed/unnecessary-paints/">Avoiding Unnecessary Paints</a></li>
  <li><a href="http://www.html5rocks.com/tutorials/speed/scrolling/">Scrolling Performance</a></li>
  <li><a href="http://www.html5rocks.com/tutorials/speed/parallax/">Parallaxin’</a></li>
  <li><a href="http://www.html5rocks.com/tutorials/canvas/hidpi/">High DPI Canvas</a></li>
  <li><a href="http://www.html5rocks.com/tutorials/speed/animations/">Leaner, Meaner, Faster Animations with requestAnimationFrame</a></li>
  <li><a href="https://developers.google.com/events/io/sessions/325091862">Web page design with the GPU in mind</a></li>
  <li><a href="http://www.smashingmagazine.com/2013/06/10/pinterest-paint-performance-case-study/">Rendering Performance test for ‘pinterest’</a></li>
  <li><a href="http://coding.smashingmagazine.com/2013/03/04/animating-web-gonna-need-bigger-api/">Using CSS to get faster, smoother animations</a></li>
  <li><a href="http://alistapart.com/article/improving-ux-through-front-end-performance">How Fast UX is all about performance.</a></li>
  <li><a href="http://kellegous.com/j/2013/01/26/layout-performance/">On Layout and web performance</a></li>
  <li><a href="http://youtu.be/bMZZOzuJCgk">How to debug painting performance issues</a></li>

</ul>

  </section>


  <section id="further_reading">
    <h3>Getting Social</h3>
    <ul>
      <li><a href="https://plus.google.com/u/0/communities/113993151878673122189">Google+ Web Performance Community</a></li>
      <li><a href="https://twitter.com/search?q=%23perfmatters&src=hash">The #perfmatters tag on Twitter</a></li>
    </ul>
  </section>
{% endblock %}
